/*
 *	PROGRAM:	Interactive SQL utility
 *	MODULE:		show.epp
 *	DESCRIPTION:	Display routines
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Revision 1.2  2000/11/19 07:02:49  fsg
 * Change in show.epp to use CHARACTER_LENGTH instead of FIELD_LENGTH in
 * SHOW PROCEDURE
 *
 * 19-May-2001 Claudio Valderrama.
 * Change to be in sync with extract.e: BLOB is not returned
 * by value but by descriptor.
 * 2001.09.21 Claudio Valderrama: Show correct mechanism for UDF parameters.
 * 2001.10.01 Claudio Valderrama: SHOW GRANTS works without any argument, too.
 *   Metadata extraction is slightly faster if SHOW_grants() knows the obj_type.
 *   Keyword USER is written when the grantee is a user and since the engine
 *   now supports GRANT...to ROLE role_name, ROLE is written when the grantee is
 *   indeed a role. When the grantee is a group, it's shown, too.
 * 2003.02.04 Dmitry Yemanov: support for universal triggers
 */

#include "firebird.h"
#include <stdio.h>
#include "../jrd/license.h"
#include <string.h>

#include "../yvalve/gds_proto.h"
#include "ibase.h"
#include "../isql/isql.h"
#include "../jrd/intl.h"
#include "../common/intlobj_new.h"
#include "../common/StdHelper.h"
#include "../common/classes/AlignedBuffer.h"
#include "../common/classes/ClumpletReader.h"
#include "../isql/isql_proto.h"
#include "../isql/show_proto.h"
#include "../isql/iutils_proto.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../isql/extra_proto.h"
#include "../common/utils_proto.h"
#include "../jrd/constants.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/VaryStr.h"
#include "../common/classes/ImplementHelper.h"
#include "../common/classes/MetaString.h"
#include "../common/TimeZoneUtil.h"
#include "../isql/OptionsBase.h"

#include <firebird/Interface.h>

#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

using namespace Firebird;
using MsgFormat::SafeArg;


//DATABASE DB = EXTERN COMPILETIME "yachts.lnk";
DATABASE DB = EXTERN COMPILETIME "yachts.lnk" RUNTIME isqlGlob.global_Db_name;


// This enumeration tell comment-related routines how to behave: for SHOW,
// we present names and text as they are. For EXTRACT, we need to make a valid
// script and escape double quotes in identifiers and single quotes in strings.
enum commentMode {cmmShow, cmmExtract};


static void make_priv_string(USHORT, char*, bool);
static processing_state show_all_tables(SSHORT);
static void show_charsets(SSHORT char_set_id, SSHORT collation);
static processing_state show_check(const std::optional<QualifiedMetaString>& name);
static processing_state show_collations(const std::optional<QualifiedMetaString>& name,
	SSHORT sys_flag, const char* msg = nullptr, bool compact = false);
static void show_comment(const char* objtype, const QualifiedMetaString& name, const MetaString& name2,
	ISC_QUAD* blobfld, const commentMode showextract, const char* banner);
static processing_state show_comments(const commentMode showextract, const char* banner);
static void show_db();
static processing_state show_dependencies(const std::optional<QualifiedMetaString>& name);
static processing_state show_dependencies(const QualifiedMetaString& name, int obj_type);
static processing_state show_dialect();
static processing_state show_domains(const std::optional<QualifiedMetaString>& name);
static processing_state show_exceptions(const std::optional<QualifiedMetaString>& name);
static processing_state show_filters(const std::optional<MetaString>& name);
static processing_state show_functions(const std::optional<QualifiedMetaString>& name,
	bool system, const char* msg = nullptr);
static processing_state show_func_legacy(const QualifiedMetaString& name);
static processing_state show_func(const QualifiedMetaString& name);
static processing_state show_generators(const std::optional<QualifiedMetaString>& name);
static void show_index(const QualifiedMetaString&, const QualifiedMetaString&, const SSHORT, const SSHORT, const SSHORT);
static processing_state show_indices(const std::optional<QualifiedMetaString>& name);
static processing_state show_proc(const std::optional<QualifiedMetaString>& name, bool, const char* msg = nullptr);
static processing_state show_packages(const std::optional<QualifiedMetaString>& name, bool, const SCHAR* = nullptr);
static processing_state show_publications(const std::optional<MetaString>& name, bool, const SCHAR* = nullptr);
static void show_pub_table(const QualifiedMetaString& name);
static processing_state show_role(const std::optional<MetaString>& name, bool, const char* msg = nullptr);
static processing_state show_schemas(const std::optional<MetaString>& name, bool, const char* msg = nullptr);
static processing_state show_secclass(const std::optional<QualifiedMetaString>& object, bool detail);
static processing_state show_table(const QualifiedMetaString& name, bool);
static processing_state show_trigger(const std::optional<QualifiedMetaString>& name, bool, bool);
static processing_state show_users();
static processing_state show_users12();
static processing_state show_wireStats();

const char* const spaces = "                                ";
static TEXT Print_buffer[512];
static bool reReadDbOwner = true;


namespace {

// Used to make sure that local calls to print stuff go to isqlGlob.Out
// and not to stdout if IUtil::version gets called

class VersionCallback :
	public Firebird::AutoIface<Firebird::IVersionCallbackImpl<VersionCallback, Firebird::CheckStatusWrapper> >
{
public:
	// IVersionCallback implementation
	void callback(Firebird::CheckStatusWrapper*, const char* text)
	{
		isqlGlob.printf("%s%s", text, NEWLINE);
	}
};

} // anonymous namespace


static SINT64 ISQL_vax_integer(const UCHAR* bytes, USHORT length)
{
	return isc_portable_integer(bytes, length);
}


// Initialize types

// Keep this array in sync with obj.h in jrd.
static const SCHAR* Object_types[] =
{
	"Table",
	"View",
	"Trigger",
	"Computed column",
	"Validation",
	"Procedure",
	"Expression index",
	"Exception",
	"User",
	"Domain",
	"Index",
	"Count [error if used]",
	"User group",
	"SQL role",
	"Generator",
	"User defined function",
	"Blob filter",	// impossible to have explicit dependencies on it, but...
	"Collation"
};



const SCHAR* Trigger_prefix_types[] =
{
	"BEFORE",			// keyword
	"AFTER"				// keyword
};

const SCHAR* Trigger_suffix_types[] =
{
	"",
	"INSERT",			// keyword
	"UPDATE",			// keyword
	"DELETE"			// keyword
};

const SCHAR* Db_trigger_types[] =
{
	"CONNECT",				// keyword
	"DISCONNECT",			// keyword
	"TRANSACTION START",	// keyword
	"TRANSACTION COMMIT",	// keyword
	"TRANSACTION ROLLBACK"	// keyword
};


enum priv_flag {
	priv_UNKNOWN	= 1,
	priv_SELECT	= 2,
	priv_INSERT	= 4,
	priv_UPDATE	= 8,
	priv_DELETE	= 16,
	priv_EXECUTE	= 32,
	priv_REFERENCES	= 64,
	priv_CREATE = 128,
	priv_ALTER = 256,
	priv_DROP = 512
};


static const struct
{
	USHORT priv_flag;
	const char* priv_string;
} privs[] =
{
	{ priv_DELETE, "DELETE"},			// keyword
	{ priv_EXECUTE, "EXECUTE"},			// keyword
	{ priv_INSERT, "INSERT"},			// keyword
	{ priv_SELECT, "SELECT"},			// keyword
	{ priv_UPDATE, "UPDATE"},			// keyword
	{ priv_REFERENCES, "REFERENCES"},	// keyword
	{ priv_CREATE, "CREATE"},			// keyword
	{ priv_ALTER, "ALTER"},				// keyword
	{ priv_DROP, "DROP"},				// keyword
	{ 0, NULL}
};

// strlen of each element above, + strlen(", ") for separators

const int MAX_PRIV_LIST = (6 + 2 + 7 + 2 + 6 + 2 + 6 + 2 + 6 + 2 + 10 + 2 + 6 + 2 + 5 + 2 + 4 + 1);

const int PRIV_UPDATE_POS = 4;
const int PRIV_REFERENCES_POS = 5;

const int RELATION_PRIV_ALL = priv_SELECT | priv_INSERT | priv_UPDATE | priv_DELETE | priv_REFERENCES;

struct PrivilegeFields
{
	const char* privilege;
	string fields;
};

// Added support to display FORCED WRITES status. - PR 27-NOV-2001
// Added support to display transaction info when next_transaction id is fixed.
// Added support to display ODS version. CVC 26-Aug-2004.
static const UCHAR db_items[] =
{
	isc_info_page_size,
	isc_info_db_size_in_pages,
	fb_info_pages_used,
	fb_info_pages_free,
	isc_info_sweep_interval,
	isc_info_limbo,
	isc_info_forced_writes,
	isc_info_oldest_transaction,
	isc_info_oldest_active,
	isc_info_oldest_snapshot,
	isc_info_next_transaction,
	isc_info_ods_version,
	isc_info_ods_minor_version,
#ifdef DEV_BUILD
	isc_info_db_id,
#endif
	fb_info_crypt_state,
	fb_info_protocol_version,
	fb_info_wire_crypt,
	fb_info_creation_timestamp_tz,
	isc_info_creation_date,
	fb_info_replica_mode,
	isc_info_end
};


/* BPB to force transliteration of any shown system blobs from
 * Database character set (CS_METADATA) to process character set
 * (CS_dynamic).
 * This same BPB is safe to use for both V3 & V4 db's - as
 * a V3 db will ignore the source_ & target_interp values.
 */
static const UCHAR metadata_text_bpb[] =
{
	isc_bpb_version1,
	isc_bpb_source_type, 1, isc_blob_text,
	isc_bpb_target_type, 1, isc_blob_text,
	isc_bpb_source_interp, 1, CS_METADATA,
	isc_bpb_target_interp, 1, CS_dynamic
};

// trigger action helpers

inline int TRIGGER_ACTION_PREFIX(int value)
{
	return (value + 1) & 1;
}

inline int TRIGGER_ACTION_SUFFIX(int value, int slot)
{
	return ((value + 1) >> (slot * 2 - 1)) & 3;
}

const string SHOW_trigger_action(SINT64 type)
{
	switch (type & TRIGGER_TYPE_MASK)
	{
	case TRIGGER_TYPE_DML:
		{
			char buffer[256];
			int prefix = TRIGGER_ACTION_PREFIX(type);
			strcpy(buffer, Trigger_prefix_types[prefix]);
			int suffix = TRIGGER_ACTION_SUFFIX(type, 1);
			strcat(buffer, " ");
			strcat(buffer, Trigger_suffix_types[suffix]);
			if ( (suffix = TRIGGER_ACTION_SUFFIX(type, 2)) )
			{
				strcat(buffer, " OR ");
				strcat(buffer, Trigger_suffix_types[suffix]);
			}
			if ( (suffix = TRIGGER_ACTION_SUFFIX(type, 3)) )
			{
				strcat(buffer, " OR ");
				strcat(buffer, Trigger_suffix_types[suffix]);
			}
			return buffer;
		}

	case TRIGGER_TYPE_DB:
		return string("ON ") + Db_trigger_types[type & ~TRIGGER_TYPE_DB];

	case TRIGGER_TYPE_DDL:
		{
			bool first = true;
			string buffer = Trigger_prefix_types[type & 1];

			if ((type & DDL_TRIGGER_ANY) == DDL_TRIGGER_ANY)
				buffer += " ANY DDL STATEMENT";
			else
			{
				for (SINT64 pos = 1; pos < 64; ++pos)
				{
					if (((1LL << pos) & TRIGGER_TYPE_MASK) || (type & (1LL << pos)) == 0)
						continue;

					if (first)
						first = false;
					else
						buffer += " OR";

					buffer += " ";

					if (pos < FB_NELEM(DDL_TRIGGER_ACTION_NAMES))
					{
						buffer += string(DDL_TRIGGER_ACTION_NAMES[pos][0]) + " " +
							DDL_TRIGGER_ACTION_NAMES[pos][1];
					}
					else
						buffer += "<unknown>";
				}
			}

			return buffer;
		}

	default:
		fb_assert(false);
		return "";
	}
}


// *************************
// S H O W _ c o m m e n t s
// *************************
// Extract database comments. Since it's called by the script extraction
// routine, it does nothing for ODS < 11, unless the force option is true.
void SHOW_comments(bool force)
{
	if (isqlGlob.major_ods >= ODS_VERSION11 || force)
	{
		char banner[BUFFER_LENGTH128];
		fb_utils::snprintf(banner, sizeof(banner), "%s/* Comments for database objects. */%s", NEWLINE, NEWLINE);
		show_comments(cmmExtract, banner);
	}
}


void SHOW_dbb_parameters(Firebird::IAttachment* db_handle,
						 const UCHAR* db_itemsL,
						 unsigned item_length,
						 bool translate,
						 const char* separator)
{
/**************************************
 *
 *	S H O W _ d b b _ p a r a m e t e r s
 *
 **************************************
 *
 * Functional description
 *	Show db_info on this database
 *
 *	Arguments:
 *	    db_handle -- database handle
 *	    db_itemsL -- list of db_info items to process
 *
 **************************************/
	UCHAR buffer[BUFFER_LENGTH400];
	TEXT msg[MSG_LENGTH];

	Firebird::AutoPtr<Firebird::IStatus, Firebird::SimpleDispose>
		status_vector(fbMaster->getStatus());
	Firebird::CheckStatusWrapper statusWrapper(status_vector);
	db_handle->getInfo(&statusWrapper, item_length, db_itemsL, sizeof(buffer), buffer);
	if (ISQL_errmsg(status_vector))
		return;

	bool crdatePrinted = false;

	for (Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		UCHAR item = p.getClumpTag();
		SINT64 value_out = 0;

		/*
		 * This is not the best solution but it fixes the lack of <LF> characters
		 * in Windows ISQL.  This will need to remain until we modify the messages
		 * to remove the '\n' (on the PC its '\n\r').
		 * CVC: WISQL is dead. I've restored the missing newlines for isql.
		 */
		switch (item)
		{
		case isc_info_end:
			break;

		case isc_info_page_size:
			value_out = p.getBigInt();
			isqlGlob.printf("PAGE_SIZE %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_db_size_in_pages:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages allocated = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_pages_used:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_USED_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages used = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_pages_free:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_FREE_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages free = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_crypt_state:
			value_out = p.getBigInt();
			if (translate)
			{
				Firebird::string s;
				if (value_out & fb_info_crypt_encrypted)
					IUTILS_msg_get(DATABASE_CRYPTED, msg);
				else
					IUTILS_msg_get(DATABASE_NOT_CRYPTED, msg);

				s = msg;

				if (value_out & fb_info_crypt_process)
				{
					s += ", ";
					IUTILS_msg_get(DATABASE_CRYPT_PROCESS, msg);
					s += msg;
				}

				isqlGlob.printf("%s%s", s.c_str(), separator);
			}
			else
			{
				isqlGlob.printf("DB %sencrypted%s%s",
					(value_out & fb_info_crypt_encrypted ? "" : "not "),
					(value_out & fb_info_crypt_process ? ", crypt thread not complete" : ""),
					separator);
			}
			break;

		case isc_info_sweep_interval:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(SWEEP_INTERV, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Sweep interval = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_forced_writes:
			value_out = p.getBigInt();
			isqlGlob.printf("Forced Writes are %s%s", (value_out == 1 ? "ON" : "OFF"), separator);
			break;

		case isc_info_oldest_transaction :
			value_out = p.getBigInt();
			isqlGlob.printf("Transaction - oldest = %" UQUADFORMAT"%s", static_cast<TraNumber>(value_out), separator);
			break;

		case isc_info_oldest_active :
			value_out = p.getBigInt();
			isqlGlob.printf("Transaction - oldest active = %" UQUADFORMAT"%s", static_cast<TraNumber>(value_out), separator);
			break;

		case isc_info_oldest_snapshot :
			value_out = p.getBigInt();
			isqlGlob.printf("Transaction - oldest snapshot = %" UQUADFORMAT"%s", static_cast<TraNumber>(value_out), separator);
			break;

		case isc_info_next_transaction :
			value_out = p.getBigInt();
			isqlGlob.printf("Transaction - Next = %" UQUADFORMAT"%s", static_cast<TraNumber>(value_out), separator);
			break;

		case isc_info_base_level:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(BASE_LEVEL, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Base level = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_limbo:
			value_out = p.getBigInt();
			if (translate)
			{
				IUTILS_msg_get(LIMBO, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Transaction in limbo = %" UQUADFORMAT"%s", static_cast<TraNumber>(value_out), separator);
			break;

		case isc_info_ods_version:
			isqlGlob.major_ods = p.getInt();
			break;
		case isc_info_ods_minor_version:
			value_out = p.getBigInt();
			isqlGlob.printf("ODS = %" SLONGFORMAT".%" SQUADFORMAT"%s",
					(SLONG) isqlGlob.major_ods, value_out, separator);
			break;

		case fb_info_wire_crypt:
			if (p.getClumpLength())
				isqlGlob.printf("Wire crypt plugin: %.*s%s", p.getClumpLength(), p.getBytes(), separator);
			break;

		case fb_info_protocol_version:
			value_out = p.getBigInt();
			if (value_out)
				isqlGlob.printf("Protocol version = %" SQUADFORMAT"%s", value_out, separator);
			else
				isqlGlob.printf("Embedded connection%s", separator);
			break;

		case isc_info_creation_date:
			if (p.getClumpLength() == sizeof(ISC_TIMESTAMP) && !crdatePrinted)
			{
				ISC_TIMESTAMP ts;

				const UCHAR* t = p.getBytes();
				ts.timestamp_date = ISQL_vax_integer(t, sizeof(ISC_DATE));
				t += sizeof(ISC_DATE);
				ts.timestamp_time = ISQL_vax_integer(t, sizeof(ISC_TIME));

				struct tm time;
				isc_decode_timestamp(&ts, &time);

				isqlGlob.printf("Creation date: %s %d, %d %d:%02d:%02d%s",
					FB_SHORT_MONTHS[time.tm_mon], time.tm_mday, time.tm_year + 1900,
					time.tm_hour, time.tm_min, time.tm_sec, separator);
			}
			break;

		case fb_info_creation_timestamp_tz:
			if (p.getClumpLength() == sizeof(ISC_TIMESTAMP))
			{
				ISC_TIMESTAMP_TZ tsz;

				const UCHAR* t = p.getBytes();
				tsz.utc_timestamp.timestamp_date = ISQL_vax_integer(t, sizeof(ISC_DATE));
				t += sizeof(ISC_DATE);
				tsz.utc_timestamp.timestamp_time = ISQL_vax_integer(t, sizeof(ISC_TIME));
				t += sizeof(ISC_TIME);
				tsz.time_zone = ISQL_vax_integer(t, sizeof(ULONG));

				unsigned year, month, day, hours, minutes, seconds, fractions;
				char timeZone[Firebird::TimeZoneUtil::MAX_SIZE];

				Firebird::UtilInterfacePtr()->decodeTimeStampTz(fbStatus, &tsz,
					&year, &month, &day, &hours, &minutes, &seconds, &fractions, sizeof(timeZone), timeZone);

				if (ISQL_errmsg(fbStatus))
					break;

				isqlGlob.printf("Creation date: %s %d, %d %d:%02d:%02d %s%s",
					FB_SHORT_MONTHS[month - 1], day, year,
					hours, minutes, seconds, timeZone, separator);

				crdatePrinted = true;
			}
			break;

#ifdef DEV_BUILD
		case isc_info_db_id:
			{
				// Will print with garbage for now.
				//It's sprintf(info, "DB/Host = %.*s", length, d);
				const UCHAR* s = p.getBytes();
				const UCHAR* end = s + p.getClumpLength();
				++s; // Skip useless indicator.
				int len = *s++;
				isqlGlob.printf("DB = %.*s\n", len, s);
				s += len;
				while (s < end)
				{
					len = *s++;
					isqlGlob.printf("Host = %.*s\n", len, s);
					s += len;
				}
			}
			break;
#endif

		case fb_info_replica_mode:
			{
				value_out = p.getBigInt();
				const char* mode =
					(value_out == fb_info_replica_none) ? "NONE" :
					(value_out == fb_info_replica_read_only) ? "READ_ONLY" :
					(value_out == fb_info_replica_read_write) ? "READ_WRITE" :
					"unknown";
				isqlGlob.printf("Replica mode: %s%s", mode, separator);
			}
			break;

		case isc_info_truncated:
			return;
		}
	}
}


void SHOW_read_owner()
{
/**************************************
 *
 *	S H O W _ r e a d _ o w n e r
 *
 **************************************
 *
 * Functional description
 *	Make granted_by() re-read db owner name.
 *
 **************************************/
	reReadDbOwner = true;
}


static string granted_by(const MetaString& grantor, bool nullGrantor)
{
/**************************************
 *
 *	g r a n t e d _ b y
 *
 **************************************
 *
 * Functional description
 *	Output message only if not granted by DB owner.
 *
 **************************************/
	static MetaString owner;

	if (reReadDbOwner)
	{
		// Get the owner name
		owner = DBA_USER_NAME;

		FOR REL IN RDB$RELATIONS
		WITH (REL.RDB$SCHEMA_NAME = SYSTEM_SCHEMA OR REL.RDB$SCHEMA_NAME MISSING) AND
			 REL.RDB$RELATION_NAME = "RDB$DATABASE"
		{
			if (!REL.RDB$OWNER_NAME.NULL)
				owner = REL.RDB$OWNER_NAME;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return "";
		END_ERROR

		reReadDbOwner = false;
	}

	if (grantor == owner || nullGrantor)
		return "";

	return " GRANTED BY " + IUTILS_name_to_string(grantor);
}


static void set_grantee(int user_type, const QualifiedMetaString& name, string& user_string)
{
	switch (user_type)
	{
	case obj_view:
		user_string.printf("VIEW %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_trigger:
		user_string.printf("TRIGGER %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_procedure:
		user_string.printf("PROCEDURE %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_udf:
		user_string.printf("FUNCTION %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_user:
		if (name.object == "PUBLIC")
			user_string.printf("USER %s", IUTILS_name_to_string(name).c_str());
		else
			user_string = IUTILS_name_to_string(name).c_str();
		break;
	case obj_user_group:
		user_string.printf("GROUP %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_sql_role:
		user_string.printf("ROLE %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_package_header:
		user_string.printf("PACKAGE %s", IUTILS_name_to_string(name).c_str());
		break;
	case obj_privilege:
		FOR T IN RDB$TYPES
			WITH T.RDB$FIELD_NAME EQ 'RDB$SYSTEM_PRIVILEGES' AND
				 T.RDB$TYPE EQ atoi(name.object.c_str())
		{
			user_string.printf("SYSTEM PRIVILEGE %s", fb_utils::exact_name(T.RDB$TYPE_NAME));
		}
		END_FOR
		break;
	default:
		user_string = IUTILS_name_to_string(name).c_str();
		break;
	}
}


static USHORT convert_privilege_to_code(char privilege)
{
	switch (privilege)
	{
	case 'S':
		return priv_SELECT;
	case 'I':
		return priv_INSERT;
	case 'U':
		return priv_UPDATE;
	case 'D':
		return priv_DELETE;
	case 'R':
		return priv_REFERENCES;
	case 'X':
	case 'G':
		// Execute should not be here
		return 0;
	}

	return priv_UNKNOWN;
}


static void make_privilege_string_with_fields(USHORT priv_flags,
											  const PrivilegeFields* priv_fields,
											  int priv_fields_count,
											  char* priv_string,
											  string& out_result)
{
	out_result = "";

	if (priv_flags)
	{
		make_priv_string(priv_flags, priv_string, false);
		out_result.assign(priv_string);
	}

	for (int i = 0; i < priv_fields_count; i++)
	{
		if (priv_fields[i].fields.isEmpty())
			continue;

		if (!out_result.isEmpty())
			out_result += ", ";
		out_result += priv_fields[i].privilege + (" (" + priv_fields[i].fields + ")");
	}
}


processing_state SHOW_ddl_grants(const std::optional<QualifiedMetaString>& name,
	const SCHAR* terminator, ObjectType obj_type, const TEXT* optional_msg)
{
	if (isqlGlob.major_ods < ODS_VERSION12)
		return OBJECT_NOT_FOUND;

	char priv_string[MAX_PRIV_LIST] = "";
	char with_option[19] = "";
	USHORT priv_flags = 0;
	string user_string;
	SCHAR obj_string[QUOTED_NAME_SIZE + 20];
	bool first = true;

	if (!name || name->schema.isEmpty())
	{
		FOR PRV IN RDB$USER_PRIVILEGES
			WITH PRV.RDB$GRANTOR NOT MISSING AND
				 PRV.RDB$OBJECT_TYPE >= obj_database
			SORTED BY PRV.RDB$RELATION_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$GRANT_OPTION
		{
			if (isqlGlob.major_ods >= ODS_VERSION14 && !PRV.RDB$RELATION_SCHEMA_NAME.NULL)
				continue;

			if (!isDdlObject(PRV.RDB$OBJECT_TYPE) || (obj_type != obj_any && PRV.RDB$OBJECT_TYPE != obj_type) ||
				(name && name->object != getDllSecurityName(PRV.RDB$OBJECT_TYPE)))
			{
				continue;
			}

			const MetaString relationSchemaName(PRV.RDB$RELATION_SCHEMA_NAME);

			if (first && optional_msg)
				isqlGlob.prints(optional_msg);

			// re-initialize strings
			priv_string[0] = '\0';
			with_option[0] = '\0';
			priv_flags = 0;

			first = false;

			// Only the first character is used for permissions

			const char c = PRV.RDB$PRIVILEGE[0];

			switch (c)
			{
			case 'C':
				priv_flags |= priv_CREATE;
				break;
			case 'L':
				priv_flags |= priv_ALTER;
				break;
			case 'O':
				priv_flags |= priv_DROP;
				break;
			default:
				priv_flags |= priv_UNKNOWN;
				break;
			}

			make_priv_string(priv_flags, priv_string, (PRV.RDB$OBJECT_TYPE != obj_database));

			set_grantee(PRV.RDB$USER_TYPE, QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

			strcpy(obj_string, getDdlObjectName(PRV.RDB$OBJECT_TYPE));

			if (PRV.RDB$GRANT_OPTION)
				strcpy(with_option, " WITH GRANT OPTION");
			else
				with_option[0] = '\0';

			isqlGlob.printf(
				"GRANT %s %s%s TO %s%s%s%s%s",
				priv_string,
				obj_string,
				(relationSchemaName.hasData() ?
					(" ON SCHEMA " + IUTILS_name_to_string(relationSchemaName)).c_str() :
					""
				),
				user_string.c_str(),
				with_option,
				granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
				terminator,
				NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (isqlGlob.major_ods >= ODS_VERSION14)
		{
			FOR PRV IN RDB$USER_PRIVILEGES
				CROSS SCH IN RDB$SCHEMAS
				WITH SCH.RDB$SCHEMA_NAME EQ PRV.RDB$RELATION_SCHEMA_NAME AND
					 PRV.RDB$GRANTOR NOT MISSING AND
					 PRV.RDB$OBJECT_TYPE >= obj_database AND
					 SCH.RDB$OWNER_NAME NE PRV.RDB$USER
				SORTED BY PRV.RDB$RELATION_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$GRANT_OPTION
			{
				if (!isDdlObject(PRV.RDB$OBJECT_TYPE) || (obj_type != obj_any && PRV.RDB$OBJECT_TYPE != obj_type) ||
					(name && name->object != getDllSecurityName(PRV.RDB$OBJECT_TYPE)))
				{
					continue;
				}

				const MetaString relationSchemaName(PRV.RDB$RELATION_SCHEMA_NAME);

				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				// re-initialize strings
				priv_string[0] = '\0';
				with_option[0] = '\0';
				priv_flags = 0;

				first = false;

				// Only the first character is used for permissions

				const char c = PRV.RDB$PRIVILEGE[0];

				switch (c)
				{
				case 'C':
					priv_flags |= priv_CREATE;
					break;
				case 'L':
					priv_flags |= priv_ALTER;
					break;
				case 'O':
					priv_flags |= priv_DROP;
					break;
				default:
					priv_flags |= priv_UNKNOWN;
					break;
				}

				make_priv_string(priv_flags, priv_string, (PRV.RDB$OBJECT_TYPE != obj_database));

				set_grantee(PRV.RDB$USER_TYPE, QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

				strcpy(obj_string, getDdlObjectName(PRV.RDB$OBJECT_TYPE));

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH GRANT OPTION");
				else
					with_option[0] = '\0';

				isqlGlob.printf(
					"GRANT %s %s%s TO %s%s%s%s%s",
					priv_string,
					obj_string,
					(relationSchemaName.hasData() ?
						(" ON SCHEMA " + IUTILS_name_to_string(relationSchemaName)).c_str() :
						""
					),
					user_string.c_str(),
					with_option,
					granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
					terminator,
					NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		}
	}

	if (obj_type == obj_database || obj_type == obj_any)
	{
		FOR PRV IN SEC$DB_CREATORS
			SORTED BY PRV.SEC$USER_TYPE, PRV.SEC$USER
		{
			if (first && optional_msg)
				isqlGlob.prints(optional_msg);

			first = false;

			set_grantee(PRV.SEC$USER_TYPE, QualifiedMetaString(PRV.SEC$USER), user_string);

			isqlGlob.printf("GRANT CREATE DATABASE TO %s%s%s",
				user_string.c_str(), terminator, NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (!first)
		return (SKIP);

	return OBJECT_NOT_FOUND;
}


processing_state SHOW_grants(const std::optional<QualifiedMetaString>& name,
				  const SCHAR* terminator,
				  ObjectType obj_type,
				  const TEXT* optional_msg)
{
/**************************************
 *
 *	S H O W _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Show grants for given object name
 *	This function is also called by extract for privileges.
 *  	It must extract granted privileges on tables/views to users,
 *		- these may be compound, so put them on the same line.
 *	Grant execute privilege on procedures to users
 *	Grant various privilegs to procedures.
 *	All privileges may have the with_grant option set.
 *	The optional msg is to display a customized message. When the
 *	new feature of all grants is used, there's no way to print the
 *	header message after this routine, so it should be printed here.
 *
 **************************************/
	if (!name || name->object.isEmpty())
		return ps_ERR;

	QualifiedMetaString prev_user;
	BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION prev_grant_option;
	MetaString prev_grantor;
	string user_string;
	SCHAR obj_string[QUOTED_NAME_SIZE + 20];

	PrivilegeFields priv_fields[] =
	{
		{privs[PRIV_UPDATE_POS].priv_string, ""},
		{privs[PRIV_REFERENCES_POS].priv_string, ""}
	};
	const int priv_fields_count = FB_NELEM(priv_fields);

	bool first = true;

	// Query against user_privileges instead of looking at rdb$security_classes

	prev_grant_option = -1;
	char priv_string[MAX_PRIV_LIST] = "";
	char with_option[19] = "";
	USHORT priv_flags = 0;

	if (obj_type == obj_relation || obj_type == obj_any)
	{
		// Find the user specified relation and show its privileges

		FOR FIRST 1 R IN RDB$RELATIONS
			WITH R.RDB$RELATION_NAME EQ name->object.c_str()
			SORTED BY R.RDB$SCHEMA_NAME
		{
			if (name->schema.hasData() && name->schema != R.RDB$SCHEMA_NAME)
				continue;

			const QualifiedMetaString relationName(R.RDB$RELATION_NAME, R.RDB$SCHEMA_NAME);

			// This query only finds tables, eliminating owner privileges

			FOR PRV IN RDB$USER_PRIVILEGES CROSS
				REL IN RDB$RELATIONS
				WITH PRV.RDB$GRANTOR NOT MISSING AND
					 PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
					 PRV.RDB$RELATION_NAME EQ relationName.object.c_str() AND
					 REL.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
					 REL.RDB$RELATION_NAME EQ PRV.RDB$RELATION_NAME AND
					 PRV.RDB$PRIVILEGE     NE 'M' AND
					 REL.RDB$OWNER_NAME    NE PRV.RDB$USER
				SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$GRANT_OPTION, PRV.RDB$FIELD_NAME
			{
				const QualifiedMetaString user(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME);

				// Sometimes grant options are null, sometimes 0.  Both same

				if (PRV.RDB$GRANT_OPTION.NULL)
					PRV.RDB$GRANT_OPTION = 0;

				if (PRV.RDB$FIELD_NAME.NULL)
					PRV.RDB$FIELD_NAME[0] = '\0';

				// Print a new grant statement for each new user or change of option

				if (prev_grant_option != -1 &&
					(prev_user != user ||
					 prev_grant_option != PRV.RDB$GRANT_OPTION ||
					 prev_grantor != PRV.RDB$GRANTOR))
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);
					first = false;

					if (prev_grant_option)
						strcpy(with_option, " WITH GRANT OPTION");

					string combine_privileges = "";
					make_privilege_string_with_fields(priv_flags, priv_fields, priv_fields_count,
						priv_string, combine_privileges);

					isqlGlob.printf("GRANT %s ON %s TO %s%s%s%s%s",
						combine_privileges.c_str(),
						IUTILS_name_to_string(relationName).c_str(),
						user_string.c_str(), with_option, granted_by(prev_grantor, false).c_str(),
						terminator, NEWLINE);

					// re-initialize
					priv_flags = 0;
					with_option[0] = '\0';
					priv_string[0] = '\0';
					for (int i = 0; i < priv_fields_count; i++)
						priv_fields[i].fields = "";
				}

				// At each row, store this value for the next compare of contol break

				prev_user = user;
				prev_grant_option = PRV.RDB$GRANT_OPTION;
				prev_grantor = PRV.RDB$GRANTOR;

				set_grantee(PRV.RDB$USER_TYPE, user, user_string);

				// Only the first character is used for permissions
				const char c = PRV.RDB$PRIVILEGE[0];

				// Column level privileges for update and references only
				if (PRV.RDB$FIELD_NAME.NULL)
					priv_flags |= convert_privilege_to_code(c);
				else
				{
					for (int i = 0; i < priv_fields_count; i++)
					{
						if (c == priv_fields[i].privilege[0])
						{
							if (priv_fields[i].fields.hasData())
								priv_fields[i].fields += ", ";

							priv_fields[i].fields += IUTILS_name_to_string(PRV.RDB$FIELD_NAME);
							break;
						}
					}
				}
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR

			// Print last case if there was anything to print

			if (prev_grant_option != -1)
			{
				if (first && optional_msg)
					isqlGlob.prints(optional_msg);
				first = false;

				if (prev_grant_option)
					strcpy(with_option, " WITH GRANT OPTION");

				string combine_privileges;
				make_privilege_string_with_fields(priv_flags, priv_fields, priv_fields_count,
					priv_string, combine_privileges);

				isqlGlob.printf("GRANT %s ON %s TO %s%s%s%s%s",
					combine_privileges.c_str(),
					IUTILS_name_to_string(relationName).c_str(),
					user_string.c_str(), with_option, granted_by(prev_grantor, false).c_str(),
					terminator, NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			return (SKIP);
	}

	// No relation called "object" was found, try procedure "object"
	if (obj_type == obj_procedure || obj_type == obj_any)
	{
		FOR FIRST 1 P IN RDB$PROCEDURES
			WITH P.RDB$PROCEDURE_NAME EQ name->object.c_str() AND
				 P.RDB$PACKAGE_NAME MISSING
			SORTED BY P.RDB$SCHEMA_NAME
		{
			if (name->schema.hasData() && name->schema != P.RDB$SCHEMA_NAME)
				continue;

			const QualifiedMetaString procedureName(P.RDB$PROCEDURE_NAME, P.RDB$SCHEMA_NAME);

			// Part two is for stored procedures only

			FOR PRV IN RDB$USER_PRIVILEGES CROSS
				PRC IN RDB$PROCEDURES WITH
				PRV.RDB$GRANTOR NOT MISSING AND
				PRV.RDB$OBJECT_TYPE = obj_procedure AND
				PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(procedureName.schema.c_str(), '') AND
				PRV.RDB$RELATION_NAME EQ procedureName.object.c_str() AND
				PRC.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
				PRC.RDB$PROCEDURE_NAME EQ PRV.RDB$RELATION_NAME AND
				PRV.RDB$PRIVILEGE EQ 'X' AND
				PRC.RDB$OWNER_NAME NE PRV.RDB$USER AND
				PRC.RDB$PACKAGE_NAME MISSING
				SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
			{
				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				first = false;

				set_grantee(PRV.RDB$USER_TYPE, QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH GRANT OPTION");
				else
					with_option[0] = '\0';

				isqlGlob.printf("GRANT EXECUTE ON PROCEDURE %s TO %s%s%s%s%s",
						 IUTILS_name_to_string(procedureName).c_str(),
						 user_string.c_str(), with_option,
						 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(), terminator, NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			return (SKIP);
	}

	// No procedure called "object" was found, try role "object"

	if ((obj_type == obj_sql_role || obj_type == obj_any) && name->schema.isEmpty())
	{
		// No procedure called "object" was found, try role "object"
		// CVC: This code could be superseded by SHOW_grant_roles() below
		// with the sole difference of the sort fields.
		// This part is only used by SHOW GRANT <object> command
		// Metadata extraction and SHOW GRANT with no param uses SHOW_grant_roles.

		FOR FIRST 1 R IN RDB$ROLES
			WITH R.RDB$ROLE_NAME EQ name->object.c_str()
		{
			FOR PRV IN RDB$USER_PRIVILEGES
				WITH PRV.RDB$GRANTOR NOT MISSING AND
					 PRV.RDB$OBJECT_TYPE EQ obj_sql_role AND
					 (PRV.RDB$USER_TYPE EQ obj_user OR
					  PRV.RDB$USER_TYPE EQ obj_sql_role) AND
					 PRV.RDB$RELATION_NAME EQ name->object.c_str() AND
					 PRV.RDB$PRIVILEGE EQ 'M'
				SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER
			{
				MetaString role_name(PRV.RDB$RELATION_NAME);

				user_string = IUTILS_name_to_string(PRV.RDB$USER);

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH ADMIN OPTION");
				else
					with_option[0] = '\0';

				const char* default_option = "";
				if (!PRV.RDB$FIELD_NAME.NULL && PRV.RDB$FIELD_NAME[0] == 'D')
					default_option = " DEFAULT";

				fb_utils::snprintf(Print_buffer, sizeof(Print_buffer), "GRANT%s %s TO %s%s%s%s%s",
						default_option,
						IUTILS_name_to_string(role_name).c_str(),
						user_string.c_str(), with_option, granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
						terminator, NEWLINE);

				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				first = false;
				isqlGlob.prints(Print_buffer);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			return (SKIP);
	}

	if (obj_type == obj_package_header || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 P IN RDB$PACKAGES
				WITH P.RDB$PACKAGE_NAME EQ name->object.c_str()
				SORTED BY P.RDB$SCHEMA_NAME
			{
				if (name->schema.hasData() && name->schema != P.RDB$SCHEMA_NAME)
					continue;

				const QualifiedMetaString packageName(P.RDB$PACKAGE_NAME, P.RDB$SCHEMA_NAME);

				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					PACK IN RDB$PACKAGES WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_package_header AND
					PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(packageName.schema.c_str(), '') AND
					PRV.RDB$RELATION_NAME EQ packageName.object.c_str() AND
					PACK.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
					PACK.RDB$PACKAGE_NAME EQ PRV.RDB$RELATION_NAME AND
					PRV.RDB$PRIVILEGE EQ 'X' AND
					PACK.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;

					set_grantee(PRV.RDB$USER_TYPE, QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					isqlGlob.printf("GRANT EXECUTE ON PACKAGE %s TO %s%s%s%s%s",
							 IUTILS_name_to_string(packageName).c_str(),
							 user_string.c_str(), with_option,
							 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
							 terminator, NEWLINE);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_udf || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 F IN RDB$FUNCTIONS
				WITH F.RDB$FUNCTION_NAME EQ name->object.c_str() AND
					 F.RDB$PACKAGE_NAME MISSING
				SORTED BY F.RDB$SCHEMA_NAME
			{
				if (name->schema.hasData() && name->schema != F.RDB$SCHEMA_NAME)
					continue;

				const QualifiedMetaString functionName(F.RDB$FUNCTION_NAME, F.RDB$SCHEMA_NAME);

				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					FUN IN RDB$FUNCTIONS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_udf AND
					PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(functionName.schema.c_str(), '') AND
					PRV.RDB$RELATION_NAME EQ functionName.object.c_str() AND
					FUN.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
					FUN.RDB$FUNCTION_NAME EQ PRV.RDB$RELATION_NAME AND
					FUN.RDB$PACKAGE_NAME MISSING AND
					PRV.RDB$PRIVILEGE EQ 'X' AND
					FUN.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;

					set_grantee(PRV.RDB$USER_TYPE,
						QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					isqlGlob.printf("GRANT EXECUTE ON FUNCTION %s TO %s%s%s%s%s",
							 IUTILS_name_to_string(functionName).c_str(),
							 user_string.c_str(), with_option,
							 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
							 terminator, NEWLINE);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_generator || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 G IN RDB$GENERATORS
				WITH G.RDB$GENERATOR_NAME EQ name->object.c_str()
				SORTED BY G.RDB$SCHEMA_NAME
			{
				if (name->schema.hasData() && name->schema != G.RDB$SCHEMA_NAME)
					continue;

				const QualifiedMetaString generatorName(G.RDB$GENERATOR_NAME, G.RDB$SCHEMA_NAME);

				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					GEN IN RDB$GENERATORS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_generator AND
					PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(generatorName.schema.c_str(), '') AND
					PRV.RDB$RELATION_NAME EQ generatorName.object.c_str() AND
					GEN.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
					GEN.RDB$GENERATOR_NAME EQ PRV.RDB$RELATION_NAME AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					GEN.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;

					set_grantee(PRV.RDB$USER_TYPE,
						QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					isqlGlob.printf("GRANT USAGE ON SEQUENCE %s TO %s%s%s%s%s",
							 IUTILS_name_to_string(generatorName).c_str(),
							 user_string.c_str(), with_option,
							 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
							 terminator, NEWLINE);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_exception || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 E IN RDB$EXCEPTIONS
				WITH E.RDB$EXCEPTION_NAME EQ name->object.c_str()
				SORTED BY E.RDB$SCHEMA_NAME
			{
				if (name->schema.hasData() && name->schema != E.RDB$SCHEMA_NAME)
					continue;

				const QualifiedMetaString exceptionName(E.RDB$EXCEPTION_NAME, E.RDB$SCHEMA_NAME);

				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					XCP IN RDB$EXCEPTIONS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_exception AND
					PRV.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(exceptionName.schema.c_str(), '') AND
					PRV.RDB$RELATION_NAME EQ exceptionName.object.c_str() AND
					XCP.RDB$SCHEMA_NAME EQUIV PRV.RDB$RELATION_SCHEMA_NAME AND
					XCP.RDB$EXCEPTION_NAME EQ PRV.RDB$RELATION_NAME AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					XCP.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;

					set_grantee(PRV.RDB$USER_TYPE,
						QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME), user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					isqlGlob.printf("GRANT USAGE ON EXCEPTION %s TO %s%s%s%s%s",
							 IUTILS_name_to_string(exceptionName).c_str(),
							 user_string.c_str(), with_option,
							 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
							 terminator, NEWLINE);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if ((obj_type == obj_schema || obj_type == obj_any) && name->schema.isEmpty())
	{
		if (isqlGlob.major_ods >= ODS_VERSION14)
		{
			FOR PRV IN RDB$USER_PRIVILEGES CROSS
				SCH IN RDB$SCHEMAS WITH
				PRV.RDB$GRANTOR NOT MISSING AND
				PRV.RDB$OBJECT_TYPE = obj_schema AND
				PRV.RDB$RELATION_NAME EQ name->object.c_str() AND
				SCH.RDB$SCHEMA_NAME EQ PRV.RDB$RELATION_NAME AND
				PRV.RDB$PRIVILEGE EQ 'G' AND
				SCH.RDB$OWNER_NAME NE PRV.RDB$USER
				SORTED BY SCH.RDB$SCHEMA_NAME, PRV.RDB$USER_SCHEMA_NAME, PRV.RDB$USER,
						  PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION
			{
				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				first = false;

				set_grantee(
					PRV.RDB$USER_TYPE,
					QualifiedMetaString(PRV.RDB$USER, PRV.RDB$USER_SCHEMA_NAME),
					user_string);

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH GRANT OPTION");
				else
					with_option[0] = '\0';

				isqlGlob.printf("GRANT USAGE ON SCHEMA %s TO %s%s%s%s%s",
						 IUTILS_name_to_string(name.value()).c_str(),
						 user_string.c_str(), with_option,
						 granted_by(PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL).c_str(),
						 terminator, NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR

			if (!first)
				return (SKIP);
		}
	}

	if (isDdlObject(obj_type) || obj_type == obj_any)
		return SHOW_ddl_grants(name, terminator, obj_type, optional_msg);

	return OBJECT_NOT_FOUND;
}


void SHOW_grant_roles(const SCHAR* terminator, bool* first, const TEXT* optional_msg)
{
/**************************************
 *
 *	S H O W _ g r a n t _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Show grants for each role name
 *	This function is also called by extract for privileges.
 *	All membership privilege may have the with_admin or/and default options set.
 *
 **************************************/
	BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR dummy;	// used to declare buf_grantor
	FB_UNUSED_VAR(dummy); // Silence compiler warning about unused variable
	SCHAR buf_grantor[sizeof(dummy) + 20];

	// process role "object"

	FOR PRV IN RDB$USER_PRIVILEGES WITH
		PRV.RDB$GRANTOR NOT MISSING           AND
		PRV.RDB$OBJECT_TYPE   EQ obj_sql_role AND
		(PRV.RDB$USER_TYPE    EQ obj_user      OR
		 PRV.RDB$USER_TYPE     EQ obj_sql_role) AND
		PRV.RDB$PRIVILEGE     EQ 'M'
		SORTED BY PRV.RDB$RELATION_NAME, PRV.RDB$USER
	{
		if (first)
		{
			if (*first && optional_msg) {
				isqlGlob.prints(optional_msg);
			}
			*first = false;
		}

		const char* with_option = "";
		if (PRV.RDB$GRANT_OPTION)
			with_option = " WITH ADMIN OPTION";
		const char* default_option = "";
		if (!PRV.RDB$FIELD_NAME.NULL && PRV.RDB$FIELD_NAME[0] == 'D')
			default_option = " DEFAULT";

		const MetaString grantor(PRV.RDB$GRANTOR);

		isqlGlob.printf(
			"GRANT%s %s TO %s%s%s%s%s",
			default_option,
			IUTILS_name_to_string(PRV.RDB$RELATION_NAME).c_str(),
			IUTILS_name_to_string(PRV.RDB$USER).c_str(),
			with_option,
			granted_by(grantor, false).c_str(),
			terminator,
			NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
	END_ERROR

}


void SHOW_print_metadata_text_blob(FILE* fp, ISC_QUAD* blobid, bool escape_squote, bool avoid_end_in_single_line_comment)
{
/**************************************
 *
 *	S H O W _ p r i n t _ m e t a d a t a _ t e x t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Print a Blob that is known to be metadata text.
 *	The last param says whether single quotes should be escaped (duplicating them).
 *
 **************************************/

	// Don't bother with null blobs
	if (UserBlob::blobIsNull(*blobid))
		return;

	Firebird::IBlob* blob = DB->openBlob(fbStatus, fbTrans, blobid,
		sizeof(metadata_text_bpb), metadata_text_bpb);
	if (ISQL_errmsg(fbStatus))
		return;

	string fullText;
	SCHAR buffer[BUFFER_LENGTH512];
	bool endedWithCr = false;

	while (true)
	{
		unsigned int length;
		int cc = blob->getSegment(fbStatus, sizeof(buffer) - 1, buffer, &length);
		if (cc == Firebird::IStatus::RESULT_NO_DATA || cc == Firebird::IStatus::RESULT_ERROR)
			break;

		// ASF: In Windows, \n characters are printed as \r\n in text mode.
		// If the original string has \r\n, they're printed as \r\r\n, resulting
		// in mixed/wrong line endings. So here, we filter any \r present just
		// before \n.
		bool prevEndedWithCr = endedWithCr;

		if ((endedWithCr = length != 0 && buffer[length - 1] == '\r'))
			--length;

		buffer[length] = 0;

		for (SCHAR* p = buffer; p < buffer + length - 1; ++p)
		{
			if (p[0] == '\r' && p[1] == '\n')
			{
				memmove(p, p + 1, length - (p - buffer));
				--length;
			}
		}

		if (prevEndedWithCr && buffer[0] != '\n')
		{
			fputc('\r', fp);
			if (avoid_end_in_single_line_comment)
				fullText += "\r";
		}

		if (escape_squote)
		{
			for (const UCHAR* p = (UCHAR*) buffer; *p; ++p)
			{
				if (*p == SINGLE_QUOTE)
				{
					fputc(*p, fp);
					if (avoid_end_in_single_line_comment)
						fullText += *p;
				}

				fputc(*p, fp);
				if (avoid_end_in_single_line_comment)
					fullText += *p;
			}
			fflush(fp);
		}
		else
		{
			IUTILS_printf(fp, buffer);
			if (avoid_end_in_single_line_comment)
				fullText += buffer;
		}
	}

	if (endedWithCr)
	{
		fputc('\r', fp);
		if (avoid_end_in_single_line_comment)
			fullText += "\r";
	}

	if (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS)
		ISQL_errmsg(fbStatus);

	blob->close(fbStatus);

	if (avoid_end_in_single_line_comment && ISQL_statement_ends_in_comment(fullText.c_str()))
		fputc('\n', fp);
}


processing_state SHOW_metadata(const FrontendParser::AnyShowNode& node)
{
/**************************************
 *
 *	S H O W _ m e t a d a t a
 *
 **************************************
 *
 * Functional description
 *	If somebody presses the show ..., come here to
 *	interpret the desired command.
 *
 **************************************/

	static const OptionsBase::optionsMap options[] =
	{
		{0, "ROLES", 4},				// ROLE
		{0, "TABLES", 5},				// TABLE
		{0, "VIEWS", 4},				// VIEW
		{0, "SYSTEM", 3},				// SYS
		{0, "INDEXES", 3},				// IND
		{0, "INDICES", 0},
		{0, "DOMAINS", 6},				// DOMAIN
		{0, "EXCEPTIONS", 5},			// EXCEPTION
		{0, "FILTERS", 6},				// FILTER
		{0, "FUNCTIONS", 4},			// FUNCTION
		{0, "GENERATORS", 3},			// GEN
		{0, "SEQUENCES", 3},			// SEQ
		{0, "GRANTS", 5},				// GRANT
		{0, "PROCEDURES", 4},			// PROC
		{0, "TRIGGERS", 4},				// TRIG
		{0, "CHECKS", 5},				// CHECK
		{0, "DB", 0},
		{0, "DATABASE", 0},
		{0, "COMMENTS", 7},				// COMMENT
		{0, "DEPENDENCY", 5},			// DEPEN
		{0, "DEPENDENCIES", 5},			// DEPEN
		{0, "COLLATES", 7},				// COLLATE
		{0, "COLLATIONS", 9},			// COLLATION
		{0, "SECCLASSES", 6},			// SECCLA
		{0, "USERS", 0},
		{0, "PACKAGES", 4},				// PACK
		{0, "SCHEMAS", 4},				// SCHE
		{0, "MAPPINGS", 3},				// MAP
		{0, "PUBLICATIONS", 3},			// PUB
		{0, "WIRE_STATISTICS", 9},		// WIRE_STAT
		{0, "WIRE_STATS", 10}
	};

	const OptionsBase showoptions(options, FB_NELEM(options), 0);

	if (!std::holds_alternative<FrontendParser::ShowSqlDialectNode>(node) &&
		!std::holds_alternative<FrontendParser::ShowVersionNode>(node))
	{
		if (!ISQL_dbcheck())
			return ps_ERR;
	}

	int key = 0;
	QualifiedMetaString notFoundName;

	const auto ret = std::visit(StdVisitOverloads{
		[](const FrontendParser::InvalidNode&)
		{
			return CONT;
		},

		[&](const FrontendParser::ShowNode& node)
		{
			TEXT msg_string[MSG_LENGTH];
			IUTILS_msg_get(VALID_OPTIONS, msg_string);
			isqlGlob.printf("%s\n", msg_string);
			showoptions.showCommands(isqlGlob.Out);
			return ps_ERR;
		},

		[&](const FrontendParser::ShowChecksNode& node)
		{
			const auto ret = show_check(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->object.c_str()
					{
						if (node.name->schema.hasData() && node.name->schema != R.RDB$SCHEMA_NAME)
							continue;

						key = NO_CHECKS_ON_REL;
						break;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					notFoundName = node.name.value();
				}

				if (!key)
					key = NO_TABLE;
			}

			return ret;
		},

		[&](const FrontendParser::ShowCollationsNode& node)
		{
			const auto ret = show_collations(node.name, 0);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_COLLATION;
					notFoundName = node.name.value();
				}
				else
					key = NO_COLLATIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowCommentsNode&)
		{
			const auto ret = show_comments(cmmShow, nullptr);

			if (ret == OBJECT_NOT_FOUND)
				key = NO_COMMENTS;

			return ret;
		},

		[](const FrontendParser::ShowDatabaseNode&)
		{
			show_db();
			return SKIP;
		},

		[&](const FrontendParser::ShowDependenciesNode& node)
		{
			const auto ret = show_dependencies(node.name);

			if (ret == OBJECT_NOT_FOUND)
				key = NO_DEPENDENCIES;

			return ret;
		},

		[&](const FrontendParser::ShowDomainsNode& node)
		{
			const auto ret = show_domains(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_DOMAIN;
					notFoundName = node.name.value();
				}
				else
					key = NO_DOMAINS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowExceptionsNode& node)
		{
			const auto ret = show_exceptions(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_EXCEPTION;
					notFoundName = node.name.value();
				}
				else
					key = NO_EXCEPTIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowFiltersNode& node)
		{
			const auto ret = show_filters(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_FILTER;
					notFoundName.object = node.name.value();
				}
				else
					key = NO_FILTERS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowFunctionsNode& node)
		{
			const auto ret = show_functions(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_FUNCTION;
					notFoundName = node.name.value();
				}
				else
					key = NO_FUNCTIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowGeneratorsNode& node)
		{
			const auto ret = show_generators(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_GEN;
					notFoundName = node.name.value();
				}
				else
					key = NO_GENS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowGrantsNode& node)
		{
			processing_state ret;

			if (node.name)
				ret = SHOW_grants(node.name, "", obj_any, nullptr);
			else
				ret = EXTRACT_list_grants("");

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->object.c_str()
					{
						if (node.name->schema.hasData() && node.name->schema != R.RDB$SCHEMA_NAME)
							continue;

						key = NO_GRANT_ON_REL;
						break;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					if (!key)
					{
						FOR P IN RDB$PROCEDURES
							WITH P.RDB$PROCEDURE_NAME EQ node.name->object.c_str() AND
								 P.RDB$PACKAGE_NAME MISSING
						{
							if (node.name->schema.hasData() && node.name->schema != P.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_PROC;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key && node.name->schema.isEmpty())
					{
						FOR FIRST 1 R IN RDB$ROLES
							WITH R.RDB$ROLE_NAME EQ node.name->object.c_str()
						{
							key = NO_GRANT_ON_ROL;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR F IN RDB$FUNCTIONS
							WITH F.RDB$FUNCTION_NAME EQ node.name->object.c_str() AND
								 F.RDB$PACKAGE_NAME MISSING
						{
							if (node.name->schema.hasData() && node.name->schema != F.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_FUN;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR G IN RDB$GENERATORS
							WITH G.RDB$GENERATOR_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != G.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_GEN;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR E IN RDB$EXCEPTIONS
							WITH E.RDB$EXCEPTION_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != E.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_XCP;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR F IN RDB$FIELDS
							WITH F.RDB$FIELD_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != F.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_FLD;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR CS IN RDB$CHARACTER_SETS
							WITH CS.RDB$CHARACTER_SET_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != CS.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_CS;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR C IN RDB$COLLATIONS
							WITH C.RDB$COLLATION_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != C.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_COLL;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key && isqlGlob.major_ods >= ODS_VERSION12)
					{
						FOR P IN RDB$PACKAGES
							WITH P.RDB$PACKAGE_NAME EQ node.name->object.c_str()
						{
							if (node.name->schema.hasData() && node.name->schema != P.RDB$SCHEMA_NAME)
								continue;

							key = NO_GRANT_ON_PKG;
							break;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
						key = NO_OBJECT;

					notFoundName = node.name.value();
				}
				else
					key = NO_GRANT_ON_ANY;
			}

			return ret;
		},

		[&](const FrontendParser::ShowIndexesNode& node)
		{
			const auto ret = show_indices(node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->object.c_str()
					{
						if (node.name->schema.hasData() && node.name->schema != R.RDB$SCHEMA_NAME)
							continue;

						key = NO_INDICES_ON_REL;
						break;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					notFoundName = node.name.value();

					if (!key)
						key = NO_REL_OR_INDEX;
				}
				else
					key = NO_INDICES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowMappingsNode& node)
		{
			const auto ret = SHOW_maps(false, node.name);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_MAP;
					notFoundName.object = node.name.value();
				}
				else
					key = NO_MAPS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowPackagesNode& node)
		{
			const auto ret = show_packages(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PACKAGE;
					notFoundName = node.name.value();
				}
				else
					key = NO_PACKAGES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowProceduresNode& node)
		{
			const auto ret = show_proc(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PROC;
					notFoundName = node.name.value();
				}
				else
					key = NO_PROCS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowPublicationsNode& node)
		{
			const auto ret = show_publications(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PUBLICATION;
					notFoundName.object = node.name.value();
				}
				else
					key = NO_PUBLICATIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowRolesNode& node)
		{
			const auto ret = show_role(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_ROLE;
					notFoundName.object = node.name.value();
				}
				else
					key = NO_ROLES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowSchemasNode& node)
		{
			const auto ret = show_schemas(node.name, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_SCHEMA;
					notFoundName.object = node.name.value();
				}
				else
					key = NO_SCHEMAS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowSecClassesNode& node)
		{
			const auto ret = show_secclass(node.name, node.detail);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_SECCLASS;
					notFoundName = node.name.value();
				}
				else
					key = NO_DB_WIDE_SECCLASS;
			}

			return ret;
		},

		[](const FrontendParser::ShowSqlDialectNode& node)
		{
			return show_dialect();
		},

		[](const FrontendParser::ShowSystemNode& node)
		{
			if (node.objType)
			{
				switch (node.objType.value())
				{
				case obj_schema:
					show_schemas(std::nullopt, true);
					break;

				case obj_collation:
					show_collations(std::nullopt, 1);
					break;

				case obj_udf:
					show_functions(std::nullopt, true);
					break;

				case obj_relation:
					show_all_tables(1);
					break;

				case obj_sql_role:
					show_role(std::nullopt, true);
					break;

				case obj_procedure:
					show_proc(std::nullopt, true);
					break;

				case obj_package_header:
					show_packages(std::nullopt, true);
					break;

				case obj_publication:
					show_publications(std::nullopt, true);
					break;

				default:
					return ps_ERR;
				}
			}
			else
			{
				TEXT msg[MSG_LENGTH];
				IUTILS_msg_get(MSG_SCHEMAS, msg);
				show_schemas(std::nullopt, true, msg);
				IUTILS_msg_get(MSG_TABLES, msg);
				isqlGlob.printf("%s%s", msg, NEWLINE);
				show_all_tables(1);
				IUTILS_msg_get(MSG_FUNCTIONS, msg);
				show_functions(std::nullopt, true, msg);
				IUTILS_msg_get(MSG_PROCEDURES, msg);
				show_proc(std::nullopt, true, msg);
				IUTILS_msg_get(MSG_PACKAGES, msg);
				show_packages(std::nullopt, true, msg);
				IUTILS_msg_get(MSG_COLLATIONS, msg);
				show_collations(std::nullopt, 1, msg, true);
				IUTILS_msg_get(MSG_ROLES, msg);
				show_role(std::nullopt, true, msg);
				IUTILS_msg_get(MSG_PUBLICATIONS, msg);
				show_publications(std::nullopt, true, msg);
			}

			return SKIP;
		},

		[&](const FrontendParser::ShowTablesNode& node)
		{
			processing_state ret;

			if (node.name)
			{
				ret = show_table(node.name.value(), false);

				if (ret == OBJECT_NOT_FOUND)
				{
					key = NO_TABLE;
					notFoundName = node.name.value();
				}
			}
			else
			{
				ret = show_all_tables(0);
				if (ret == OBJECT_NOT_FOUND)
					key = NO_TABLES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowTriggersNode& node)
		{
			const auto ret = show_trigger(node.name, true, true);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_TRIGGER;
					notFoundName = node.name.value();
				}
				else
					key = NO_TRIGGERS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowUsersNode& node)
		{
			const auto ret = show_users();

			if (ret == OBJECT_NOT_FOUND) // It seems impossible, but...
				key = NO_CONNECTED_USERS;

			return ret;
		},

		[](const FrontendParser::ShowVersionNode&)
		{
			TEXT msg_string[MSG_LENGTH];
			IUTILS_msg_get(VERSION, msg_string, SafeArg() << FB_VERSION);
			isqlGlob.printf("%s%s", msg_string, NEWLINE);
			isqlGlob.printf("Server version:%s", NEWLINE);
			VersionCallback callback;
			UtilInterfacePtr()->getFbVersion(fbStatus, DB, &callback);
			if (fbStatus->getState() & IStatus::STATE_ERRORS)
			{
				IUTILS_msg_get(CANNOT_GET_SRV_VER, msg_string);
				STDERROUT(msg_string);
			}

			return SKIP;
		},

		[&](const FrontendParser::ShowViewsNode& node)
		{
			processing_state ret;

			if (node.name)
			{
				ret = show_table(node.name.value(), true);

				if (ret == OBJECT_NOT_FOUND)
				{
					key = NO_VIEW;
					notFoundName = node.name.value();
				}
			}
			else
			{
				ret = show_all_tables(-1);
				if (ret == OBJECT_NOT_FOUND)
					key = NO_VIEWS;
			}

			return ret;
		},

		[](const FrontendParser::ShowWireStatsNode&)
		{
			return show_wireStats();
		},

		[](auto& arg)
		{
			static_assert(FrontendParser::AlwaysFalseV<decltype(arg)>,
				"Add visitor method for that show node type");
		}
	}, node);

	if (ret == OBJECT_NOT_FOUND)
	{
		TEXT key_string[MSG_LENGTH];
		IUTILS_msg_get(key, key_string, SafeArg() << IUTILS_name_to_string(notFoundName).c_str());
		STDERROUT(key_string);
	}

	return ret;
}


static void make_priv_string(USHORT flags, char* string, bool useAny)
{
/**************************************
 *
 *	m a k e _ p r i v _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Given a bit-vector of privileges, turn it into a
 *	string list.
 *
 **************************************/
	if (flags == RELATION_PRIV_ALL)
	{
		strcat(string, "ALL");
		return;
	}

	for (int i = 0; privs[i].priv_string; i++)
	{
		if (flags & privs[i].priv_flag)
		{
			if (*string)
				strcat(string, ", ");

			strcat(string, privs[i].priv_string);

			if (useAny && (privs[i].priv_flag == priv_ALTER || privs[i].priv_flag == priv_DROP))
				strcat(string, " ANY");
		}
	}
}


static processing_state show_all_tables(SSHORT sys_flag)
{
/**************************************
 *
 *	s h o w _ a l l _ t a b l e s
 *
 **************************************
 *
 *	Print the names of all user tables from
 *	rdb$relations.  We use a dynamic query
 *
 *	Parameters:  sys_flag -- 0, show user tables
 *	1, show system tables only; -1, show views only
 *
 **************************************/
	bool first = true;

	if (sys_flag == -1)
	{
		// Views
		FOR REL IN RDB$RELATIONS WITH
			REL.RDB$VIEW_BLR NOT MISSING
			SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_NAME
		{
			first = false;

			const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

			isqlGlob.printf("%s%s", IUTILS_name_to_string(relationName).c_str(), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	else // 23-Apr-2004 (only tables)
	{
		// The rdb$system_flag is not always set for non-system objects... this
		// query may potentially fail.
		FOR REL IN RDB$RELATIONS WITH
			(REL.RDB$SYSTEM_FLAG EQ sys_flag
				/*OR (sys_flag == 0 AND REL.RDB$SYSTEM_FLAG MISSING)*/)
			AND REL.RDB$VIEW_BLR MISSING
			SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_NAME
		{
			first = false;

			const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

			isqlGlob.printf("%s%s", IUTILS_name_to_string(relationName).c_str(), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (!first)
	{
		isqlGlob.printf(NEWLINE);
		return SKIP;
	}

	return OBJECT_NOT_FOUND;
}


static void show_charsets(SSHORT char_set_id, SSHORT collation)
{
/*************************************
*
*	s h o w _ c h a r s e t s
*
**************************************
*
* Functional description
*	Show names of character set and collations
*
**************************************/
#ifdef	DEV_BUILD
	bool found = false;
#endif

	FOR COL IN RDB$COLLATIONS CROSS
		CST IN RDB$CHARACTER_SETS WITH
		COL.RDB$CHARACTER_SET_ID EQ CST.RDB$CHARACTER_SET_ID AND
		COL.RDB$COLLATION_ID EQ collation AND
		CST.RDB$CHARACTER_SET_ID EQ char_set_id
	{
#ifdef DEV_BUILD
		found = true;
#endif

		const QualifiedMetaString charSetName(CST.RDB$CHARACTER_SET_NAME, CST.RDB$SCHEMA_NAME);
		const QualifiedMetaString collationName(COL.RDB$COLLATION_NAME, COL.RDB$SCHEMA_NAME);
		const QualifiedMetaString charSetDefaultCollationName(
			CST.RDB$DEFAULT_COLLATE_NAME, CST.RDB$DEFAULT_COLLATE_SCHEMA_NAME);

		if (charSetDefaultCollationName == collationName && charSetName == collationName)
		{
			// Collation is default and match charset name - do not show it.
			isqlGlob.printf(
				" CHARACTER SET %s",
				IUTILS_name_to_string(charSetName).c_str());
		}
		else
		{
			isqlGlob.printf(
				" CHARACTER SET %s COLLATE %s",
				IUTILS_name_to_string(charSetName).c_str(),
				IUTILS_name_to_string(collationName).c_str());
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

#ifdef DEV_BUILD
	if (!found)
	{
		TEXT Print_buffer[PRINT_BUFFER_LENGTH];
		sprintf(Print_buffer,
				"ISQL_get_character_set: charset %d collation %d not found.\n",
				char_set_id, collation);
		STDERROUT(Print_buffer);
	}
#endif
}


static processing_state show_check(const std::optional<QualifiedMetaString>& name)
{
/**************************************
 *
 *	s h o w _ c h e c k
 *
 **************************************
 *
 * Functional description
 *	Show check constraints for the named object
 *
 **************************************/
	bool first = true;

	if (!name)
		return ps_ERR;
	// Query gets the check clauses for triggers stored for check constraints

	FOR TRG IN RDB$TRIGGERS CROSS
		CHK IN RDB$CHECK_CONSTRAINTS WITH
		TRG.RDB$TRIGGER_TYPE EQ 1 AND
		TRG.RDB$SCHEMA_NAME EQUIV CHK.RDB$SCHEMA_NAME AND
		TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME AND
		//CHK.RDB$TRIGGER_NAME STARTING WITH "CHECK" AND
		TRG.RDB$SYSTEM_FLAG EQ int(fb_sysflag_check_constraint) AND
		TRG.RDB$RELATION_NAME EQ name->object.c_str()
		SORTED BY CHK.RDB$SCHEMA_NAME, CHK.RDB$CONSTRAINT_NAME
	{
		const QualifiedMetaString constraintName(CHK.RDB$CONSTRAINT_NAME, CHK.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != constraintName.schema)
			continue;

		// Use print_blob to print the blob
		first = false;

		isqlGlob.printf("CONSTRAINT %s:%s  ", IUTILS_name_to_string(constraintName.object).c_str(), NEWLINE);

		if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);
		isqlGlob.printf(NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_collations(const std::optional<QualifiedMetaString>& name,
	SSHORT sys_flag, const char* msg, bool compact)
{
/**************************************
 *
 *	s h o w _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show collations.
 *
 **************************************/
	bool found = false;

	// Show all collations or named collation
	FOR CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS
		WITH CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID
		SORTED BY CL.RDB$SCHEMA_NAME, CL.RDB$COLLATION_NAME
	{
		const QualifiedMetaString collationName(CL.RDB$COLLATION_NAME, CL.RDB$SCHEMA_NAME);

		if ((!name &&
			 ((!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0 && sys_flag != 0) ||
			  (!(!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0) && sys_flag != 1))) ||
			collationName == name ||
			(name->schema.isEmpty() && name->object == collationName.object))
		{
			if (!found)
			{
				found = true;

				if (msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
			}

			if (compact)
				isqlGlob.printf("%s%s", IUTILS_name_to_string(collationName).c_str(), NEWLINE);
			else
			{
				isqlGlob.printf("%s", IUTILS_name_to_string(collationName).c_str());

				const QualifiedMetaString charSetName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);
				isqlGlob.printf(", CHARACTER SET %s", IUTILS_name_to_string(charSetName).c_str());

				if (!CL.RDB$BASE_COLLATION_NAME.NULL)
				{
					fb_utils::exact_name(CL.RDB$BASE_COLLATION_NAME);
					isqlGlob.printf(", FROM EXTERNAL ('%s')", CL.RDB$BASE_COLLATION_NAME);
				}

				if (!CL.RDB$COLLATION_ATTRIBUTES.NULL)
				{
					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_PAD_SPACE)
						isqlGlob.printf(", PAD SPACE");

					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_CASE_INSENSITIVE)
						isqlGlob.printf(", CASE INSENSITIVE");

					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_ACCENT_INSENSITIVE)
						isqlGlob.printf(", ACCENT INSENSITIVE");
				}

				if (!CL.RDB$SPECIFIC_ATTRIBUTES.NULL)
				{
					isqlGlob.printf(", '");
					SHOW_print_metadata_text_blob (isqlGlob.Out, &CL.RDB$SPECIFIC_ATTRIBUTES);
					isqlGlob.printf("'");
				}

				if (!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0)
					isqlGlob.printf(", SYSTEM");

				isqlGlob.printf("%s", NEWLINE);
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (!found)
		return (OBJECT_NOT_FOUND);

	isqlGlob.printf(NEWLINE);

	return SKIP;
}


// ***********************
// s h o w _ c o m m e n t
// ***********************
// Helper that displays in correct syntax the COMMENT ON command for each object.
// It escapes identifiers with embedded double quotes and escapes the comment
// itself if it contains single quotes when we are honoring script extraction.
static void show_comment(const char* objtype, const QualifiedMetaString& name, const MetaString& name2,
	ISC_QUAD* blobfld, const commentMode showextract, const char* banner)
{
	const bool escape_quotes = showextract == cmmExtract;

	if (escape_quotes && banner)
		isqlGlob.prints(banner);

	const char* quot = escape_quotes ? "'" : "";

	isqlGlob.printf("COMMENT ON %-12s", objtype);

	if (name.object.hasData() || name2.hasData())
		isqlGlob.printf(" ");

	if (name.object.hasData())
		isqlGlob.printf("%s", IUTILS_name_to_string(name).c_str());

	if (name2.hasData())
		isqlGlob.printf(".%s", IUTILS_name_to_string(name2).c_str());

	isqlGlob.printf(" IS %s", quot);

	SHOW_print_metadata_text_blob(isqlGlob.Out, blobfld, escape_quotes);
	isqlGlob.printf("%s%s%s", quot, isqlGlob.global_Term, NEWLINE);
}


// *************************
// s h o w _ c o m m e n t s
// *************************
// Will extract and show descriptions (comments) for all supported db objects.
// This function does its task even if the server version doesn't support
// the COMMENT ON command. It will however skip generators and roles that
// didn't have description fields before ODS11.
// It will extract the main objects by category and inside each category,
// in alphabetical order. For tables and views, their fields are printed
// immediately after the table/field in rdb$field_position order, that's
// the order the users sees when doing a select * from tbl/view. For procedures,
// their parameters are printed immediately after the procedure, first the input
// params by position, the  the output params by position. All system objects
// as well as implicit domains and implicit triggers are skipped. For ODS < 11,
// we skip generators and roles because those system tables didn't have a
// rdb$description field.
// When showing comments, we don't escape quotes in neither names nor strings.
// When extracting comments, we do the usual escaping to make the script valid.
static processing_state show_comments(const commentMode showextract, const char* banner)
{
	// From dsql.h:
	//	ddl_database, ddl_domain, ddl_relation, ddl_view, ddl_procedure, ddl_trigger,
	//	ddl_udf, ddl_blob_filter, ddl_exception, ddl_generator, ddl_index, ddl_role,
	//	ddl_charset, ddl_collation//, ddl_sec_class

	bool first = true;

	FOR FIRST 1 DT IN RDB$DATABASE
		WITH DT.RDB$DESCRIPTION NOT MISSING
	{
		show_comment("DATABASE", {}, {}, &DT.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR DM IN RDB$FIELDS
		WITH DM.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
			 (DM.RDB$SYSTEM_FLAG EQ 0 OR DM.RDB$SYSTEM_FLAG MISSING) AND
			 DM.RDB$DESCRIPTION NOT MISSING
		SORTED BY DM.RDB$SCHEMA_NAME, DM.RDB$FIELD_NAME
	{
		const QualifiedMetaString name(DM.RDB$FIELD_NAME, DM.RDB$SCHEMA_NAME);

		show_comment("DOMAIN", name, {}, &DM.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR RL IN RDB$RELATIONS
		WITH RL.RDB$VIEW_BLR MISSING AND
			 (RL.RDB$SYSTEM_FLAG EQ 0 OR RL.RDB$SYSTEM_FLAG MISSING)
		SORTED BY RL.RDB$SCHEMA_NAME, RL.RDB$RELATION_NAME
	{
		const QualifiedMetaString name(RL.RDB$RELATION_NAME, RL.RDB$SCHEMA_NAME);

		if (!RL.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(RL.RDB$DESCRIPTION))
		{
			show_comment("TABLE", name, {}, &RL.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}

		FOR RF IN RDB$RELATION_FIELDS
			WITH RF.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 RF.RDB$RELATION_NAME = RL.RDB$RELATION_NAME AND
				 RF.RDB$DESCRIPTION NOT MISSING
			SORTED BY RF.RDB$FIELD_POSITION
		{
			show_comment("   COLUMN", name, RF.RDB$FIELD_NAME,
				&RF.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR VW IN RDB$RELATIONS
		WITH VW.RDB$VIEW_BLR NOT MISSING AND
			 (VW.RDB$SYSTEM_FLAG EQ 0 OR VW.RDB$SYSTEM_FLAG MISSING)
		SORTED BY VW.RDB$SCHEMA_NAME, VW.RDB$RELATION_NAME
	{
		const QualifiedMetaString name(VW.RDB$RELATION_NAME, VW.RDB$SCHEMA_NAME);

		if (!VW.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(VW.RDB$DESCRIPTION))
		{
			show_comment("VIEW", name, {}, &VW.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}

		FOR RF IN RDB$RELATION_FIELDS
			WITH RF.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 RF.RDB$RELATION_NAME = name.object.c_str() AND
				 RF.RDB$DESCRIPTION NOT MISSING
			SORTED BY RF.RDB$FIELD_POSITION
		{
			show_comment("   COLUMN", name, RF.RDB$FIELD_NAME,
				&RF.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR PR IN RDB$PROCEDURES
		WITH (PR.RDB$SYSTEM_FLAG EQ 0 OR PR.RDB$SYSTEM_FLAG MISSING)
		SORTED BY PR.RDB$SCHEMA_NAME, PR.RDB$PROCEDURE_NAME
	{
		const QualifiedMetaString name(PR.RDB$PROCEDURE_NAME, PR.RDB$SCHEMA_NAME, PR.RDB$PACKAGE_NAME);

		if (!PR.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(PR.RDB$DESCRIPTION))
		{
			show_comment("PROCEDURE", name, {}, &PR.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}

		FOR PA IN RDB$PROCEDURE_PARAMETERS
			WITH PA.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 PA.RDB$PROCEDURE_NAME = name.object.c_str() AND
				 PA.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '') AND
				 PA.RDB$DESCRIPTION NOT MISSING
			SORTED BY PA.RDB$PARAMETER_TYPE, PA.RDB$PARAMETER_NUMBER
		{
			show_comment("   PROCEDURE PARAMETER", name,
				PA.RDB$PARAMETER_NAME, &PA.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR TR IN RDB$TRIGGERS
		WITH TR.RDB$DESCRIPTION NOT MISSING AND
			 (TR.RDB$SYSTEM_FLAG EQ 0 OR TR.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TR.RDB$SCHEMA_NAME, TR.RDB$TRIGGER_NAME
	{
		const QualifiedMetaString name(TR.RDB$TRIGGER_NAME, TR.RDB$SCHEMA_NAME);

		show_comment("TRIGGER", name, {}, &TR.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR UD IN RDB$FUNCTIONS
		WITH UD.RDB$DESCRIPTION NOT MISSING AND
			 (UD.RDB$SYSTEM_FLAG EQ 0 OR UD.RDB$SYSTEM_FLAG MISSING)
		SORTED BY UD.RDB$SCHEMA_NAME, UD.RDB$FUNCTION_NAME
	{
		// Avoid syntax error when extracting scripts due to an historical bug in gbak.
		// See CORE-1174.
		if (UserBlob::blobIsNull(UD.RDB$DESCRIPTION))
			continue;

		const QualifiedMetaString name(UD.RDB$FUNCTION_NAME, UD.RDB$SCHEMA_NAME, UD.RDB$PACKAGE_NAME);

		show_comment("FUNCTION", name, {},
			&UD.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;

		FOR ARG IN RDB$FUNCTION_ARGUMENTS
			WITH ARG.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 ARG.RDB$FUNCTION_NAME = name.object.c_str() AND
				 ARG.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '') AND
				 ARG.RDB$DESCRIPTION NOT MISSING
			SORTED BY ARG.RDB$ARGUMENT_POSITION
		{
			show_comment("   FUNCTION PARAMETER", name,
				ARG.RDB$ARGUMENT_NAME, &ARG.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR BF IN RDB$FILTERS
		WITH BF.RDB$DESCRIPTION NOT MISSING AND
			 (BF.RDB$SYSTEM_FLAG EQ 0 OR BF.RDB$SYSTEM_FLAG MISSING)
		SORTED BY BF.RDB$FUNCTION_NAME
	{
		const QualifiedMetaString name(BF.RDB$FUNCTION_NAME);

		show_comment("FILTER", name, {}, &BF.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR XC IN RDB$EXCEPTIONS
		WITH XC.RDB$DESCRIPTION NOT MISSING AND
			 (XC.RDB$SYSTEM_FLAG EQ 0 OR XC.RDB$SYSTEM_FLAG MISSING)
		SORTED BY XC.RDB$SCHEMA_NAME, XC.RDB$EXCEPTION_NAME
	{
		const QualifiedMetaString name(XC.RDB$EXCEPTION_NAME, XC.RDB$SCHEMA_NAME);

		show_comment("EXCEPTION", name, {}, &XC.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION11)
	{
		FOR GR IN RDB$GENERATORS
			WITH GR.RDB$DESCRIPTION NOT MISSING AND
				 (GR.RDB$SYSTEM_FLAG EQ 0 OR GR.RDB$SYSTEM_FLAG MISSING)
			SORTED BY GR.RDB$SCHEMA_NAME, GR.RDB$GENERATOR_NAME
		{
			const QualifiedMetaString name(GR.RDB$GENERATOR_NAME, GR.RDB$SCHEMA_NAME);

			show_comment("GENERATOR", name, {}, &GR.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	FOR IX IN RDB$INDICES
		WITH IX.RDB$DESCRIPTION NOT MISSING AND
			 (IX.RDB$SYSTEM_FLAG EQ 0 OR IX.RDB$SYSTEM_FLAG MISSING)
		SORTED BY IX.RDB$SCHEMA_NAME, IX.RDB$INDEX_NAME
	{
		const QualifiedMetaString name(IX.RDB$INDEX_NAME, IX.RDB$SCHEMA_NAME);

		show_comment("INDEX", name, {}, &IX.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION11)
	{
		FOR RO IN RDB$ROLES
			WITH RO.RDB$DESCRIPTION NOT MISSING AND
				 (RO.RDB$SYSTEM_FLAG EQ 0 OR RO.RDB$SYSTEM_FLAG MISSING)
			SORTED BY RO.RDB$ROLE_NAME
		{
			const QualifiedMetaString name(RO.RDB$ROLE_NAME);

			show_comment("ROLE", name, {}, &RO.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR PACK IN RDB$PACKAGES
			WITH PACK.RDB$DESCRIPTION NOT MISSING AND
				 (PACK.RDB$SYSTEM_FLAG EQ 0 OR PACK.RDB$SYSTEM_FLAG MISSING)
			SORTED BY PACK.RDB$SCHEMA_NAME, PACK.RDB$PACKAGE_NAME
		{
			const QualifiedMetaString name(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);

			show_comment("PACKAGE", name, {}, &PACK.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	FOR CH IN RDB$CHARACTER_SETS
		WITH CH.RDB$DESCRIPTION NOT MISSING AND
			 (CH.RDB$SYSTEM_FLAG EQ 0 OR CH.RDB$SYSTEM_FLAG MISSING)
		SORTED BY CH.RDB$SCHEMA_NAME, CH.RDB$CHARACTER_SET_NAME
	{
		const QualifiedMetaString name(CH.RDB$CHARACTER_SET_NAME, CH.RDB$SCHEMA_NAME);

		show_comment("CHARACTER SET", name, {},
			&CH.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR CL IN RDB$COLLATIONS
		WITH CL.RDB$DESCRIPTION NOT MISSING AND
			 (CL.RDB$SYSTEM_FLAG EQ 0 OR CL.RDB$SYSTEM_FLAG MISSING)
		SORTED BY CL.RDB$SCHEMA_NAME, CL.RDB$COLLATION_NAME
	{
		const QualifiedMetaString name(CL.RDB$COLLATION_NAME, CL.RDB$SCHEMA_NAME);

		show_comment("COLLATION", name, {}, &CL.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR M IN RDB$AUTH_MAPPING
			WITH M.RDB$DESCRIPTION NOT MISSING AND
				 (M.RDB$SYSTEM_FLAG EQ 0 OR M.RDB$SYSTEM_FLAG MISSING)
			SORTED BY M.RDB$MAP_NAME
		{
			const QualifiedMetaString name(M.RDB$MAP_NAME);

			show_comment("MAPPING", name, {}, &M.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR M IN SEC$GLOBAL_AUTH_MAPPING
			WITH M.SEC$DESCRIPTION NOT MISSING
			SORTED BY M.SEC$MAP_NAME
		{
			const QualifiedMetaString name(M.SEC$MAP_NAME);

			show_comment("GLOBAL MAPPING", name, {}, &M.SEC$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (isqlGlob.major_ods >= ODS_VERSION14)
	{
		FOR SCH IN RDB$SCHEMAS
			WITH SCH.RDB$DESCRIPTION NOT MISSING AND
				 (SCH.RDB$SYSTEM_FLAG EQ 0 OR SCH.RDB$SYSTEM_FLAG MISSING)
			SORTED BY SCH.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString name(SCH.RDB$SCHEMA_NAME);

			show_comment("SCHEMA", name, {}, &SCH.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	return first ? OBJECT_NOT_FOUND : SKIP;
}


static void show_db()
{
/**************************************
 *
 *	s h o w _ d b
 *
 **************************************
 *
 * Functional description
 *	Show info on this database.  cache, logfiles, etc
 *
 **************************************/

	// First print the name of the database

	isqlGlob.printf("Database: %s%s", isqlGlob.global_Db_name, NEWLINE);

	// Get the owner name
	FOR REL IN RDB$RELATIONS
		WITH (REL.RDB$SCHEMA_NAME = SYSTEM_SCHEMA OR REL.RDB$SCHEMA_NAME MISSING) AND
			 REL.RDB$RELATION_NAME = "RDB$DATABASE" AND
			 REL.RDB$OWNER_NAME NOT MISSING
	{
		isqlGlob.printf("%sOwner: %s%s", TAB_AS_SPACES, REL.RDB$OWNER_NAME, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// Query for files

	FOR FIL IN RDB$FILES
		SORTED BY FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_SEQUENCE
	{
		// reset nulls to zero

		if (FIL.RDB$FILE_FLAGS.NULL)
			FIL.RDB$FILE_FLAGS = 0;
		if (FIL.RDB$FILE_LENGTH.NULL)
			FIL.RDB$FILE_LENGTH = 0;
		if (FIL.RDB$FILE_SEQUENCE.NULL)
			FIL.RDB$FILE_SEQUENCE = 0;
		if (FIL.RDB$FILE_START.NULL)
			FIL.RDB$FILE_START = 0;
		if (!FIL.RDB$FILE_NAME.NULL)
			fb_utils::exact_name(FIL.RDB$FILE_NAME);

		if (FIL.RDB$FILE_FLAGS == 0)
		{
			isqlGlob.printf(" File %d: \"%s\", length %ld, start %ld%s",
					 FIL.RDB$FILE_SEQUENCE, FIL.RDB$FILE_NAME,
					 FIL.RDB$FILE_LENGTH, FIL.RDB$FILE_START, NEWLINE);
		}
		else if (FIL.RDB$FILE_FLAGS & FILE_shadow)
		{
			if (FIL.RDB$FILE_SEQUENCE) {
				isqlGlob.printf("%sfile %s ", TAB_AS_SPACES, FIL.RDB$FILE_NAME);
			}
			else
			{
				isqlGlob.printf(" Shadow %d: \"%s\" ", FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_NAME);
				if (FIL.RDB$FILE_FLAGS & FILE_inactive) {
					isqlGlob.printf("inactive ");
				}
				if (FIL.RDB$FILE_FLAGS & FILE_manual) {
					isqlGlob.printf("manual ");
				}
				else {
					isqlGlob.printf("auto ");
				}
				if (FIL.RDB$FILE_FLAGS & FILE_conditional) {
					isqlGlob.printf("conditional ");
				}
			}
			if (FIL.RDB$FILE_LENGTH) {
				isqlGlob.printf("length %ld ", FIL.RDB$FILE_LENGTH);
			}
			if (FIL.RDB$FILE_START) {
				isqlGlob.printf("starting %ld", FIL.RDB$FILE_START);
			}
			isqlGlob.printf(NEWLINE);
		}
		else if ((FIL.RDB$FILE_FLAGS & FILE_difference) && !FIL.RDB$FILE_NAME.NULL)
		{
			// This is an explicit name for the difference file typically named <db_name>.delta
			isqlGlob.printf("Explicit physical backup difference file: \"%s\"%s",
					FIL.RDB$FILE_NAME, NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// First general database parameters

	bool translate = true;

	SHOW_dbb_parameters(DB, db_items, sizeof(db_items), translate, NEWLINE);

	FOR DBB IN RDB$DATABASE
		CROSS CS IN RDB$CHARACTER_SETS
		WITH CS.RDB$SCHEMA_NAME EQUIV DBB.RDB$CHARACTER_SET_SCHEMA_NAME AND
			 CS.RDB$CHARACTER_SET_NAME EQ DBB.RDB$CHARACTER_SET_NAME
	{
		const QualifiedMetaString charSetName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);
		const QualifiedMetaString collationName(CS.RDB$DEFAULT_COLLATE_NAME, CS.RDB$DEFAULT_COLLATE_SCHEMA_NAME);

		isqlGlob.printf("Default Character set: %s", IUTILS_name_to_string(charSetName).c_str());

		if (!CS.RDB$DEFAULT_COLLATE_NAME.NULL && charSetName != collationName)
			isqlGlob.printf(" (with Default Collation %s)", IUTILS_name_to_string(collationName).c_str());

		isqlGlob.printf("%s", NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	int pass = 0;
	FOR DBB2 IN RDB$DATABASE
	{
		if (!DBB2.RDB$LINGER.NULL && DBB2.RDB$LINGER > 0)
			isqlGlob.printf("Linger: %d seconds%s", DBB2.RDB$LINGER, NEWLINE);

		if (!DBB2.RDB$SQL_SECURITY.NULL && DBB2.RDB$SQL_SECURITY == FB_TRUE)
			isqlGlob.printf("SQL SECURITY DEFINER%s", NEWLINE);

		if (++pass > 1)
			isqlGlob.printf("RDB$DATABASE has more than one record%s", NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION13)
	{
		bool published = false;

		FOR PUB IN RDB$PUBLICATIONS WITH
			PUB.RDB$ACTIVE_FLAG > 0
		{
			published = true;
			break;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR

		isqlGlob.printf("Publication: %s%s", published ? "Enabled" : "Disabled", NEWLINE);
	}
}


// *********************************
// s h o w _ d e p e n d e n c i e s   (front-end)
// *********************************
// Iterate through all types of objects types (as per jrd/obj.h) calling the
// overloaded routine. We try to fetch all possible object types that share
// the same name.
static processing_state show_dependencies(const std::optional<QualifiedMetaString>& name)
{
	if (!name)
		return ps_ERR;

	bool missing = true;

	for (FB_SIZE_T i = 0; i < FB_NELEM(Object_types); ++i)
	{
		if (show_dependencies(name.value(), i) == SKIP)
		{
			missing = false;
			isqlGlob.printf("+++%s", NEWLINE);
		}
	}

	return missing ? OBJECT_NOT_FOUND : SKIP;
}


// *********************************
// s h o w _ d e p e n d e n c i e s    (processor)
// *********************************
// Discover dependencies. Format:
// - objects that depend on this object
// - objects this object depends on
// - if it's table or view, list fields that depend on other objects
// - if it's procedure, list parameters that depend on other objects (unlikely for now)
static processing_state show_dependencies(const QualifiedMetaString& name, int obj_type)
{
	Array<QualifiedMetaString> dependsOn;

	FOR DEP1 IN RDB$DEPENDENCIES
		WITH DEP1.RDB$DEPENDED_ON_NAME EQ name.object.c_str() AND
			 DEP1.RDB$DEPENDED_ON_TYPE EQ obj_type
		SORTED BY DEP1.RDB$DEPENDED_ON_SCHEMA_NAME
	{
		const QualifiedMetaString dependedOnName(DEP1.RDB$DEPENDED_ON_NAME, DEP1.RDB$DEPENDED_ON_SCHEMA_NAME);

		if (name.schema.hasData() && name.schema != dependedOnName.schema)
			continue;

		const QualifiedMetaString dependentName(DEP1.RDB$DEPENDENT_NAME, DEP1.RDB$DEPENDENT_SCHEMA_NAME);

		if (dependsOn.hasData())
			isqlGlob.prints(", ");

		dependsOn.add(dependedOnName);

		const char* type_name = Object_types[DEP1.RDB$DEPENDENT_TYPE];
		if (DEP1.RDB$FIELD_NAME.NULL)
			isqlGlob.printf("%s:%s", IUTILS_name_to_string(dependentName).c_str(), type_name);
		else
		{
			isqlGlob.printf(
				"%s:%s->%s",
				IUTILS_name_to_string(dependentName).c_str(),
				type_name,
				IUTILS_name_to_string(DEP1.RDB$FIELD_NAME).c_str());
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	bool target_done = false;
	if (dependsOn.hasData())
	{
		for (const auto& dependsOnName : dependsOn)
		{
			const char* type_name = Object_types[obj_type];
			isqlGlob.printf("%s%s[%s:%s]", NEWLINE, TAB_AS_SPACES, IUTILS_name_to_string(dependsOnName).c_str(), type_name);
			target_done = true;
		}
	}

	bool missing2 = true;

	FOR DEP2 IN RDB$DEPENDENCIES
		WITH DEP2.RDB$DEPENDENT_NAME EQ name.object.c_str() AND
			 DEP2.RDB$DEPENDENT_TYPE EQ obj_type
		SORTED BY DEP2.RDB$DEPENDENT_SCHEMA_NAME
	{
		const QualifiedMetaString dependentName(DEP2.RDB$DEPENDENT_NAME, DEP2.RDB$DEPENDENT_SCHEMA_NAME);

		if (name.schema.hasData() && name.schema != dependentName.schema)
			continue;

		const QualifiedMetaString dependedOnName(DEP2.RDB$DEPENDED_ON_NAME, DEP2.RDB$DEPENDED_ON_SCHEMA_NAME);

		if (missing2)
		{
			if (!target_done)
			{
				const char* type_name = Object_types[obj_type];
				isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, IUTILS_name_to_string(dependentName).c_str(), type_name);
				target_done = true;
			}

			isqlGlob.prints(NEWLINE);
			missing2 = false;
		}
		else
			isqlGlob.prints(", ");

		const char* type_name = Object_types[DEP2.RDB$DEPENDED_ON_TYPE];
		if (DEP2.RDB$FIELD_NAME.NULL)
			isqlGlob.printf("%s:%s", IUTILS_name_to_string(dependedOnName).c_str(), type_name);
		else
		{
			isqlGlob.printf(
				"%s:%s<-%s",
				IUTILS_name_to_string(dependedOnName).c_str(),
				type_name,
				IUTILS_name_to_string(DEP2.RDB$FIELD_NAME).c_str());
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	bool missing3 = true;
	if (obj_type == obj_relation || obj_type == obj_view)
	{
		FOR RFR IN RDB$RELATION_FIELDS
			CROSS REL IN RDB$RELATIONS
			CROSS FLD IN RDB$FIELDS
			CROSS DEP3 IN RDB$DEPENDENCIES
			WITH RFR.RDB$RELATION_NAME = name.object.c_str() AND
				 REL.RDB$SCHEMA_NAME EQUIV RFR.RDB$SCHEMA_NAME AND
				 REL.RDB$RELATION_NAME = RFR.RDB$RELATION_NAME AND
				 RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
				 RFR.RDB$FIELD_SOURCE = FLD.RDB$FIELD_NAME AND
				 DEP3.RDB$DEPENDENT_SCHEMA_NAME EQUIV RFR.RDB$FIELD_SOURCE_SCHEMA_NAME AND
				 DEP3.RDB$DEPENDENT_NAME = RFR.RDB$FIELD_SOURCE AND
				 DEP3.RDB$DEPENDENT_TYPE EQ obj_computed
			SORTED BY RFR.RDB$FIELD_POSITION
		{
			const QualifiedMetaString relationName(RFR.RDB$RELATION_NAME, RFR.RDB$SCHEMA_NAME);

			if (name.schema.hasData() && name.schema != relationName.schema)
				continue;

			const bool isTable = REL.RDB$VIEW_BLR.NULL && (REL.RDB$DBKEY_LENGTH.NULL || REL.RDB$DBKEY_LENGTH == 8);

			if ((obj_type == obj_relation && !isTable) || (obj_type == obj_view && isTable) ||
				FLD.RDB$COMPUTED_BLR.NULL)	// redundant
			{
				continue;
			}

			const QualifiedMetaString dependedOnName(DEP3.RDB$DEPENDED_ON_NAME, DEP3.RDB$DEPENDED_ON_SCHEMA_NAME);

			if (missing3)
			{
				if (!target_done)
				{
					const char* type_name = Object_types[obj_type];
					isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, IUTILS_name_to_string(relationName).c_str(), type_name);
					target_done = true;
				}

				isqlGlob.prints(NEWLINE);
				missing3 = false;
			}
			else
				isqlGlob.prints(", ");

			const char* type_name = Object_types[DEP3.RDB$DEPENDED_ON_TYPE];

			isqlGlob.printf(
				"Field-%s(%s):%s->%s:%s",
				IUTILS_name_to_string(RFR.RDB$FIELD_NAME).c_str(),
				IUTILS_name_to_string(FLD.RDB$FIELD_NAME).c_str(),
				Object_types[obj_computed],
				IUTILS_name_to_string(dependedOnName).c_str(),
				type_name);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	else if (obj_type == obj_procedure)
	{
		// This code shouldn't find anything under normal circumstances.
		FOR PAR IN RDB$PROCEDURE_PARAMETERS
			CROSS FLD IN RDB$FIELDS
			CROSS DEP3 IN RDB$DEPENDENCIES
			WITH PAR.RDB$PROCEDURE_NAME = name.object.c_str() AND
				 PAR.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
				 PAR.RDB$FIELD_SOURCE = FLD.RDB$FIELD_NAME AND
				 DEP3.RDB$DEPENDENT_SCHEMA_NAME EQUIV PAR.RDB$FIELD_SOURCE_SCHEMA_NAME AND
				 DEP3.RDB$DEPENDENT_NAME = PAR.RDB$FIELD_SOURCE AND
				 DEP3.RDB$DEPENDENT_TYPE EQ obj_computed
			SORTED BY PAR.RDB$PARAMETER_TYPE, PAR.RDB$PARAMETER_NUMBER
		{
			const QualifiedMetaString procedureName(PAR.RDB$PROCEDURE_NAME, PAR.RDB$SCHEMA_NAME);

			if (name.schema.hasData() && name.schema != procedureName.schema)
				continue;

			if (FLD.RDB$COMPUTED_BLR.NULL) // redundant
				continue;

			const QualifiedMetaString dependedOnName(DEP3.RDB$DEPENDED_ON_NAME, DEP3.RDB$DEPENDED_ON_SCHEMA_NAME);

			if (missing3)
			{
				if (!target_done)
				{
					const char* type_name = Object_types[obj_type];
					isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, IUTILS_name_to_string(procedureName).c_str(), type_name);
					target_done = true;
				}

				isqlGlob.prints(NEWLINE);
				missing3 = false;
			}
			else
				isqlGlob.prints(", ");

			const char* type_name = Object_types[DEP3.RDB$DEPENDED_ON_TYPE];

			isqlGlob.printf(
				"%s-%s(%s):%s->%s:%s",
				(PAR.RDB$PARAMETER_TYPE ? "Output" : "Input"),
				IUTILS_name_to_string(PAR.RDB$PARAMETER_NAME).c_str(),
				IUTILS_name_to_string(FLD.RDB$FIELD_NAME).c_str(),
				Object_types[obj_computed],
				IUTILS_name_to_string(dependedOnName).c_str(),
				type_name);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (!target_done)
		return OBJECT_NOT_FOUND;

	isqlGlob.prints(NEWLINE);
	return SKIP;
}


static processing_state show_dialect()
{
/**************************************
 *
 *	s h o w _ d i a l e c t
 *
 **************************************
 *
 *	Print out the SQL dialect information
 *
 **************************************/

	if (isqlGlob.db_SQL_dialect > 0)
	{
		isqlGlob.printf("%38s%d%s%d",
				"Client SQL dialect is set to: ", isqlGlob.SQL_dialect,
				" and database SQL dialect is: ", isqlGlob.db_SQL_dialect);
	}
	else if (isqlGlob.SQL_dialect == 0)
	{
		isqlGlob.printf("%38s%s",
				"Client SQL dialect has not been set",
				" and no database has been connected yet.");
	}
	else
	{
		isqlGlob.printf("%38s%d%s",
				"Client SQL dialect is set to: ", isqlGlob.SQL_dialect,
				". No database has been connected.");
	}
	isqlGlob.printf(NEWLINE);
	return SKIP;
}


static processing_state show_domains(const std::optional<QualifiedMetaString>& name)
{
/*************************************
*
*	s h o w _ d o m a i n s
*
**************************************
*
* Functional description
*	Show all domains or the named domain
************************************/
	bool first = true;

	if (!name)
	{
		//  List all domain names in columns
		FOR FLD IN RDB$FIELDS
			WITH FLD.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
				 FLD.RDB$SYSTEM_FLAG NE 1
			SORTED BY FLD.RDB$SCHEMA_NAME, FLD.RDB$FIELD_NAME
		{
			first = false;

			const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

			isqlGlob.printf("%s%s", IUTILS_name_to_string(fieldName).c_str(), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			isqlGlob.printf(NEWLINE);
	}
	else
	{
		// List named domain

		FOR FLD IN RDB$FIELDS WITH
			FLD.RDB$FIELD_NAME EQ name->object.c_str()
			SORTED BY FLD.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != fieldName.schema)
				continue;

			first = false;
			// Print the name of the domain
			isqlGlob.printf("%-31s ", IUTILS_name_to_string(fieldName).c_str());

			// Array dimensions
			if (!FLD.RDB$DIMENSIONS.NULL)
			{
				isqlGlob.printf("ARRAY OF ");
				ISQL_array_dimensions(fieldName);
				isqlGlob.printf("%s                                ", NEWLINE);
			}

			if (!ISQL_printNumericType(fieldName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Length for CHARs
			if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) {
				isqlGlob.printf("(%d)", ISQL_get_field_length(fieldName));
			}

			// Blob domains
			if (FLD.RDB$FIELD_TYPE == blr_blob)
			{
				isqlGlob.printf(" segment %u, subtype ", (USHORT) FLD.RDB$SEGMENT_LENGTH);
				const int subtype  = FLD.RDB$FIELD_SUB_TYPE;
				if (subtype >= 0 && subtype <= MAX_BLOBSUBTYPES) {
					isqlGlob.prints(Sub_types[subtype]);
				}
				else {
					isqlGlob.printf("%d", subtype);
				}
			}

			// Show international character sets
			SSHORT char_set_id = 0;
			if (!FLD.RDB$CHARACTER_SET_ID.NULL)
				char_set_id = FLD.RDB$CHARACTER_SET_ID;

			SSHORT collation = 0;
			if (!FLD.RDB$COLLATION_ID.NULL)
				collation = FLD.RDB$COLLATION_ID;

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob && FLD.RDB$FIELD_SUB_TYPE == isc_blob_text)
			{
				show_charsets(char_set_id, collation);
			}

			if (FLD.RDB$NULL_FLAG != 1) {
				isqlGlob.printf(" Nullable");
			}
			else {
				isqlGlob.printf(" Not Null");
			}
			isqlGlob.printf(NEWLINE);

			ISC_QUAD default_source;
			ISQL_get_domain_default_source(fieldName, &default_source);
			if (default_source.gds_quad_high)
			{
				isqlGlob.printf("                                ");
				SHOW_print_metadata_text_blob (isqlGlob.Out, &default_source);
				isqlGlob.printf(NEWLINE);
			}

			if (!FLD.RDB$VALIDATION_SOURCE.NULL)
			{
				isqlGlob.printf("                                ");
				SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_exceptions(const std::optional<QualifiedMetaString>& name)
{
/**************************************
 *
 *	s h o w _ e x c e p t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show exceptions and their dependencies
 *	This version fetches all the exceptions, and only prints the
 *	one you asked for if you ask for one.  It could be optimized
 *	like other such functions.
 *
 **************************************/
	bool first = true;
	SCHAR type[20];

	FOR EXC IN RDB$EXCEPTIONS
		SORTED BY EXC.RDB$SCHEMA_NAME, EXC.RDB$EXCEPTION_NAME
	{
		const QualifiedMetaString exceptionName(EXC.RDB$EXCEPTION_NAME, EXC.RDB$SCHEMA_NAME);
		// List all objects if none specified, or just the named exception

		if (!name ||
			name == exceptionName ||
			(name->schema.isEmpty() && name->object == exceptionName.object))
		{
			first = false;

			isqlGlob.printf("%s", IUTILS_name_to_string(exceptionName).c_str());

			if (!EXC.RDB$MESSAGE.NULL && strlen(EXC.RDB$MESSAGE))
				isqlGlob.printf("; Msg: %s", EXC.RDB$MESSAGE);

			// Look up dependent objects --procedures and triggers
			bool first_dep = true;
			FOR DEP IN RDB$DEPENDENCIES WITH
				DEP.RDB$DEPENDED_ON_TYPE = obj_exception AND
				DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQUIV NULLIF(exceptionName.schema.c_str(), '') AND
				DEP.RDB$DEPENDED_ON_NAME EQ exceptionName.object.c_str()
				SORTED BY DEP.RDB$DEPENDENT_TYPE, DEP.RDB$DEPENDENT_NAME
			{
				if (first_dep)
				{
					isqlGlob.printf("; Used by: ");
					first_dep = false;
				}
				else
					isqlGlob.printf(", ");

				const QualifiedMetaString dependentName(DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_SCHEMA_NAME);

				switch (DEP.RDB$DEPENDENT_TYPE)
				{
					case obj_trigger:
						strcpy (type, "Trigger");
						break;
					case obj_procedure:
						strcpy (type, "Stored procedure");
						break;
					default:
						strcpy (type, "Unknown");
						break;
				}

				isqlGlob.printf("%s (%s)", IUTILS_name_to_string(dependentName).c_str(), type);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR

			isqlGlob.printf(NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_filters(const std::optional<MetaString>& name)
{
/**************************************
 *
 *	s h o w _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 *	Show blob filters in general or  for the named filters
 *
 **************************************/
	bool first = true;

	// Show all functions
	if (!name)
	{
		FOR FIL IN RDB$FILTERS
		SORTED BY FIL.RDB$FUNCTION_NAME
		{
			const MetaString filterName(FIL.RDB$FUNCTION_NAME);
			first = false;
			isqlGlob.printf("%s%s", IUTILS_name_to_string(filterName).c_str(), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
		{
			isqlGlob.printf(NEWLINE);
			return (SKIP);
		}

		return OBJECT_NOT_FOUND;
	}

	// We have a filter name, so expand on it
	FOR FIL IN RDB$FILTERS WITH
	   FIL.RDB$FUNCTION_NAME EQ name->c_str()
	{
		const MetaString filterName(FIL.RDB$FUNCTION_NAME);

		first = false;

		fb_utils::exact_name(FIL.RDB$MODULE_NAME);
		fb_utils::exact_name(FIL.RDB$ENTRYPOINT);

		isqlGlob.printf(
			"BLOB Filter: %s %s%sInput subtype: %d Output subtype: %d%s",
			IUTILS_name_to_string(filterName).c_str(),
			NEWLINE,
			TAB_AS_SPACES,
			FIL.RDB$INPUT_SUB_TYPE,
			FIL.RDB$OUTPUT_SUB_TYPE,
			NEWLINE);

	   isqlGlob.printf("%sFilter library is %s%s%sEntry point is %s%s%s",
				TAB_AS_SPACES, FIL.RDB$MODULE_NAME, NEWLINE,
				TAB_AS_SPACES, FIL.RDB$ENTRYPOINT, NEWLINE,
				NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_functions(const std::optional<QualifiedMetaString>& name, bool system, const char* msg)
{
/**************************************
 *
 *	s h o w _ f u n c t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show functions in general or for the named function
 *
 **************************************/

	int systemFlag = system ? 1 : 0;

	// If no function name was given, just list the functions
	if (!name)
	{
		bool first = true;

		// This query gets the function name; the next query
		// gets all the dependencies if any

		FOR FUN IN RDB$FUNCTIONS
			WITH FUN.RDB$SYSTEM_FLAG EQ systemFlag
			SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$PACKAGE_NAME, FUN.RDB$FUNCTION_NAME
		{
			if (first)
			{
				first = false;
				if (msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
			}

			const QualifiedMetaString functionName(
				FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME, FUN.RDB$PACKAGE_NAME);

			isqlGlob.printf("%s", IUTILS_name_to_string(functionName).c_str());

			if (!(FUN.RDB$VALID_BLR.NULL || FUN.RDB$VALID_BLR))
				isqlGlob.printf("; Invalid");

			if (FUN.RDB$PACKAGE_NAME.NULL)
			{
				bool first_dep = true;

				FOR DEP IN RDB$DEPENDENCIES
					WITH DEP.RDB$DEPENDENT_SCHEMA_NAME EQUIV NULLIF(functionName.schema.c_str(), '') AND
						 DEP.RDB$DEPENDENT_NAME EQ functionName.object.c_str()
					REDUCED TO DEP.RDB$DEPENDED_ON_SCHEMA_NAME, DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
					SORTED BY DEP.RDB$DEPENDED_ON_SCHEMA_NAME, DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
				{
					const QualifiedMetaString dependendOnName(
						DEP.RDB$DEPENDED_ON_NAME, DEP.RDB$DEPENDED_ON_SCHEMA_NAME);


					if (first_dep)
					{
						isqlGlob.printf("; Dependencies: ");
						first_dep = false;
					}
					else
						isqlGlob.printf(", ");

					isqlGlob.printf("%s (%s)", IUTILS_name_to_string(dependendOnName).c_str(),
						Object_types[DEP.RDB$DEPENDED_ON_TYPE]);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg (fbStatus);
					return ps_ERR;
				END_ERROR;
			}

			isqlGlob.printf(NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (first)
			return OBJECT_NOT_FOUND;

		return (SKIP);
	}

	processing_state return_state = OBJECT_NOT_FOUND;

	const QualifiedMetaString name1(name->object, name->schema, name->package);
	const auto name2 = name1.package.hasData() ?
		name1 :
		QualifiedMetaString(name->object, "", name->schema);

	FOR FUN IN RDB$FUNCTIONS
		WITH (FUN.RDB$FUNCTION_NAME EQ name1.object.c_str() AND
			  FUN.RDB$PACKAGE_NAME EQUIV NULLIF(name1.package.c_str(), '')) OR
			 (FUN.RDB$FUNCTION_NAME EQ name2.object.c_str() AND
			  FUN.RDB$PACKAGE_NAME EQUIV NULLIF(name2.package.c_str(), ''))
		SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$PACKAGE_NAME
	{
		const QualifiedMetaString functionName(
			FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME, FUN.RDB$PACKAGE_NAME);

		if (!(name1.schema.isEmpty() || name1.schema == functionName.schema) &&
			!(name2.schema.isEmpty() || name2.schema == functionName.schema))
		{
			continue;
		}

		if (!FUN.RDB$MODULE_NAME.NULL)
			return_state = show_func_legacy(functionName);
		else if (isqlGlob.major_ods >= ODS_VERSION12)
			return_state = show_func(functionName);
	}
	END_FOR

	return return_state;
}


static processing_state show_func(const QualifiedMetaString& name)
{
/**************************************
 *
 *	s h o w _ f u n c
 *
 **************************************
 *
 * Functional description
 *	Show function.
 *
 **************************************/
	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool first = true;

	FOR FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
			 FUN.RDB$FUNCTION_NAME EQ name.object.c_str() AND
			 FUN.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		first = false;

		isqlGlob.printf("Function: %s%s", IUTILS_name_to_string(name).c_str(), NEWLINE);

		if (!FUN.RDB$DETERMINISTIC_FLAG.NULL && FUN.RDB$DETERMINISTIC_FLAG)
			isqlGlob.printf("Deterministic function%s", NEWLINE);

		if (!FUN.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENTRYPOINT);
			isqlGlob.printf("External name: %s%s", FUN.RDB$ENTRYPOINT, NEWLINE);
		}

		if (!FUN.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = FUN.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
			isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
		}

		if (!FUN.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENGINE_NAME);
			isqlGlob.printf("Engine: %s%s", FUN.RDB$ENGINE_NAME, NEWLINE);
		}

		if (!FUN.RDB$FUNCTION_SOURCE.NULL)
		{
			isqlGlob.printf("Function text:%s", NEWLINE);
			isqlGlob.printf("=============================================================================%s", NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &FUN.RDB$FUNCTION_SOURCE);
			isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
		}

		bool first_param = true;
		const SSHORT default_charset = ISQL_get_default_char_set_id();

		FOR ARG IN RDB$FUNCTION_ARGUMENTS CROSS
			FLD IN RDB$FIELDS
			WITH ARG.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 ARG.RDB$FUNCTION_NAME EQ name.object.c_str() AND
				 ARG.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '') AND
				 ARG.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
				 ARG.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME
			SORTED BY ARG.RDB$ARGUMENT_POSITION
		{
			if (first_param)
			{
				isqlGlob.printf("Parameters:%s", NEWLINE);
				first_param = false;
			}

			isqlGlob.printf(
				"%-33s %s ",
				IUTILS_name_to_string(ARG.RDB$ARGUMENT_NAME).c_str(),
				(ARG.RDB$ARGUMENT_POSITION == FUN.RDB$RETURN_ARGUMENT ? "OUTPUT" : "INPUT"));

			prm_mech_t mechanism = prm_mech_normal;
			bool prm_default_source_null = true;
			ISC_QUAD prm_default_source;

			if (!ARG.RDB$ARGUMENT_MECHANISM.NULL)
				mechanism = (prm_mech_t) ARG.RDB$ARGUMENT_MECHANISM;

			if (ARG.RDB$ARGUMENT_POSITION != FUN.RDB$RETURN_ARGUMENT)
			{
				prm_default_source_null = ARG.RDB$DEFAULT_SOURCE.NULL;
				prm_default_source = ARG.RDB$DEFAULT_SOURCE;
			}

			const QualifiedMetaString relationName(ARG.RDB$RELATION_NAME, ARG.RDB$RELATION_SCHEMA_NAME);
			const MetaString relationField(ARG.RDB$FIELD_NAME);
			const QualifiedMetaString domainName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

			const bool basedOnColumn = relationName.object.hasData() && relationField.hasData();
			// Decide if this is a user-created domain
			if (!fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				isqlGlob.printf("(%s", (mechanism == prm_mech_type_of ? "TYPE OF " : ""));

				if (basedOnColumn)
				{
					isqlGlob.printf(
						"COLUMN %s.%s) ",
						IUTILS_name_to_string(relationName).c_str(),
						relationField.c_str());
				}
				else
					isqlGlob.printf("%s) ", IUTILS_name_to_string(domainName).c_str());
			}

			if (!ISQL_printNumericType(domainName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Use RDB$CHARACTER_LENGTH instead of RDB$FIELD_LENGTH
			//   FSG 19.Nov.2000
			if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				!FLD.RDB$CHARACTER_LENGTH.NULL)
			{
				isqlGlob.printf("(%d)", FLD.RDB$CHARACTER_LENGTH);
			}

			// Show international character sets and collations

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob)
			{
				SSHORT charset = 0, collation = 0;

				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					charset = FLD.RDB$CHARACTER_SET_ID;

				bool prm_collation_null = ARG.RDB$COLLATION_ID.NULL;
				if (!prm_collation_null)
					collation = ARG.RDB$COLLATION_ID;

				if (prm_collation_null)
				{
					FOR RFL IN RDB$RELATION_FIELDS
						WITH RFL.RDB$SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
							 RFL.RDB$RELATION_NAME = relationName.object.c_str() AND
							 RFL.RDB$FIELD_NAME = ARG.RDB$FIELD_NAME
					{
						prm_collation_null = RFL.RDB$COLLATION_ID.NULL;
						if (!prm_collation_null)
							collation = RFL.RDB$COLLATION_ID;
					}
					END_FOR
				}

				if (prm_collation_null && !FLD.RDB$COLLATION_ID.NULL)
					collation = FLD.RDB$COLLATION_ID;

				show_charsets(charset, collation);
			}

			if (ARG.RDB$ARGUMENT_POSITION != FUN.RDB$RETURN_ARGUMENT) // input, try to show default and make Vlad happy.
			{
				if (!prm_default_source_null)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
				}
				else if (fb_utils::implicit_domain(domainName.object.c_str()) && !FLD.RDB$DEFAULT_SOURCE.NULL)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
				}
			}

			isqlGlob.printf(NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_func_legacy(const QualifiedMetaString& name)
{
/**************************************
 *
 *	s h o w _ f u n c _ l e g a c y
 *
 **************************************
 *
 * Functional description
 *	Show legacy function.
 *
 **************************************/
	bool first = true;

	FOR FUN IN RDB$FUNCTIONS CROSS
		FNA IN RDB$FUNCTION_ARGUMENTS
		WITH FNA.RDB$SCHEMA_NAME EQUIV FUN.RDB$SCHEMA_NAME AND
			 FNA.RDB$FUNCTION_NAME EQ FUN.RDB$FUNCTION_NAME AND
			 FNA.RDB$PACKAGE_NAME MISSING AND
			 FUN.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
			 FUN.RDB$FUNCTION_NAME EQ name.object.c_str() AND
			 FUN.RDB$PACKAGE_NAME MISSING AND
			 FUN.RDB$MODULE_NAME NOT MISSING
		SORTED BY FNA.RDB$ARGUMENT_POSITION
	{
		fb_utils::exact_name(FUN.RDB$MODULE_NAME);
		fb_utils::exact_name(FUN.RDB$ENTRYPOINT);

		if (first)
		{
			isqlGlob.printf("%sExternal function %s:%s", NEWLINE, IUTILS_name_to_string(name).c_str(), NEWLINE);
			isqlGlob.printf("Function library is %s%s", FUN.RDB$MODULE_NAME, NEWLINE);
			isqlGlob.printf("Entry point is %s%s", FUN.RDB$ENTRYPOINT, NEWLINE);
		}

		SSHORT ptype = (SSHORT) abs(FNA.RDB$MECHANISM);
		if (ptype > MAX_UDFPARAM_TYPES) {
			ptype = MAX_UDFPARAM_TYPES;
		}

		first = false;
		if (FUN.RDB$RETURN_ARGUMENT == FNA.RDB$ARGUMENT_POSITION)
		{
			isqlGlob.printf("Returns %s%s", UDF_param_types[ptype],
						(FNA.RDB$MECHANISM < 0 ? " FREE_IT " : " "));
		}
		else {
			isqlGlob.printf("Argument %d:%s ", FNA.RDB$ARGUMENT_POSITION, UDF_param_types[ptype]);
		}

		for (int i = 0; Column_types[i].type; i++)
		{
			if (FNA.RDB$FIELD_TYPE == Column_types[i].type)
			{
				bool precision_known = false;

				// Handle Integral subtypes NUMERIC and DECIMAL
				// We are ODS >= 10
				if ( (isqlGlob.major_ods >= ODS_VERSION10) &&
						((FNA.RDB$FIELD_TYPE == blr_short) ||
						(FNA.RDB$FIELD_TYPE == blr_long) ||
						(FNA.RDB$FIELD_TYPE == blr_int64) ||
						(FNA.RDB$FIELD_TYPE == blr_int128)) )
				{
					// We are Dialect >=3 since FIELD_PRECISION is non-NULL
					if (!FNA.RDB$FIELD_PRECISION.NULL &&
						FNA.RDB$FIELD_SUB_TYPE > 0 &&
						FNA.RDB$FIELD_SUB_TYPE <= MAX_INTSUBTYPES)
					{
						isqlGlob.printf("%s(%d, %d)",
									Integral_subtypes[FNA.RDB$FIELD_SUB_TYPE],
									FNA.RDB$FIELD_PRECISION,
									-FNA.RDB$FIELD_SCALE);
						precision_known = true;
					}
				}

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((FNA.RDB$FIELD_TYPE == blr_short) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(4, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_long) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(9, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_double) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(15, %d)", -FNA.RDB$FIELD_SCALE);
					else
						isqlGlob.printf("%s", Column_types[i].type_name);
				}
				break;
			}

		}

		// Print length where appropriate
		if (FNA.RDB$FIELD_TYPE == blr_text || FNA.RDB$FIELD_TYPE == blr_varying ||
			FNA.RDB$FIELD_TYPE == blr_cstring)
		{
			FOR ARG IN RDB$FUNCTION_ARGUMENTS CROSS
				CS IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
				WITH ARG.RDB$SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
					 ARG.RDB$FUNCTION_NAME EQ name.object.c_str() AND
					 ARG.RDB$PACKAGE_NAME MISSING AND
					 ARG.RDB$ARGUMENT_POSITION EQ FNA.RDB$ARGUMENT_POSITION
			{
				const QualifiedMetaString charSetName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);

				isqlGlob.printf(
					"(%d) CHARACTER SET %s",
					(FNA.RDB$FIELD_LENGTH / MAX (1, CS.RDB$BYTES_PER_CHARACTER)),
					IUTILS_name_to_string(charSetName).c_str());
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR
		}

		isqlGlob.printf(NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_generators(const std::optional<QualifiedMetaString>& name)
{
/**************************************
 *
 *	s h o w _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Show generators including the current number they return
 *      We do this by selecting the GEN_ID of each one,
 *         incrementing by 0 to not change the current value.
 *
 **************************************/
	bool found = false;

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 1));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	// If the user has set his client dialect to 1, we take that to
	// mean that he wants to see just the lower 32 bits of the
	// generator, as in V5.  Otherwise, we show him the whole 64-bit value.
	const bool use64 = isqlGlob.SQL_dialect >= SQL_DIALECT_V6_TRANSITION;
	mb->setType(fbStatus, 0, use64 ? SQL_INT64 : SQL_LONG);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<20> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());
	unsigned off = outMetadata->getOffset(fbStatus, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	// Show all generators or named generator
	FOR GEN IN RDB$GENERATORS
		SORTED BY GEN.RDB$SCHEMA_NAME, GEN.RDB$GENERATOR_NAME
	{
		const QualifiedMetaString genName(GEN.RDB$GENERATOR_NAME, GEN.RDB$SCHEMA_NAME);

		if ((!name && (GEN.RDB$SYSTEM_FLAG.NULL || GEN.RDB$SYSTEM_FLAG == 0)) ||
			name == genName ||
			(name->schema.isEmpty() && name->object == genName.object))
		{
			// Get the current id for each generator

			string query;
			query.printf(
				"SELECT GEN_ID(%s, 0) FROM %sRDB$DATABASE",
				IUTILS_name_to_string(genName).c_str(),
				(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""));

			DB->execute(fbStatus, fbTrans, 0, query.c_str(), isqlGlob.SQL_dialect,
				NULL, NULL, outMetadata, outBuffer);
			if (ISQL_errmsg (fbStatus))
				continue;

			found = true;
			ISC_INT64 val = use64 ? *((ISC_INT64*) &outBuffer[off]) : *((SLONG*) &outBuffer[off]);

			isqlGlob.printf("Generator %s, current value: %" SQUADFORMAT,
				IUTILS_name_to_string(genName).c_str(), val);

			if (isqlGlob.major_ods >= ODS_VERSION12)
			{
				FOR G2 IN RDB$GENERATORS
					WITH G2.RDB$SCHEMA_NAME EQUIV NULLIF(genName.schema.c_str(), '') AND
						 G2.RDB$GENERATOR_NAME = genName.object.c_str()
				{
					ISC_INT64 initval = !G2.RDB$INITIAL_VALUE.NULL ? G2.RDB$INITIAL_VALUE : 0;
					isqlGlob.printf(", initial value: %" SQUADFORMAT ", increment: %" SLONGFORMAT,
						initval, G2.RDB$GENERATOR_INCREMENT);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}

			isqlGlob.prints(NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (!found)
		return (OBJECT_NOT_FOUND);

	return SKIP;
}


static void show_index(const QualifiedMetaString& relationName,
					   const QualifiedMetaString& indexName,
					   const SSHORT unique_flag,
					   const SSHORT index_type,
					   const SSHORT inactive)
{
/**************************************
 *
 *	s h o w _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Show an index.
 *
 *	relation_name -- Name of table to investigate
 *
 **************************************/

	isqlGlob.printf(
		"%s%s%s INDEX ON %s",
		IUTILS_name_to_string(indexName).c_str(),
		(unique_flag ? " UNIQUE" : ""),
		(index_type == 1 ? " DESCENDING" : ""), IUTILS_name_to_string(relationName.object).c_str());

	// Get column names

	SCHAR collist[BUFFER_LENGTH512];

	if (ISQL_get_index_segments(collist, sizeof(collist), indexName))
		isqlGlob.printf("(%s) %s%s", collist, (inactive ? "(inactive)" : ""), NEWLINE);
}


static processing_state show_indices(const std::optional<QualifiedMetaString>& name)
{
/**************************************
 *
 *	s h o w _ i n d i c e s
 *
 **************************************
 *
 * Functional description
 *	shows indices for a given table name or index name or all tables
 *
 *	Use a static SQL query to get the info and print it.
 *
 *	relation_name -- Name of table to investigate
 *
 **************************************/
	bool first = true;

	// The names stored in the database are all upper case

	if (name)
	{
		FOR IDX IN RDB$INDICES
			WITH IDX.RDB$RELATION_NAME EQ name->object.c_str() OR
				 IDX.RDB$INDEX_NAME EQ name->object.c_str()
			SORTED BY IDX.RDB$SCHEMA_NAME, IDX.RDB$INDEX_NAME
		{
			const QualifiedMetaString indexName(IDX.RDB$INDEX_NAME, IDX.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != indexName.schema)
				continue;

			const QualifiedMetaString relationName(IDX.RDB$RELATION_NAME, IDX.RDB$SCHEMA_NAME);

			if (IDX.RDB$INDEX_INACTIVE.NULL)
				IDX.RDB$INDEX_INACTIVE = 0;

			show_index(relationName, indexName,
					   IDX.RDB$UNIQUE_FLAG, IDX.RDB$INDEX_TYPE, IDX.RDB$INDEX_INACTIVE);

			if (!IDX.RDB$EXPRESSION_BLR.NULL)
			{
				isqlGlob.printf(" COMPUTED BY ");
				if (!IDX.RDB$EXPRESSION_SOURCE.NULL)
					SHOW_print_metadata_text_blob (isqlGlob.Out, &IDX.RDB$EXPRESSION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

			if (!IDX.RDB$CONDITION_SOURCE.NULL)
			{
				isqlGlob.printf(" ");
				SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX.RDB$CONDITION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

			first = false;
		}
		END_FOR
			ON_ERROR ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (first)
			return (OBJECT_NOT_FOUND);

		return (SKIP);

	}
	else
	{
		FOR IDX IN RDB$INDICES CROSS
			REL IN RDB$RELATIONS
			WITH REL.RDB$SCHEMA_NAME EQUIV IDX.RDB$SCHEMA_NAME AND
				 REL.RDB$RELATION_NAME = IDX.RDB$RELATION_NAME AND
				 (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING)
			SORTED BY IDX.RDB$SCHEMA_NAME, IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME
		{
			const QualifiedMetaString indexName(IDX.RDB$INDEX_NAME, IDX.RDB$SCHEMA_NAME);
			const QualifiedMetaString relationName(IDX.RDB$RELATION_NAME, IDX.RDB$SCHEMA_NAME);

			first = false;

			show_index(relationName, indexName,
					   IDX.RDB$UNIQUE_FLAG, IDX.RDB$INDEX_TYPE, IDX.RDB$INDEX_INACTIVE);

			if (!IDX.RDB$EXPRESSION_BLR.NULL)
			{
				isqlGlob.printf(" COMPUTED BY ");
				if (!IDX.RDB$EXPRESSION_SOURCE.NULL)
					SHOW_print_metadata_text_blob (isqlGlob.Out, &IDX.RDB$EXPRESSION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

			if (!IDX.RDB$CONDITION_SOURCE.NULL)
			{
				isqlGlob.printf(" ");
				SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX.RDB$CONDITION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (first)
			return (OBJECT_NOT_FOUND);

		return (SKIP);
	}
}


static processing_state show_packages(const std::optional<QualifiedMetaString>& name, bool sys, const SCHAR* msg)
{
/*************************************
*
*	s h o w _ p a c k a g e s
*
**************************************
*
* Functional description
*	Show all packages or the named package
************************************/
	if (isqlGlob.major_ods < ODS_VERSION12)
		return OBJECT_NOT_FOUND;

	bool first = true;

	if (!name)
	{
		//  List all package names in columns
		FOR PACK IN RDB$PACKAGES
			SORTED BY PACK.RDB$SCHEMA_NAME, PACK.RDB$PACKAGE_NAME
		{
			const QualifiedMetaString packageName(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);
			bool system_flag = !PACK.RDB$SYSTEM_FLAG.NULL && PACK.RDB$SYSTEM_FLAG > 0;

			if (system_flag == sys)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
				first = false;

				isqlGlob.printf("%s%s", IUTILS_name_to_string(packageName).c_str(), NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			isqlGlob.printf(NEWLINE);
	}
	else
	{
		// List named package

		FOR PACK IN RDB$PACKAGES
			WITH PACK.RDB$PACKAGE_NAME EQ name->object.c_str()
			SORTED BY PACK.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString packageName(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != packageName.schema)
				continue;

			first = false;

			// Print the name of the package
			isqlGlob.printf("%-31s ", IUTILS_name_to_string(packageName).c_str());

			isqlGlob.printf(NEWLINE);

			if (!PACK.RDB$SQL_SECURITY.NULL)
			{
				const char* ss = PACK.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
				isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
			}

			if (!PACK.RDB$PACKAGE_HEADER_SOURCE.NULL)
			{
				isqlGlob.printf("%s%s", "Header source:", NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &PACK.RDB$PACKAGE_HEADER_SOURCE);
				isqlGlob.printf(NEWLINE);
			}
			else
				isqlGlob.printf("Missing package header source.%s", NEWLINE);

			if (!PACK.RDB$PACKAGE_BODY_SOURCE.NULL)
			{
				isqlGlob.printf("%s%s%s:%s", NEWLINE, "Body source",
					(!PACK.RDB$VALID_BODY_FLAG.NULL && PACK.RDB$VALID_BODY_FLAG != 0 ?
						"" : " (invalid)"),
					NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &PACK.RDB$PACKAGE_BODY_SOURCE);
				isqlGlob.printf(NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static void printMap(bool extract, bool global, const MetaString& name, char* usng, const MetaString& plugin,
	const MetaString& db, const MetaString& fromType, const MetaString& from, short toType, const MetaString& to)
{
	if (extract)
	{
		isqlGlob.printf("CREATE ");
		if (global)
			isqlGlob.printf("OR ALTER GLOBAL ");
	}

	isqlGlob.printf("MAPPING %s ", IUTILS_name_to_string(name).c_str());

	isqlGlob.printf("USING ");
	switch (usng[0])
	{
	case 'P':
		if (plugin.isEmpty())
			isqlGlob.printf("ANY PLUGIN ");
		else
			isqlGlob.printf("PLUGIN %s ", IUTILS_name_to_string(plugin).c_str());
		break;
	case 'S':
		isqlGlob.printf("ANY PLUGIN SERVERWIDE ");
		break;
	case '*':
		isqlGlob.printf("* ");
		break;
	case 'M':
		isqlGlob.printf("MAPPING ");
		break;
	default:
		isqlGlob.printf("/*unknown = %c*/ ", usng[0]);
	}

	if (db.hasData())
		isqlGlob.printf("IN %s ", IUTILS_name_to_string(db).c_str());

	bool anyObj = from == "*";
	isqlGlob.printf("FROM %s", anyObj ? "ANY " : "");
	isqlGlob.printf("%s ", IUTILS_name_to_string(fromType).c_str());
	if (!anyObj)
		isqlGlob.printf("\'%s\' ", IUTILS_name_to_string(from).c_str());

	isqlGlob.printf("TO %s ", toType ? "ROLE" : "USER");
	if (to.hasData())
		isqlGlob.printf("%s", IUTILS_name_to_string(to).c_str());
	isqlGlob.printf("%s%s", extract ? ";" : "", NEWLINE);
}


processing_state SHOW_maps(bool extract, const std::optional<MetaString>& name)
{
/*************************************
*
*	s h o w _ m a p s
*
**************************************
*
* Functional description
*	Show all maps or maps to map_name
************************************/
	if (isqlGlob.major_ods < ODS_VERSION12)
		return OBJECT_NOT_FOUND;

	bool first = true;

	//  List all mappings
	FOR M IN RDB$AUTH_MAPPING WITH
		(M.RDB$SYSTEM_FLAG NE 1 OR M.RDB$SYSTEM_FLAG MISSING)
		SORTED BY M.RDB$MAP_NAME
	{
		const MetaString mapName(M.RDB$MAP_NAME);

		if (!name || mapName == name)
		{
			if (first && extract)
				isqlGlob.printf("%s/* Mapping security objects for this database */%s", NEWLINE, NEWLINE);
			first = false;

			printMap(extract, false, mapName, M.RDB$MAP_USING,
				M.RDB$MAP_PLUGIN,
				M.RDB$MAP_DB,
				M.RDB$MAP_FROM_TYPE, M.RDB$MAP_FROM,
				M.RDB$MAP_TO_TYPE, M.RDB$MAP_TO);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	bool firstGlobal = true;

	//  List global mappings
	FOR M IN SEC$GLOBAL_AUTH_MAPPING
		SORTED BY M.SEC$MAP_NAME
	{
		const MetaString mapName(M.SEC$MAP_NAME);

		if (!name || mapName == name)
		{
			if (firstGlobal)
			{
				const char* sep = extract ? "/" : "**";
				isqlGlob.printf("%s%s* Global mapping *%s%s",
					(first && (!extract)) ? "" : NEWLINE, sep, sep, NEWLINE);
				firstGlobal = false;
			}

			first = false;

			printMap(extract, true, mapName, M.SEC$MAP_USING,
				M.SEC$MAP_PLUGIN,
				M.SEC$MAP_DB,
				M.SEC$MAP_FROM_TYPE, M.SEC$MAP_FROM,
				M.SEC$MAP_TO_TYPE, M.SEC$MAP_TO);
		}
	}
	END_FOR
	ON_ERROR
		if (!extract)
			ISQL_errmsg(fbStatus);		// report error but not return error on it
	END_ERROR

	return first ? OBJECT_NOT_FOUND : SKIP;
}


static processing_state show_proc(const std::optional<QualifiedMetaString>& name, bool sys, const char* msg)
{
/**************************************
 *
 *	s h o w _ p r o c
 *
 **************************************
 *
 * Functional description
 *	shows text of a stored procedure given a name.
 *	or lists procedures if no argument.
 *
 *	procname -- Name of procedure to investigate
 *
 **************************************/

	// If no procedure name was given, just list the procedures

	if (!name)
	{
		// This query gets the procedure name; the next query
		// gets all the dependencies if any

		bool first_proc = true;

		FOR PRC IN RDB$PROCEDURES
			SORTED BY PRC.RDB$SCHEMA_NAME, PRC.RDB$PACKAGE_NAME, PRC.RDB$PROCEDURE_NAME
		{
			bool system_flag = !PRC.RDB$SYSTEM_FLAG.NULL && PRC.RDB$SYSTEM_FLAG > 0;

			if (system_flag == sys)
			{
				if (first_proc)
				{
					if (msg)
						isqlGlob.printf("%s%s%s", NEWLINE, msg, NEWLINE);
					first_proc = false;
				}

				const QualifiedMetaString procedureName(
					PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME, PRC.RDB$PACKAGE_NAME);

				isqlGlob.printf("%s", IUTILS_name_to_string(procedureName).c_str());

				if (!(PRC.RDB$VALID_BLR.NULL || PRC.RDB$VALID_BLR))
					isqlGlob.printf("; Invalid");

				if (PRC.RDB$PACKAGE_NAME.NULL)
				{
					bool first_dep = true;
					FOR DEP IN RDB$DEPENDENCIES
						WITH DEP.RDB$DEPENDENT_SCHEMA_NAME EQUIV NULLIF(procedureName.schema.c_str(), '') AND
							 DEP.RDB$DEPENDENT_NAME EQ procedureName.object.c_str()
						REDUCED TO DEP.RDB$DEPENDED_ON_SCHEMA_NAME, DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
						SORTED BY DEP.RDB$DEPENDED_ON_SCHEMA_NAME, DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
					{
						const QualifiedMetaString dependendOnName(
							DEP.RDB$DEPENDED_ON_NAME, DEP.RDB$DEPENDED_ON_SCHEMA_NAME);

						if (first_dep)
						{
							isqlGlob.printf("; Dependencies: ");
							first_dep = false;
						}
						else
							isqlGlob.printf(", ");

						isqlGlob.printf(
							"%s (%s)",
							IUTILS_name_to_string(dependendOnName).c_str(),
							Object_types[DEP.RDB$DEPENDED_ON_TYPE]);
					}
					END_FOR
					ON_ERROR
						ISQL_errmsg (fbStatus);
						return ps_ERR;
					END_ERROR
				}

				isqlGlob.printf(NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (first_proc)
			return OBJECT_NOT_FOUND;

		isqlGlob.printf(NEWLINE);
		return (SKIP);
	}

	// A procedure was named, so print all the info on that procedure

	bool first = true;

	const QualifiedMetaString name1(name->object, name->schema, name->package);
	const auto name2 = name1.package.hasData() ?
		name1 :
		QualifiedMetaString(name->object, "", name->schema);

	FOR PRC IN RDB$PROCEDURES
		WITH (PRC.RDB$PROCEDURE_NAME EQ name1.object.c_str() AND
			  PRC.RDB$PACKAGE_NAME EQUIV NULLIF(name1.package.c_str(), '')) OR
		     (PRC.RDB$PROCEDURE_NAME EQ name2.object.c_str() AND
			  PRC.RDB$PACKAGE_NAME EQUIV NULLIF(name2.package.c_str(), ''))
		SORTED BY PRC.RDB$SCHEMA_NAME, PRC.RDB$PACKAGE_NAME
	{
		const QualifiedMetaString procedureName(
			PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME, PRC.RDB$PACKAGE_NAME);

		if (!(name1.schema.isEmpty() || name1.schema == procedureName.schema) &&
			!(name2.schema.isEmpty() || name2.schema == procedureName.schema))
		{
			continue;
		}

		first = false;

		isqlGlob.printf("Procedure: %s%s", IUTILS_name_to_string(procedureName).c_str(), NEWLINE);

		if (!PRC.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENTRYPOINT);
			isqlGlob.printf("External name: %s%s", PRC.RDB$ENTRYPOINT, NEWLINE);
		}

		if (!PRC.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = PRC.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
			isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
		}

		if (!PRC.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENGINE_NAME);
			isqlGlob.printf("Engine: %s%s", PRC.RDB$ENGINE_NAME, NEWLINE);
		}

		if (!PRC.RDB$PROCEDURE_SOURCE.NULL)
		{
			isqlGlob.printf("Procedure text:%s", NEWLINE);
			isqlGlob.printf("=============================================================================%s", NEWLINE);
			SHOW_print_metadata_text_blob (isqlGlob.Out, &PRC.RDB$PROCEDURE_SOURCE);
			isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
		}

		bool first_param = true;

		FOR PRM IN RDB$PROCEDURE_PARAMETERS CROSS
			FLD IN RDB$FIELDS
			WITH PRM.RDB$SCHEMA_NAME EQUIV NULLIF(procedureName.schema.c_str(), '') AND
				 PRM.RDB$PACKAGE_NAME EQUIV NULLIF(procedureName.package.c_str(), '') AND
				 PRM.RDB$PROCEDURE_NAME EQ procedureName.object.c_str() AND
				 PRM.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
				 PRM.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME
			SORTED BY PRM.RDB$PARAMETER_TYPE, PRM.RDB$PARAMETER_NUMBER
		{
			if (first_param)
			{
				isqlGlob.printf("Parameters:%s", NEWLINE);
				first_param = false;
			}

			isqlGlob.printf(
				"%-33s %s ",
				IUTILS_name_to_string(PRM.RDB$PARAMETER_NAME).c_str(),
				(PRM.RDB$PARAMETER_TYPE ? "OUTPUT" : "INPUT"));

			prm_mech_t mechanism = prm_mech_normal;
			bool prm_default_source_null = true;
			ISC_QUAD prm_default_source;

			SSHORT collation = 0;
			bool prm_collation_null = true;

			if (!PRM.RDB$PARAMETER_MECHANISM.NULL)
				mechanism = (prm_mech_t) PRM.RDB$PARAMETER_MECHANISM;

			if (PRM.RDB$PARAMETER_TYPE == 0)
			{
				prm_default_source_null = PRM.RDB$DEFAULT_SOURCE.NULL;
				prm_default_source = PRM.RDB$DEFAULT_SOURCE;
			}

			prm_collation_null = PRM.RDB$COLLATION_ID.NULL;
			if (!prm_collation_null)
				collation = PRM.RDB$COLLATION_ID;

			const QualifiedMetaString domainName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);
			const QualifiedMetaString relationName(PRM.RDB$RELATION_NAME, PRM.RDB$RELATION_SCHEMA_NAME);
			const MetaString relationField(PRM.RDB$FIELD_NAME);

			if (prm_collation_null && relationName.object.hasData())
			{
				FOR RFL IN RDB$RELATION_FIELDS
					WITH RFL.RDB$SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
						 RFL.RDB$RELATION_NAME = relationName.object.c_str() AND
						 RFL.RDB$FIELD_NAME = PRM.RDB$FIELD_NAME
				{
					prm_collation_null = RFL.RDB$COLLATION_ID.NULL;
					if (!prm_collation_null)
						collation = RFL.RDB$COLLATION_ID;
				}
				END_FOR
			}

			if (prm_collation_null && !FLD.RDB$COLLATION_ID.NULL)
				collation = FLD.RDB$COLLATION_ID;

			const bool basedOnColumn = relationName.object.hasData() && relationField.hasData();
			// Decide if this is a user-created domain
			if (!fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				isqlGlob.printf("(%s", (mechanism == prm_mech_type_of ? "TYPE OF " : ""));

				if (basedOnColumn)
				{
					isqlGlob.printf(
						"COLUMN %s.%s) ",
						IUTILS_name_to_string(relationName).c_str(),
						relationField.c_str());
				}
				else
					isqlGlob.printf("%s) ", IUTILS_name_to_string(domainName).c_str());
			}

			if (!ISQL_printNumericType(domainName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Use RDB$CHARACTER_LENGTH instead of RDB$FIELD_LENGTH
			//   FSG 19.Nov.2000
			if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				!FLD.RDB$CHARACTER_LENGTH.NULL)
			{
				isqlGlob.printf("(%d)", FLD.RDB$CHARACTER_LENGTH);
			}

			// Show international character sets and collations

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob)
			{
				SSHORT charset = 0;
				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					charset = FLD.RDB$CHARACTER_SET_ID;

				show_charsets(charset, collation);
			}

			if (PRM.RDB$PARAMETER_TYPE == 0) // input, try to show default and make Vlad happy.
			{
				if (!prm_default_source_null)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
				}
				else if (fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) && !FLD.RDB$DEFAULT_SOURCE.NULL)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
				}
			}

			isqlGlob.printf(NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static processing_state show_publications(const std::optional<MetaString>& name, bool sys, const SCHAR* msg)
{
/**************************************
 *
 *	s h o w _ p u b l i c a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show publications.
 *
 **************************************/
	if (isqlGlob.major_ods < ODS_VERSION13)
		return OBJECT_NOT_FOUND;

	bool first = true;

	if (name)
	{
		// List named publication

		FOR PUB IN RDB$PUBLICATIONS WITH
			PUB.RDB$PUBLICATION_NAME EQ name->c_str()
		{
			const MetaString publicationName(PUB.RDB$PUBLICATION_NAME);

			first = false;

			isqlGlob.printf("%s: ", IUTILS_name_to_string(publicationName).c_str());

			const bool active_flag = (!PUB.RDB$ACTIVE_FLAG.NULL && PUB.RDB$ACTIVE_FLAG > 0);
			isqlGlob.printf("%s", active_flag ? "Enabled" : "Disabled");

			if (!PUB.RDB$AUTO_ENABLE.NULL && PUB.RDB$AUTO_ENABLE > 0)
				isqlGlob.printf(", Auto-enable");

			isqlGlob.printf(NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	else
	{
		//  List all publications

		FOR PUB IN RDB$PUBLICATIONS
			SORTED BY PUB.RDB$PUBLICATION_NAME
		{
			const MetaString publicationName(PUB.RDB$PUBLICATION_NAME);
			const bool system_flag = (!PUB.RDB$SYSTEM_FLAG.NULL && PUB.RDB$SYSTEM_FLAG > 0);

			if (system_flag == sys)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);

				first = false;

				isqlGlob.printf("%s%s", IUTILS_name_to_string(publicationName).c_str(), NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
			isqlGlob.printf(NEWLINE);
	}

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static void show_pub_table(const QualifiedMetaString& name)
{
/**************************************
 *
 *	s h o w _ p u b _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	Show publication status for the given table.
 *
 **************************************/
	if (isqlGlob.major_ods < ODS_VERSION13)
		return;

	bool first = true;

	// TODO: remove block and indendation
	{
		FOR PTAB IN RDB$PUBLICATION_TABLES CROSS
			PUB IN RDB$PUBLICATIONS OVER RDB$PUBLICATION_NAME
			WITH PTAB.RDB$TABLE_SCHEMA_NAME EQUIV NULLIF(name.schema.c_str(), '') AND
				 PTAB.RDB$TABLE_NAME EQ name.object.c_str()
			SORTED BY DESCENDING PUB.RDB$SYSTEM_FLAG, PUB.RDB$PUBLICATION_NAME
		{
			const MetaString publicationName(PUB.RDB$PUBLICATION_NAME);

			if (first)
			{
				TEXT msg[MSG_LENGTH];
				IUTILS_msg_get(MSG_PUBLICATIONS, msg);
				isqlGlob.printf("%s %s", msg, IUTILS_name_to_string(publicationName).c_str());
			}
			else
				isqlGlob.printf(", %s", IUTILS_name_to_string(publicationName).c_str());

			const bool active_flag = (!PUB.RDB$ACTIVE_FLAG.NULL && PUB.RDB$ACTIVE_FLAG > 0);
			isqlGlob.printf(" (%s)", active_flag ? "Enabled" : "Disabled");

			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR
	}

	if (!first)
		isqlGlob.printf(NEWLINE);
}


bool SHOW_system_privileges(const MetaString& name, const char* prefix, bool lf)
{
	bool first = true;

	FOR X IN RDB$ROLES WITH
		X.RDB$ROLE_NAME EQ name.c_str()
	{
		if (!X.RDB$SYSTEM_PRIVILEGES.NULL)
		{
			for (unsigned byte = 0; byte < sizeof(X.RDB$SYSTEM_PRIVILEGES); ++byte)
			{
				char b = X.RDB$SYSTEM_PRIVILEGES[byte];
				for (int bit = 0; bit < 8; ++bit)
				{
					if (b & (1 << bit))
					{
						FOR T IN RDB$TYPES
							WITH T.RDB$FIELD_NAME EQ 'RDB$SYSTEM_PRIVILEGES' AND
								 T.RDB$TYPE EQ (byte * 8 + bit)
						{
							if (first)
							{
								if (lf)
									isqlGlob.printf("%s", NEWLINE);
								isqlGlob.printf("%s", prefix);
							}
							else
								isqlGlob.printf(",");

							first = false;
							isqlGlob.printf(" %s", fb_utils::exact_name(T.RDB$TYPE_NAME));
						}
						END_FOR
					}
				}
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return false;
	END_ERROR

	return !first;
}


static processing_state show_role(const std::optional<MetaString>& name, bool system, const char* msg)
{
	if (isqlGlob.major_ods < ODS_VERSION9)
		return OBJECT_NOT_FOUND;

	if (!name)
	{
		// show role with no parameters, show all roles
		// **************************************
		// * Print the names of all roles from
		// * RDB$ROLES.  We use a dynamic query
		// * If there is any roles, then returns SKIP.
		// *	Otherwise returns OBJECT_NOT_FOUND.
		// **************************************/
		bool first = true;

		FOR X IN RDB$ROLES WITH
			X.RDB$ROLE_NAME NOT MISSING
			SORTED BY X.RDB$ROLE_NAME
		{
			const MetaString roleName(X.RDB$ROLE_NAME);
			bool system_flag = !X.RDB$SYSTEM_FLAG.NULL && X.RDB$SYSTEM_FLAG > 0;

			if (system_flag == system)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
				first = false;

				isqlGlob.printf("%s%s", IUTILS_name_to_string(roleName).c_str(), NEWLINE);

				/***
				if (SHOW_system_privileges(X.RDB$ROLE_NAME, "System privileges:", !odd))
				{
					isqlGlob.printf("%s", NEWLINE);
					odd = true;
				}
				***/
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (!first)
		{
			isqlGlob.printf(NEWLINE);
			return SKIP;
		}

		return OBJECT_NOT_FOUND;
	}

	// show role with role supplied, display users and other roles granted this role
	bool first = true;

	FOR FIRST 1 R IN RDB$ROLES
		WITH R.RDB$ROLE_NAME EQ name->c_str()
	{
		FOR PRV IN RDB$USER_PRIVILEGES WITH
			PRV.RDB$OBJECT_TYPE   EQ obj_sql_role AND
			(PRV.RDB$USER_TYPE    EQ obj_user      OR
			 PRV.RDB$USER_TYPE     EQ obj_sql_role) AND
			PRV.RDB$RELATION_NAME EQ name->c_str() AND
			PRV.RDB$PRIVILEGE     EQ 'M'
			SORTED BY  PRV.RDB$USER
		{
			if (first)
			{
				first = false;

				isqlGlob.printf(
					"Role %s is granted to:%s",
					IUTILS_name_to_string(PRV.RDB$RELATION_NAME).c_str(),
					NEWLINE);
			}

			isqlGlob.printf("%s%s", IUTILS_name_to_string(PRV.RDB$USER).c_str(), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR

		if (first)
		{
			first = false;

			isqlGlob.printf(
				"Role %s isn't granted to anyone.%s",
				IUTILS_name_to_string(R.RDB$ROLE_NAME).c_str(),
				NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);
	else if (SHOW_system_privileges(name.value(), "System privileges:", false))
		isqlGlob.printf("%s", NEWLINE);

	return (SKIP);
}


static processing_state show_schemas(const std::optional<MetaString>& name, bool system, const char* msg)
{
	if (isqlGlob.major_ods < ODS_VERSION14)
		return OBJECT_NOT_FOUND;

	bool first = true;

	FOR SCH IN RDB$SCHEMAS
		SORTED BY SCH.RDB$SCHEMA_NAME
	{
		const MetaString schemaName(SCH.RDB$SCHEMA_NAME);
		bool systemFlag = !SCH.RDB$SYSTEM_FLAG.NULL && SCH.RDB$SYSTEM_FLAG > 0;

		if ((name && name != schemaName) || (!name && systemFlag != system))
			continue;

		if (first && msg)
			isqlGlob.printf("%s%s", msg, NEWLINE);

		first = false;

		string defaultCharSet;
		if (!SCH.RDB$CHARACTER_SET_NAME.NULL)
		{
			const QualifiedMetaString defaultCharSetName(
				SCH.RDB$CHARACTER_SET_NAME, SCH.RDB$CHARACTER_SET_SCHEMA_NAME);

			defaultCharSet.printf(
				"; Default character set: %s",
				IUTILS_name_to_string(defaultCharSetName).c_str());
		}

		string sqlSecurity;
		if (!SCH.RDB$SQL_SECURITY.NULL)
		{
			sqlSecurity.printf(
				"; Default SQL SECURITY: %s",
				(SCH.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER"));
		}

		isqlGlob.printf(
			"%s%s%s%s",
			IUTILS_name_to_string(schemaName).c_str(),
			defaultCharSet.c_str(),
			sqlSecurity.c_str(),
			NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (!first)
	{
		isqlGlob.printf(NEWLINE);
		return SKIP;
	}

	return OBJECT_NOT_FOUND;
}


// ***********************
// s h o w _ s e c c l a s
// ***********************
// Show low-level, GDML security for an object. It may be table/view or procedure.
// Using SHOW SECCLASS <name> DET[AIL] will print the contents of the sec blob.
// Using SHOW SECCLASS * DET[AIL] will print the db-wide sec class in rdb$database.
static processing_state show_secclass(const std::optional<QualifiedMetaString>& name, bool detail)
{
	IsqlVar var;
	memset(&var, 0, sizeof(var));
	var.subType = isc_blob_acl;

	int count = 0;

	if (!name)
	{
		FOR D IN RDB$DATABASE
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
		{
			++count;
			isqlGlob.printf("Database-wide's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.setPtr = &SC.RDB$ACL;
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		return count ? SKIP : OBJECT_NOT_FOUND;
	}

	FOR REL IN RDB$RELATIONS
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH REL.RDB$RELATION_NAME EQ name->object.c_str()
		SORTED BY REL.RDB$SCHEMA_NAME
	{
		const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != relationName.schema)
			continue;

		++count;
		isqlGlob.printf("%s's main sec class %s%s",
			REL.RDB$VIEW_BLR.NULL ? "Table" : "View",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR REL2 IN RDB$RELATIONS
		CROSS SC IN RDB$SECURITY_CLASSES
		WITH REL2.RDB$RELATION_NAME EQ name->object.c_str() AND
			 REL2.RDB$DEFAULT_CLASS EQ SC.RDB$SECURITY_CLASS
		SORTED BY REL2.RDB$SCHEMA_NAME
	{
		const QualifiedMetaString relationName(REL2.RDB$RELATION_NAME, REL2.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != relationName.schema)
			continue;

		++count;
		isqlGlob.printf("%s's default sec class %s%s",
			REL2.RDB$VIEW_BLR.NULL ? "Table" : "View",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR RF IN RDB$RELATION_FIELDS
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH RF.RDB$RELATION_NAME EQ name->object.c_str()
		SORTED BY RF.RDB$SCHEMA_NAME, RF.RDB$FIELD_POSITION
	{
		const QualifiedMetaString relationName(RF.RDB$RELATION_NAME, RF.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != relationName.schema)
			continue;

		++count;
		isqlGlob.printf(
			"   Field %s - sec class %s%s",
			IUTILS_name_to_string(RF.RDB$FIELD_NAME).c_str(),
			SC.RDB$SECURITY_CLASS, NEWLINE);

		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR PR IN RDB$PROCEDURES
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH PR.RDB$PROCEDURE_NAME EQ name->object.c_str() AND
			 PR.RDB$PACKAGE_NAME MISSING
		SORTED BY PR.RDB$SCHEMA_NAME
	{
		const QualifiedMetaString procedureName(PR.RDB$PROCEDURE_NAME, PR.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != procedureName.schema)
			continue;

		++count;
		isqlGlob.printf("Procedure's sec class %s%s",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR FUN IN RDB$FUNCTIONS
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
			WITH FUN.RDB$FUNCTION_NAME EQ name->object.c_str() AND
				 FUN.RDB$PACKAGE_NAME MISSING
			SORTED BY FUN.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString functionName(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != functionName.schema)
				continue;

			++count;
			isqlGlob.printf("Function's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR PKG IN RDB$PACKAGES
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
			WITH PKG.RDB$PACKAGE_NAME EQ name->object.c_str()
			SORTED BY PKG.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString packageName(PKG.RDB$PACKAGE_NAME, PKG.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != packageName.schema)
				continue;

			++count;
			isqlGlob.printf("Package's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR GEN IN RDB$GENERATORS
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
			WITH GEN.RDB$GENERATOR_NAME EQ name->object.c_str()
			SORTED BY GEN.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString generatorName(GEN.RDB$GENERATOR_NAME, GEN.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != generatorName.schema)
				continue;

			++count;
			isqlGlob.printf("Sequence's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR XCP IN RDB$EXCEPTIONS
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
			WITH XCP.RDB$EXCEPTION_NAME EQ name->object.c_str()
			SORTED BY XCP.RDB$SCHEMA_NAME
		{
			const QualifiedMetaString exceptionName(XCP.RDB$EXCEPTION_NAME, XCP.RDB$SCHEMA_NAME);

			if (name->schema.hasData() && name->schema != exceptionName.schema)
				continue;

			++count;
			isqlGlob.printf("Exception's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (isqlGlob.major_ods >= ODS_VERSION14 && name->schema.isEmpty())
	{
		FOR SCH IN RDB$SCHEMAS
			CROSS SC IN RDB$SECURITY_CLASSES
			OVER RDB$SECURITY_CLASS
			WITH SCH.RDB$SCHEMA_NAME EQ name->object.c_str()
		{
			++count;
			isqlGlob.printf("Schema's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	return count ? SKIP : OBJECT_NOT_FOUND;
}


static processing_state show_table(const QualifiedMetaString& name, bool isView)
{
/**************************************
 *
 *	s h o w _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	shows columns, types, info for a given table name
 *	and text of views.
 *	Use a SQL query to get the info and print it.
 *	This also shows integrity constraints and triggers
 *
 *	name -- Name of table to investigate
 *
 **************************************/
	bool first = true;

	// Query to obtain relation information
	// REL.RDB$VIEW_BLR NOT MISSING

	FOR REL IN RDB$RELATIONS
		WITH REL.RDB$RELATION_NAME EQ name.object.c_str()
		SORTED BY REL.RDB$SCHEMA_NAME
	{
		const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

		if (name.schema.hasData() && name.schema != relationName.schema)
			continue;

		if ((isView && REL.RDB$VIEW_BLR.NULL) || (!isView && !REL.RDB$VIEW_BLR.NULL))
			continue;

		first = false;

		isqlGlob.printf(
			"%s: %s%s",
			(isView ? "View" : "Table"),
			IUTILS_name_to_string(relationName).c_str(),
			NEWLINE);

		if (!REL.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = REL.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
			isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
		}

		if (!REL.RDB$EXTERNAL_FILE.NULL)
			isqlGlob.printf("External file: %s%s", REL.RDB$EXTERNAL_FILE, NEWLINE);

	// TODO: indent

	FOR RFR IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS
		WITH FLD.RDB$SCHEMA_NAME EQUIV RFR.RDB$FIELD_SOURCE_SCHEMA_NAME AND
			 FLD.RDB$FIELD_NAME EQ RFR.RDB$FIELD_SOURCE AND
			 RFR.RDB$SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
			 RFR.RDB$RELATION_NAME EQ relationName.object.c_str()
		SORTED BY RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME
	{
		const QualifiedMetaString domainName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);
		const MetaString columnName(RFR.RDB$FIELD_NAME);

		// Get length of colname to align columns for printing

		// Print the column name in first column

		isqlGlob.printf("%-31s ", IUTILS_name_to_string(columnName).c_str());

		// Decide if this is a user-created domain
		if (!(fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) && FLD.RDB$SYSTEM_FLAG != 1))
			isqlGlob.printf("(%s) ", IUTILS_name_to_string(domainName).c_str());

		// Detect the existence of arrays

		if (!FLD.RDB$DIMENSIONS.NULL)
		{
			isqlGlob.printf("ARRAY OF ");
			ISQL_array_dimensions(domainName);
			isqlGlob.printf("%s                                ", NEWLINE);
		}

		// If a computed field, show the source and exit
		// Note that view columns which are computed are dealt with later.
		if (!FLD.RDB$COMPUTED_BLR.NULL && !isView)
		{
			isqlGlob.printf("Computed by: ");
			if (!FLD.RDB$COMPUTED_SOURCE.NULL)
				SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$COMPUTED_SOURCE);
			isqlGlob.printf(NEWLINE);
			continue;
		}

		if (!ISQL_printNumericType(domainName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
				FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
		{
			return ps_ERR;
		}

		SSHORT char_set_id = 0;
		if (!FLD.RDB$CHARACTER_SET_ID.NULL)
			char_set_id = FLD.RDB$CHARACTER_SET_ID;

		SSHORT collation = 0;
		if (!RFR.RDB$COLLATION_ID.NULL)
			collation = RFR.RDB$COLLATION_ID;
		else if (!FLD.RDB$COLLATION_ID.NULL)
			collation = FLD.RDB$COLLATION_ID;

		if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
		{
			isqlGlob.printf("(%d)", ISQL_get_field_length(domainName));

			if (FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary)
			{
				// Show international character sets and collations
				show_charsets(char_set_id, collation);
			}
		}

		if (FLD.RDB$FIELD_TYPE == blr_blob)
		{
			isqlGlob.printf(" segment %u, subtype ", (USHORT) FLD.RDB$SEGMENT_LENGTH);
			const int subtype  = FLD.RDB$FIELD_SUB_TYPE;
			if (subtype >= 0 && subtype <= MAX_BLOBSUBTYPES)
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}

			if (subtype == isc_blob_text)
			{
				// Show international character sets and collations
				show_charsets(char_set_id, collation);
			}
		}

		if (!FLD.RDB$COMPUTED_BLR.NULL)
		{
			// A view expression. Other computed fields will not reach this point.
			isqlGlob.printf(" Expression%s", NEWLINE);
			continue;
		}

		// The null flag is either 1 or null (for nullable)

		if (RFR.RDB$NULL_FLAG == 1 || FLD.RDB$NULL_FLAG == 1 ||
			(!RFR.RDB$BASE_FIELD.NULL && !ISQL_get_null_flag(relationName, columnName)))
		{
			isqlGlob.printf(" Not Null ");
		}
		else
		{
			isqlGlob.printf(" Nullable ");
		}

		if (!RFR.RDB$GENERATOR_NAME.NULL)
		{
			isqlGlob.printf("Identity (%s)",
				(RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_BY_DEFAULT ? "by default" :
				 RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_ALWAYS ? "always" : ""));
		}

		// Handle defaults for columns

		if (!RFR.RDB$DEFAULT_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &RFR.RDB$DEFAULT_SOURCE);
		else if (!FLD.RDB$DEFAULT_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
		isqlGlob.printf(NEWLINE);

		// Validation clause for domains
		if (!FLD.RDB$VALIDATION_SOURCE.NULL)
		{
			isqlGlob.printf("                                ");
			SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE);
			isqlGlob.printf(NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	// If this is a view and there were columns, print the view text

	if (!REL.RDB$VIEW_BLR.NULL)
	{
		isqlGlob.printf("View Source:%s==== ======%s", NEWLINE, NEWLINE);
		if (!REL.RDB$VIEW_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &REL.RDB$VIEW_SOURCE);
		isqlGlob.printf(NEWLINE);
	}

	// Handle any referential or primary constraint on this table

	SCHAR collist[BUFFER_LENGTH512];

	// Static queries for obtaining referential constraints

	FOR RELC1 IN RDB$RELATION_CONSTRAINTS
		WITH RELC1.RDB$SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
			 RELC1.RDB$RELATION_NAME EQ relationName.object.c_str()
		SORTED BY RELC1.RDB$CONSTRAINT_TYPE, RELC1.RDB$CONSTRAINT_NAME
	{
		const QualifiedMetaString indexName1(RELC1.RDB$INDEX_NAME, RELC1.RDB$SCHEMA_NAME);
		const MetaString constraintName(RELC1.RDB$CONSTRAINT_NAME);

		ISQL_get_index_segments(collist, sizeof(collist), indexName1);
		bool isPK = false;
		bool isUK = false;

		if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "PRIMARY", 7))
		{
			isPK = true;
			isqlGlob.printf("CONSTRAINT %s:%s", IUTILS_name_to_string(constraintName).c_str(), NEWLINE);
			isqlGlob.printf("  Primary key (%s)", collist);
		}
		else if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "UNIQUE", 6))
		{
			isUK = true;
			isqlGlob.printf("CONSTRAINT %s:%s", IUTILS_name_to_string(constraintName).c_str(), NEWLINE);
			isqlGlob.printf("  Unique key (%s)", collist);
		}
		else if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "FOREIGN", 7))
		{
			isqlGlob.printf("CONSTRAINT %s:%s", IUTILS_name_to_string(constraintName).c_str(), NEWLINE);
			isqlGlob.printf("  Foreign key (%s)", collist);

			FOR RELC2 IN RDB$RELATION_CONSTRAINTS CROSS
				REFC IN RDB$REF_CONSTRAINTS
				WITH RELC2.RDB$SCHEMA_NAME EQUIV NULLIF(REFC.RDB$CONST_SCHEMA_NAME_UQ, '') AND
					 RELC2.RDB$CONSTRAINT_NAME EQ REFC.RDB$CONST_NAME_UQ AND
					 REFC.RDB$SCHEMA_NAME EQUIV NULLIF(RELC1.RDB$SCHEMA_NAME, '') AND
					 REFC.RDB$CONSTRAINT_NAME EQ RELC1.RDB$CONSTRAINT_NAME
			{
				const QualifiedMetaString indexName2(RELC2.RDB$INDEX_NAME, RELC2.RDB$SCHEMA_NAME);
				const QualifiedMetaString referencesName(RELC2.RDB$RELATION_NAME, RELC2.RDB$SCHEMA_NAME);

				ISQL_get_index_segments(collist, sizeof(collist), indexName2);

				isqlGlob.printf("    References %s (%s)", IUTILS_name_to_string(referencesName).c_str(), collist);

				if (!REFC.RDB$UPDATE_RULE.NULL)
				{
					IUTILS_truncate_term (REFC.RDB$UPDATE_RULE, static_cast<USHORT>(strlen(REFC.RDB$UPDATE_RULE)));
					ISQL_ri_action_print (REFC.RDB$UPDATE_RULE, " On Update", false);
				}

				if (!REFC.RDB$DELETE_RULE.NULL)
				{
					IUTILS_truncate_term (REFC.RDB$DELETE_RULE, static_cast<USHORT>(strlen(REFC.RDB$DELETE_RULE)));
					ISQL_ri_action_print (REFC.RDB$DELETE_RULE, " On Delete", false);
				}

				isqlGlob.printf(NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR
		}

		if (isPK || isUK) // Special handling for PRIMARY KEY and UNIQUE constraints.
		{
			FOR IDX IN RDB$INDICES
			WITH IDX.RDB$SCHEMA_NAME EQUIV NULLIF(indexName1.schema.c_str(), '') AND
				 IDX.RDB$INDEX_NAME = indexName1.object.c_str()
			{
				// Yes, the same RDB$... naming convention is used for both domains and indices.
				const bool explicit_index =
					((isPK && !fb_utils::implicit_pk(IDX.RDB$INDEX_NAME)) ||
					(isUK && !fb_utils::implicit_domain(indexName1.object.c_str()))) &&
					constraintName != indexName1.object;
				const bool descending_index = !IDX.RDB$INDEX_TYPE.NULL && IDX.RDB$INDEX_TYPE == 1;
				if (explicit_index || descending_index)
				{
					isqlGlob.printf(" uses explicit %s index",
									descending_index ? "descending" : "ascending");
				}

				if (explicit_index)
					isqlGlob.printf(" %s", IUTILS_name_to_string(indexName1.object).c_str());

				isqlGlob.prints(NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR R_C IN RDB$RELATION_CONSTRAINTS CROSS
		C_C IN RDB$CHECK_CONSTRAINTS
		WITH R_C.RDB$SCHEMA_NAME EQUIV NULLIF(relationName.schema.c_str(), '') AND
			 R_C.RDB$RELATION_NAME EQ relationName.object.c_str() AND
			 R_C.RDB$CONSTRAINT_TYPE EQ 'NOT NULL' AND
			 R_C.RDB$SCHEMA_NAME EQUIV C_C.RDB$SCHEMA_NAME AND
			 R_C.RDB$CONSTRAINT_NAME EQ C_C.RDB$CONSTRAINT_NAME
	{
		if (!fb_utils::implicit_integrity(R_C.RDB$CONSTRAINT_NAME))
		{
			isqlGlob.printf(
				"CONSTRAINT %s:%s",
				IUTILS_name_to_string(R_C.RDB$CONSTRAINT_NAME).c_str(),
				NEWLINE);

			isqlGlob.printf(
				"  Not Null Column (%s)%s",
				IUTILS_name_to_string(C_C.RDB$TRIGGER_NAME).c_str(),
				NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	// Do check constraints

	show_check(relationName);

	// Do triggers

	show_trigger(relationName, false, false);

	// Do publications

	show_pub_table(relationName);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);

	return SKIP;
}


static processing_state show_trigger(const std::optional<QualifiedMetaString>& name,
	bool show_source, bool isTriggerName)
{
/**************************************
 *
 *	s h o w _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Show triggers in general or for the named object or trigger
 *
 **************************************/
	bool first = true;

	// Show all triggers
	if (!name)
	{
		bool has_dbtrig = false;

		if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_1)
		{
			FOR TRG IN RDB$TRIGGERS
				WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
					 TRG.RDB$RELATION_NAME MISSING
				SORTED BY TRG.RDB$SCHEMA_NAME, TRG.RDB$TRIGGER_NAME
			{
				const QualifiedMetaString triggerName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);

				if (!has_dbtrig)
					has_dbtrig = true;

				isqlGlob.printf("%s", IUTILS_name_to_string(triggerName).c_str());

				if (TRG.RDB$SYSTEM_FLAG == 1)
					isqlGlob.printf("; System");

				if (!(TRG.RDB$VALID_BLR.NULL || TRG.RDB$VALID_BLR))
					isqlGlob.printf("; Invalid");

				isqlGlob.printf("%s", NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		}

		FOR TRG IN RDB$TRIGGERS CROSS
			REL IN RDB$RELATIONS
			//WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			//NOT (ANY CHK IN RDB$CHECK_CONSTRAINTS WITH
			//	 TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME)
			WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
				 TRG.RDB$SCHEMA_NAME EQUIV REL.RDB$SCHEMA_NAME AND
				 TRG.RDB$RELATION_NAME = REL.RDB$RELATION_NAME
			SORTED BY TRG.RDB$SCHEMA_NAME, TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_NAME
		{
			if (first)
			{
				if (has_dbtrig)
					isqlGlob.printf("%s", NEWLINE);

				first = false;
			}

			const QualifiedMetaString triggerName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);

			isqlGlob.printf("%s", IUTILS_name_to_string(triggerName).c_str());

			if (!TRG.RDB$RELATION_NAME.NULL)
				isqlGlob.printf("; Table: %s", IUTILS_name_to_string(TRG.RDB$RELATION_NAME).c_str());

			if (TRG.RDB$SYSTEM_FLAG == 1)
				isqlGlob.printf("; System");

			if (!(TRG.RDB$VALID_BLR.NULL || TRG.RDB$VALID_BLR))
				isqlGlob.printf("; Invalid");

			isqlGlob.printf("%s", NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		if (first && !has_dbtrig)
			return OBJECT_NOT_FOUND;

		return (SKIP);
	}

	// Show triggers for the named object
	// and avoid check constraints
	MetaString triggerNameFilter, relationNameFilter;

	if (isTriggerName)
		triggerNameFilter = name->object;
	else
		relationNameFilter = name->object;

	FOR TRG IN RDB$TRIGGERS
		WITH (TRG.RDB$RELATION_NAME EQ relationNameFilter.c_str() OR TRG.RDB$TRIGGER_NAME EQ triggerNameFilter.c_str()) AND
			 (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TRG.RDB$SCHEMA_NAME, TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_TYPE,
				  TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$TRIGGER_NAME
	{
		const QualifiedMetaString triggerName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);

		if (name->schema.hasData() && name->schema != triggerName.schema)
			continue;

		if (first)
		{
			if (!TRG.RDB$RELATION_NAME.NULL)
			{
				const QualifiedMetaString relationName(TRG.RDB$RELATION_NAME, TRG.RDB$SCHEMA_NAME);

				isqlGlob.printf("%sTriggers on Table %s:%s", NEWLINE, IUTILS_name_to_string(relationName).c_str(), NEWLINE);
			}

			first = false;
		}

		const char* ss = TRG.RDB$SQL_SECURITY.NULL ? "" :
							(TRG.RDB$SQL_SECURITY ? ", SQL SECURITY DEFINER" : ", SQL SECURITY INVOKER");

		isqlGlob.printf(
			"%s, Sequence: %d, Type: %s, %s%s%s",
			(isTriggerName ?
				IUTILS_name_to_string(triggerName) :
				IUTILS_name_to_string(triggerName.object)
			).c_str(),
			TRG.RDB$TRIGGER_SEQUENCE,
			SHOW_trigger_action(TRG.RDB$TRIGGER_TYPE).c_str(),
			(TRG.RDB$TRIGGER_INACTIVE ? "Inactive" : "Active"),
			ss,
			NEWLINE);

		if (show_source)
		{
			if (!TRG.RDB$ENTRYPOINT.NULL)
			{
				fb_utils::exact_name(TRG.RDB$ENTRYPOINT);
				isqlGlob.printf("External name: %s%s", TRG.RDB$ENTRYPOINT, NEWLINE);
			}

			if (!TRG.RDB$ENGINE_NAME.NULL)
			{
				fb_utils::exact_name(TRG.RDB$ENGINE_NAME);
				isqlGlob.printf("Engine: %s%s", TRG.RDB$ENGINE_NAME, NEWLINE);
			}

			// Use print_blob to print the blob

			if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			{
				isqlGlob.printf("Trigger text:%s", NEWLINE);
				isqlGlob.printf("=============================================================================%s", NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);
				isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return OBJECT_NOT_FOUND;

	return SKIP;
}

static processing_state show_users12()
{
/**************************************
 *
 *	s h o w _ u s e r s 1 2
 *
 **************************************
 *
 * Functional description
 *	Show users logged in and/or defined for the database.
 *
 **************************************/

	string sql;
	sql.printf(
		"select "
		"case when coalesce(MON$USER, SEC$USER_NAME) = current_user then '#' "
			 "when SEC$USER_NAME is distinct from null then ' ' else '-' end, "
		"coalesce(MON$USER, SEC$USER_NAME), count(MON$USER) "
		"from %smon$attachments m full join %ssec$users u on m.MON$USER = u.SEC$USER_NAME "
		"where coalesce(MON$SYSTEM_FLAG, 0) = 0 "
		"group by MON$USER, SEC$USER_NAME order by coalesce(MON$USER, SEC$USER_NAME)",
		(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""),
		(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""));

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 3));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 0, SQL_TEXT);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 0, 1);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 1, SQL_VARYING);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 1, MAX_SQL_IDENTIFIER_SIZE);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 2, SQL_LONG);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<MAX_SQL_IDENTIFIER_SIZE + 32> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());

	char* mark = (char*) &outBuffer[outMetadata->getOffset(fbStatus, 0)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	vary* username = (vary*) &outBuffer[outMetadata->getOffset(fbStatus, 1)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	int* cnt = (int*) &outBuffer[outMetadata->getOffset(fbStatus, 2)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::IResultSet* rs = DB->openCursor(fbStatus, fbTrans, 0, sql.c_str(), isqlGlob.SQL_dialect,
		NULL, NULL, outMetadata, NULL, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	processing_state rc = OBJECT_NOT_FOUND;

	while (rs->fetchNext(fbStatus, outBuffer) == Firebird::IStatus::RESULT_OK)
	{
		if (rc == OBJECT_NOT_FOUND)
		{
			// First time in the loop, print title.
			TEXT msg[MSG_LENGTH]; // When messages can be translated.
			IUTILS_msg_get(USERS_IN_DB, msg);
			isqlGlob.printf("%s\n", msg);
			rc = SKIP; // We found at least one user.
		}

		isqlGlob.printf("%3d %c%.*s", *cnt, *mark, username->vary_length, username->vary_string);
		isqlGlob.printf("\n");
	}
	if (ISQL_errmsg (fbStatus))
		rc = ps_ERR;

	rs->release();

	return rc;
}

static processing_state show_users()
{
/**************************************
 *
 *	s h o w _ u s e r s
 *
 **************************************
 *
 * Functional description
 *	Show users logged in the database (not users defined for this database).
 *
 **************************************/

	if (isqlGlob.major_ods >= ODS_VERSION12)
		return show_users12();

	const UCHAR user_items[] =
	{
		isc_info_user_names,
		isc_info_end
	};

	TEXT msg[MSG_LENGTH]; // When messages can be translated.

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 1));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setType(fbStatus, 0, SQL_VARYING);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 0, MAX_SQL_IDENTIFIER_SIZE);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<MAX_SQL_IDENTIFIER_SIZE + 32> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());
	unsigned off = outMetadata->getOffset(fbStatus, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	vary* my_user = (vary*) &outBuffer[off];

	string getuser;
	getuser.printf(
		"select current_user from %srdb$database",
		(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""));
	DB->execute(fbStatus, fbTrans, 0, getuser.c_str(), isqlGlob.SQL_dialect,
		NULL, NULL, outMetadata, outBuffer);
	if (ISQL_errmsg (fbStatus))
		return OBJECT_NOT_FOUND;
	my_user->vary_string[my_user->vary_length] = 0; // Just for the debugger.

	UCHAR buffer[BUFFER_LENGTH512];
	DB->getInfo(fbStatus, sizeof(user_items), user_items, sizeof(buffer), buffer);
	if (ISQL_errmsg(fbStatus))
		return ps_ERR;

	processing_state rc = OBJECT_NOT_FOUND;

	for (Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		switch (p.getClumpTag())
		{
		case isc_info_user_names:
			{
				if (rc == OBJECT_NOT_FOUND)
				{
					// First time in the loop, print title.
					IUTILS_msg_get(USERS_IN_DB, msg);
					isqlGlob.printf("%s\n", msg);
					rc = SKIP; // We found at least one user.
				}

				unsigned len = p.getBytes()[0];
				fb_assert(len == p.getClumpLength() - 1);
				const UCHAR* uname = p.getBytes() + 1;
				// Let's mark all attachments with our same user with a # prefix.
				bool same(len == my_user->vary_length && !memcmp(my_user->vary_string, uname, len));
				isqlGlob.printf("%c %.*s", same ? '#' : ' ', len, uname);
				isqlGlob.printf("\n");
			}
			break;

		case isc_info_truncated:
			isqlGlob.printf("\n");

			IUTILS_msg_get(OUTPUT_TRUNCATED, msg);
			isqlGlob.printf("%s\n", msg);
			return rc; // If we got some items, we are (partially) successful.
		}
	}

	return rc;
}

static processing_state show_wireStats()
{
	if (!DB)
	{
		isqlGlob.printf("No database connection.\n");
		return SKIP;
	}

	IsqlWireStats stats(DB);
	if (!stats.print(true))
		return ps_ERR;

	return SKIP;
}
