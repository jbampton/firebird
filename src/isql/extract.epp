/*
 *	PROGRAM:	Interactive SQL utility
 *	MODULE:		extract.epp
 *	DESCRIPTION:	Definition extract routines
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Revision 1.3  2000/11/22 17:07:25  patrickgriffin
 * In get_procedure_args change comment style from // to c style
 *
 * ...pat
 *
 * 2001.09.09 Claudio Valderrama: procedure's parameter names may need
 *   double quotes if they are in dialect 3 and have special characters.
 * 2001.09.21 Claudio Valderrama: Show correct mechanism for UDF parameters
 *   and support the RETURNS PARAMETER <n> syntax.
 *
 * Revision 1.2  2000/11/18 16:49:24  fsg
 * Increased PRINT_BUFFER_LENGTH to 2048 to show larger plans
 * Fixed Bug #122563 in extract.e get_procedure_args
 * Apparently this has to be done in show.e also,
 * but that is for another day :-)
 *
 * 2003.02.04 Dmitry Yemanov: support for universal triggers
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>				// isdigit
#include <map>
#include "../common/classes/MetaString.h"
#include "../common/classes/QualifiedMetaString.h"
#include "../jrd/constants.h"
#include "ibase.h"
#include "../yvalve/gds_proto.h"
#include "../common/intlobj_new.h"
#include "../isql/isql.h"
#include "../isql/extra_proto.h"
#include "../isql/isql_proto.h"
#include "../isql/show_proto.h"
#include "../isql/iutils_proto.h"
#include "../jrd/ini.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../common/utils_proto.h"
#include "../jrd/constants.h"

using namespace Firebird;
using MsgFormat::SafeArg;


//DATABASE DB = EXTERN COMPILETIME "yachts.lnk";
DATABASE DB = EXTERN COMPILETIME "yachts.lnk" RUNTIME isqlGlob.global_Db_name;

static bool extract_rel_constraints(const QualifiedMetaString& relation_name);
static void get_procedure_args(const QualifiedMetaString& proc_name,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void get_function_args_ods12(const QualifiedMetaString& func_name, USHORT,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static processing_state list_all_grants(bool, const SCHAR*);
static void list_all_tables(LegacyTables flag, GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_all_triggers();
static void list_check();
static void list_charsets();
static void list_collations();
static void list_create_db();
static void list_domain_table(const QualifiedMetaString&,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_domains(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void listDomainConstraints();
static void listRelationComputed(LegacyTables flag, GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_exceptions();
static void list_filters();
static void list_foreign();
static void list_functions_ods12_headers(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_functions_ods12_bodies(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_functions_legacy();
static void list_generators();
static void list_indexes();
static void list_package_bodies();
static void list_package_headers();
static void list_procedure_bodies(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_procedure_headers(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc);
static void list_schemas();
static void list_views();

static const char* const Procterm = "^";	// TXNN: script use only

static TEXT SQL_identifier[BUFFER_LENGTH256];
static TEXT SQL_identifier2[BUFFER_XLARGE]; // should be >= 1026 bytes (exception text + two quotes)



int EXTRACT_ddl(LegacyTables flag, const QualifiedMetaString& tabname)
{
/**************************************
 *
 *	E X T R A C T _ d d l
 *
 **************************************
 *
 * Functional description
 *	Extract all sql information
 *	0 flag means SQL only tables. 1 flag means all tables
 *
 **************************************/
	bool did_attach = false;

	if (!DB)
	{
		DB = fbProvider->attachDatabase(fbStatus, isqlGlob.global_Db_name, 0, NULL);
		if (ISQL_errmsg(fbStatus))
			return FINI_ERROR;
		did_attach = true;

		// Make it read owner name to display grantor correctly
		SHOW_read_owner();
	}

	ISQL_get_version(false);
	if (isqlGlob.SQL_dialect != isqlGlob.db_SQL_dialect)
	{
		isqlGlob.printf("/*=========================================================*/%s", NEWLINE);
		isqlGlob.printf("/*=                                                      ==*/%s", NEWLINE);
		isqlGlob.printf("/*=     Command Line -sqldialect %d is overwritten by    ==*/%s",
				isqlGlob.SQL_dialect, NEWLINE);
		isqlGlob.printf("/*=     Database SQL Dialect %d.                          ==*/%s",
				isqlGlob.db_SQL_dialect, NEWLINE);
		isqlGlob.printf("/*=                                                      ==*/%s", NEWLINE);
		isqlGlob.printf("/*=========================================================*/%s", NEWLINE);
	}
	isqlGlob.printf(NEWLINE);

	isqlGlob.printf("SET SQL DIALECT %d; %s", isqlGlob.db_SQL_dialect, NEWLINE);

	isqlGlob.printf(NEWLINE);

	bool did_start = false;
	if (!fbTrans)
	{
		fbTrans = DB->startTransaction(fbStatus, 0, NULL);
		if (ISQL_errmsg(fbStatus))
			return FINI_ERROR;
		did_start = true;
	}

	const SSHORT default_char_set_id = ISQL_get_default_char_set_id();
	std::map<MetaString, SSHORT> defaultSchemaCharSetMap;

	const auto getDefaultCharSetForSchema = [&](const MetaString& schemaName) -> SSHORT
	{
		if (schemaName.hasData())
		{
			if (const auto it = defaultSchemaCharSetMap.find(schemaName); it != defaultSchemaCharSetMap.end())
				return it->second;
			else if (isqlGlob.major_ods >= ODS_VERSION14)
			{
				FOR SCH IN RDB$SCHEMAS
					CROSS CHR IN RDB$CHARACTER_SETS
					WITH SCH.RDB$SCHEMA_NAME EQ schemaName.c_str() AND
						 CHR.RDB$SCHEMA_NAME EQ SCH.RDB$CHARACTER_SET_SCHEMA_NAME AND
						 CHR.RDB$CHARACTER_SET_NAME EQ SCH.RDB$CHARACTER_SET_NAME
				{
					return defaultSchemaCharSetMap[schemaName] = CHR.RDB$CHARACTER_SET_ID;
				}
				END_FOR
			}
		}

		return default_char_set_id;
	};

	int ret_code = FINI_OK;

	// If a table name was passed, extract only that table and domains
	if (tabname.object.hasData())
	{
		if (EXTRACT_list_table(tabname, {}, true, getDefaultCharSetForSchema))
		{
			SCHAR errbuf[MSG_LENGTH];
			IUTILS_msg_get(NOT_FOUND, errbuf, SafeArg() << IUTILS_name_to_string(tabname).c_str());
			STDERROUT(errbuf);
			ret_code = FINI_ERROR;
		}
	}
	else
	{
		list_create_db();
		list_filters();
		list_schemas();
		list_charsets();
		list_collations();
		list_generators();
		list_domains(getDefaultCharSetForSchema);
		list_all_tables(flag, getDefaultCharSetForSchema);
		list_functions_legacy();
		list_functions_ods12_headers(getDefaultCharSetForSchema);
		list_procedure_headers(getDefaultCharSetForSchema);
		list_package_headers();
		list_indexes();
		list_foreign();
		list_views();
		list_exceptions();
		list_functions_ods12_bodies(getDefaultCharSetForSchema);
		list_procedure_bodies(getDefaultCharSetForSchema);
		list_package_bodies();
		listDomainConstraints();
		list_check();
		listRelationComputed(flag, getDefaultCharSetForSchema);
		list_all_triggers();
		list_all_grants(true, isqlGlob.global_Term);
		SHOW_maps(true, std::nullopt);
		SHOW_comments(false); // Let's make this an option later.
	}

	if (fbTrans && did_start)
	{
		fbTrans->commit(fbStatus);
		if (ISQL_errmsg(fbStatus))
			return FINI_ERROR;
		fbTrans = NULL;
	}

	if (DB && did_attach)
	{
		DB->detach(fbStatus);
		if (ISQL_errmsg(fbStatus))
			return FINI_ERROR;
		DB = NULL;
	}

	return ret_code;
}


processing_state EXTRACT_list_grants(const SCHAR* terminator)
{
/**************************************
 *
 *	E X T R A C T _ l i s t _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Print the permissions on all user tables, views and procedures.
 *
 **************************************/
	return list_all_grants(false, terminator);
}


int EXTRACT_list_table(const QualifiedMetaString& relation_name,
						  const QualifiedMetaString& new_name,
						  bool domain_flag,
						  GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	E X T R A C T _ l i s t _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	Shows columns, types, info for a given table name
 *	and text of views.
 *	Use a GDML query to get the info and print it.
 *	If a new_name is passed, substitute it for relation_name
 *
 *	relation_name -- Name of table to investigate
 *	new_name -- Name of a new name for a replacement table
 *	domain_flag -- extract needed domains before the table
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
/**************************************
 *	default_char_set_id warrants special
 *	consideration.  If the metadata for a
 *	table is being extracted when there is
 *	really no need to redundantly and repeatedly
 *	list the databases default character set
 *	for every field.
 *
 *	At the same time there is a need to list
 *	the character set NONE when it is not
 *	the default character set for the database.
 *
 *	EXCEPT!  If the metadata is being extracted
 *	with the intention of coping that tables structure
 *	into another database, and it is not possible
 *	to know the default character set for the
 *	target database, then list every fields
 *	character set.  This includes the character
 *	set NONE.
 *
 *	Fields with no character set definition will
 *	not have any character set listed.
 *
 *	Use -1 as the default_char_set_id
 *	in this case.
 *
 *	POTENTIAL TRAP!  Consider the following:
 *	When copying a table from one database
 *	to another how should fields using the
 *	default character set be handled?
 *
 *	If both databases have the same default
 *	character set, then there is no problem
 *	or confusion.
 *
 *	If the databases have different default
 *	character sets then should fields using
 *	the default is the source database use
 *	the default of the target database?
 *
 **************************************/

	bool first = true;
	string char_sets;
	rel_t rel_type = rel_persistent;
	char ss[28] = "";

	// Query to obtain relation detail information

	FOR REL IN RDB$RELATIONS CROSS
		RFR IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS
		WITH RFR.RDB$SCHEMA_NAME EQUIV REL.RDB$SCHEMA_NAME AND
			 RFR.RDB$RELATION_NAME EQ REL.RDB$RELATION_NAME AND
			 FLD.RDB$SCHEMA_NAME EQUIV RFR.RDB$FIELD_SOURCE_SCHEMA_NAME AND
			 FLD.RDB$FIELD_NAME EQ RFR.RDB$FIELD_SOURCE AND
			 REL.RDB$SCHEMA_NAME EQUIV NULLIF(relation_name.schema.c_str(), '') AND
			 REL.RDB$RELATION_NAME EQ relation_name.object.c_str()
		SORTED BY RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME
	{
		if (!REL.RDB$RELATION_TYPE.NULL)
			rel_type = (rel_t) REL.RDB$RELATION_TYPE;

		const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

		SSHORT collation = 0;
		SSHORT char_set_id = 0;

		if (first)
		{
			first = false;
			// Do we need to print domains
			if (domain_flag)
				list_domain_table(relation_name, getDefaultCharSetForSchemaFunc);

			const MetaString ownerName(REL.RDB$OWNER_NAME);

			isqlGlob.printf("%s/* Table: %s, Owner: %s */%s",
					 NEWLINE,
					 IUTILS_name_to_string(relation_name).c_str(),
					 IUTILS_name_to_string(ownerName).c_str(),
					 NEWLINE);

			if (rel_type == rel_global_temp_preserve || rel_type == rel_global_temp_delete)
				isqlGlob.printf("CREATE GLOBAL TEMPORARY TABLE ");
			else
				isqlGlob.printf("CREATE TABLE ");

			isqlGlob.printf("%s ", IUTILS_name_to_string(new_name.object.hasData() ? new_name : relation_name).c_str());

			if (!REL.RDB$SQL_SECURITY.NULL)
			{
				if (REL.RDB$SQL_SECURITY)
					strcpy(ss, "SQL SECURITY DEFINER");
				else
					strcpy(ss, "SQL SECURITY INVOKER");
			}

			if (!REL.RDB$EXTERNAL_FILE.NULL)
			{
				IUTILS_copy_SQL_id (REL.RDB$EXTERNAL_FILE, SQL_identifier2, SINGLE_QUOTE);
				isqlGlob.printf("EXTERNAL FILE %s ", SQL_identifier2);
			}

			isqlGlob.printf("(");
		}
		else
			isqlGlob.printf(",%s%s", NEWLINE, TAB_AS_SPACES);

		const MetaString columnName(RFR.RDB$FIELD_NAME);
		isqlGlob.printf("%s ", IUTILS_name_to_string(columnName).c_str());

		/*
		** If this is a known domain, then just print the domain rather than type
		** Domains won't have length, array, or blob definitions, but they
		** may have not null, default and check overriding their definitions
		*/

		if (!(fb_utils::implicit_domain(fieldName.object.c_str()) && FLD.RDB$SYSTEM_FLAG != 1))
		{
			isqlGlob.prints(IUTILS_name_to_string(fieldName).c_str());

			// International character sets
			// Print only the character set
			if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				!RFR.RDB$COLLATION_ID.NULL)
			{
				// There is no need to print character set for domain at all because it cannot be overriden.
				// Collation will be printed later.
				collation = RFR.RDB$COLLATION_ID;
				char_set_id = FLD.RDB$CHARACTER_SET_ID;
			}
		}
		else
		{
			if (!ISQL_printNumericType(fieldName, FLD.RDB$FIELD_TYPE,
					FLD.RDB$FIELD_SUB_TYPE, FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return FINI_ERROR;
			}

			if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
			{
				isqlGlob.printf("(%d)",
					ISQL_get_char_length(
						FLD.RDB$FIELD_LENGTH,
						FLD.RDB$CHARACTER_LENGTH.NULL, FLD.RDB$CHARACTER_LENGTH,
						FLD.RDB$CHARACTER_SET_ID.NULL, FLD.RDB$CHARACTER_SET_ID
					)
				);
			}

			// Catch arrays after printing the type

			if (!FLD.RDB$DIMENSIONS.NULL)
				ISQL_array_dimensions(fieldName);

			if (FLD.RDB$FIELD_TYPE == blr_blob)
			{
				const int subtype = FLD.RDB$FIELD_SUB_TYPE;
				isqlGlob.printf(" SUB_TYPE ");

				if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
					isqlGlob.prints(Sub_types[subtype]);
				else
					isqlGlob.printf("%d", subtype);

				isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) FLD.RDB$SEGMENT_LENGTH);
			}

			// International character sets
			if ((((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				  FLD.RDB$FIELD_SUB_TYPE == fb_text_subtype_text) ||
				 FLD.RDB$FIELD_TYPE == blr_blob) &&
				!FLD.RDB$CHARACTER_SET_ID.NULL)
			{
				// Override rdb$fields id with relation_fields if present

				if (!RFR.RDB$COLLATION_ID.NULL)
					collation = RFR.RDB$COLLATION_ID;
				else if (!FLD.RDB$COLLATION_ID.NULL)
					collation = FLD.RDB$COLLATION_ID;

				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					char_set_id = FLD.RDB$CHARACTER_SET_ID;

				ISQL_get_character_sets(char_set_id, collation, getDefaultCharSetForSchemaFunc(relation_name.schema),
					Get::CHARSET_ONLY, false, char_sets);

				if (char_sets.hasData())
					isqlGlob.prints(char_sets.c_str());

				// CVC: Someone deleted the code that checks intchar when handling collations
				// several lines below, so it didn't have any effect. Commented it.
				//if (!char_set_id)
				//	intchar = true;
			}
		}

		// Check for computed fields
		if (!FLD.RDB$COMPUTED_BLR.NULL)
		{
			isqlGlob.printf(" COMPUTED BY ");

			if (domain_flag)
			{
				if (!FLD.RDB$COMPUTED_SOURCE.NULL)
					ISQL_print_validation (isqlGlob.Out, &FLD.RDB$COMPUTED_SOURCE, true, fbTrans);
			}
			else if (!RFR.RDB$COLLATION_ID.NULL)
			{
				string collate_name;

				ISQL_get_character_sets(char_set_id, collation, getDefaultCharSetForSchemaFunc(relation_name.schema),
					Get::COLLATE_ONLY, false, collate_name);

				if (collate_name.hasData())
				{
					isqlGlob.printf("(CAST(NULL AS VARCHAR(1)%s)", char_sets.c_str());
					isqlGlob.printf("%s)", collate_name.c_str());
				}
				else
					isqlGlob.printf("(NULL)");

				collation = 0;
			}
			else
				isqlGlob.printf("(NULL)");
		}

		// Handle defaults for columns

		if (!RFR.RDB$DEFAULT_SOURCE.NULL)
		{
			isqlGlob.printf(" ");
			SHOW_print_metadata_text_blob(isqlGlob.Out, &RFR.RDB$DEFAULT_SOURCE, false, true);
		}

		if (!RFR.RDB$GENERATOR_NAME.NULL)
		{
			FOR GEN IN RDB$GENERATORS
				WITH GEN.RDB$SCHEMA_NAME EQUIV NULLIF(RFR.RDB$SCHEMA_NAME, '') AND
					 GEN.RDB$GENERATOR_NAME = RFR.RDB$GENERATOR_NAME
			{
				isqlGlob.printf(" GENERATED %s AS IDENTITY",
					(RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_BY_DEFAULT ? "BY DEFAULT" :
					 RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_ALWAYS ? "ALWAYS" : ""));

				const bool printInitial = !GEN.RDB$INITIAL_VALUE.NULL && GEN.RDB$INITIAL_VALUE != 0;
				const bool printIncrement = !GEN.RDB$GENERATOR_INCREMENT.NULL && GEN.RDB$GENERATOR_INCREMENT != 1;

				if (printInitial || printIncrement)
				{
					isqlGlob.printf(" (");

					if (printInitial)
					{
						isqlGlob.printf("START WITH %" SQUADFORMAT "%s",
							GEN.RDB$INITIAL_VALUE, (printIncrement ? " " : ""));
					}

					if (printIncrement)
						isqlGlob.printf("INCREMENT %" SLONGFORMAT, GEN.RDB$GENERATOR_INCREMENT);

					isqlGlob.printf(")");
				}
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		}

		/* The null flag is either 1 or null (for nullable) .  if there is
		**  a constraint name, print that too.  Domains cannot have named
		**  constraints.  The column name is in rdb$trigger_name in
		**  rdb$check_constraints.  We hope we get at most one row back.
		*/

		if (RFR.RDB$NULL_FLAG == 1)
		{
			FOR RCO IN RDB$RELATION_CONSTRAINTS CROSS
				CON IN RDB$CHECK_CONSTRAINTS
				WITH CON.RDB$SCHEMA_NAME EQUIV NULLIF(RFR.RDB$SCHEMA_NAME, '') AND
					 CON.RDB$TRIGGER_NAME = RFR.RDB$FIELD_NAME AND
					 CON.RDB$CONSTRAINT_NAME = RCO.RDB$CONSTRAINT_NAME AND
					 RCO.RDB$CONSTRAINT_TYPE EQ "NOT NULL" AND
					 RCO.RDB$SCHEMA_NAME EQUIV CON.RDB$SCHEMA_NAME AND
					 RCO.RDB$RELATION_NAME = RFR.RDB$RELATION_NAME
			{
				if (!fb_utils::implicit_integrity(CON.RDB$CONSTRAINT_NAME))
				{
					const MetaString constraintName(CON.RDB$CONSTRAINT_NAME);
					isqlGlob.printf(" CONSTRAINT %s", IUTILS_name_to_string(constraintName).c_str());
				}
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return FINI_ERROR;
			END_ERROR

			isqlGlob.printf(" NOT NULL");
		}

		// Handle collations after defaults

		if (!RFR.RDB$COLLATION_ID.NULL)
		{
			ISQL_get_character_sets(char_set_id, collation, getDefaultCharSetForSchemaFunc(relation_name.schema),
				Get::COLLATE_ONLY, false, char_sets);

			if (char_sets.hasData())
				isqlGlob.prints(char_sets.c_str());
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return FINI_ERROR;
	END_ERROR

	// Do primary and unique keys only. References come later.
	if (!extract_rel_constraints(relation_name))
		return FINI_ERROR;

	// Check constaints are now deferred

	if (first) // we extracted nothing
		return FINI_ERROR;

	const char* gtt_scope = (rel_type == rel_global_temp_preserve) ? "ON COMMIT PRESERVE ROWS" :
							((rel_type == rel_global_temp_delete) ? "ON COMMIT DELETE ROWS" : "");

	const char* opt_delim = *gtt_scope && *ss ? ", " : "";

	if (*gtt_scope || *ss)
		isqlGlob.printf(")%s%s%s%s", NEWLINE, gtt_scope, opt_delim , ss);
	else
		isqlGlob.printf(")");

	isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	return FINI_OK;
}


static bool extract_rel_constraints(const QualifiedMetaString& relation_name)
{
/**************************************************
 *
 *	e x t r a c t _ r e l _ c o n s t r a i n t s
 *
 **************************************************
 *
 * Functional description
 *	This function extracts the relation constraints of type PK and UK.
 *
 **************************************/

	SCHAR collist[BUFFER_LENGTH512 * 2];

	// PK and UK are always based on indices for now, hence this join is safe.
	FOR RELC IN RDB$RELATION_CONSTRAINTS
		CROSS IDX IN RDB$INDICES
		WITH (RELC.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY" OR
			  RELC.RDB$CONSTRAINT_TYPE EQ "UNIQUE") AND
			 RELC.RDB$SCHEMA_NAME EQUIV NULLIF(relation_name.schema.c_str(), '') AND
			 RELC.RDB$RELATION_NAME EQ relation_name.object.c_str() AND
			 IDX.RDB$SCHEMA_NAME EQUIV RELC.RDB$SCHEMA_NAME AND
			 IDX.RDB$INDEX_NAME EQ RELC.RDB$INDEX_NAME
		SORTED BY RELC.RDB$CONSTRAINT_TYPE, RELC.RDB$CONSTRAINT_NAME
	{
		const QualifiedMetaString indexName(IDX.RDB$INDEX_NAME, IDX.RDB$SCHEMA_NAME);
		const MetaString constraintName(RELC.RDB$CONSTRAINT_NAME);

		isqlGlob.printf(",%s", NEWLINE);

		// If the name of the constraint is not INTEG_..., print it
 		if (!fb_utils::implicit_integrity(constraintName.c_str()))
			isqlGlob.printf("CONSTRAINT %s ", IUTILS_name_to_string(constraintName).c_str());

		ISQL_get_index_segments(collist, sizeof(collist), indexName);

		const bool isPK = !strncmp (RELC.RDB$CONSTRAINT_TYPE, "PRIMARY", 7);
		if (isPK)
			isqlGlob.printf("PRIMARY KEY (%s)", collist);
		else //if (!strncmp (RELC.RDB$CONSTRAINT_TYPE, "UNIQUE", 6)) // redundant
			isqlGlob.printf("UNIQUE (%s)", collist);

		// Yes, the same RDB$... naming convention is used for both domains and indices.
		const bool explicit_index = ((isPK && !fb_utils::implicit_pk(IDX.RDB$INDEX_NAME)) ||
			(!isPK && !fb_utils::implicit_domain(indexName.object.c_str()))) &&
		    constraintName != indexName.object;
		const bool descending_index = !IDX.RDB$INDEX_TYPE.NULL && IDX.RDB$INDEX_TYPE == 1;
		if (explicit_index || descending_index)
		{
			isqlGlob.printf(
				" USING %sINDEX %s",
				(descending_index ? "DESCENDING " : ""),
				IUTILS_name_to_string(indexName.object).c_str());
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return false;
	END_ERROR

	return true;
}


static void get_procedure_args(const QualifiedMetaString& proc_name,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	g e t _ p r o c e d u r e _ a r g s
 *
 **************************************
 *
 * Functional description
 *	This function extracts the procedure parameters and adds it to the
 *	extract file.
 *  Make sure to pass here only the names of procedures that are global.
 *
 **************************************/
	string char_sets;

	// query to retrieve the parameters.


	// placed the two identical code blocks into one
	// for loop as suggested by Ann H. and Claudio V.
	// FSG 18.Nov.2000

	//  Parameter types 0 = input
	//  Parameter types 1 = return

	for (SSHORT ptype = 0; ptype < 2; ptype++)
	{
		bool first_time = true;

		FOR PRM IN RDB$PROCEDURE_PARAMETERS CROSS
			FLD IN RDB$FIELDS
			WITH FLD.RDB$SCHEMA_NAME EQUIV PRM.RDB$FIELD_SOURCE_SCHEMA_NAME AND
				 FLD.RDB$FIELD_NAME EQ PRM.RDB$FIELD_SOURCE AND
				 PRM.RDB$SCHEMA_NAME EQUIV NULLIF(proc_name.schema.c_str(), '') AND
				 PRM.RDB$PROCEDURE_NAME = proc_name.object.c_str() AND
				 PRM.RDB$PARAMETER_TYPE = ptype AND
				 PRM.RDB$PACKAGE_NAME MISSING
			SORTED BY PRM.RDB$PARAMETER_NUMBER
		{
			bool prm_collation_id_null = PRM.RDB$COLLATION_ID.NULL;
			SSHORT prm_collation_id = PRM.RDB$COLLATION_ID;

			bool prm_default_source_null = PRM.RDB$DEFAULT_SOURCE.NULL;
			ISC_QUAD prm_default_source = PRM.RDB$DEFAULT_SOURCE;

			bool prm_null_flag_null = PRM.RDB$NULL_FLAG.NULL;
			bool prm_null_flag = PRM.RDB$NULL_FLAG;

			prm_mech_t prm_mech = prm_mech_normal;

			if (!PRM.RDB$PARAMETER_MECHANISM.NULL)
				prm_mech = (prm_mech_t) PRM.RDB$PARAMETER_MECHANISM;

			QualifiedMetaString relationName(PRM.RDB$RELATION_NAME, PRM.RDB$RELATION_SCHEMA_NAME);
			MetaString relationField(PRM.RDB$FIELD_NAME);

			if (first_time)
			{
				first_time = false;
				if (ptype == 0)
				{
					// this is the input part
					isqlGlob.printf("(");
				}
				else
				{
					// we are in the output part
					isqlGlob.printf("RETURNS (");
				}
			}
			else
				isqlGlob.printf(",%s", NEWLINE);

			const MetaString parameterName(PRM.RDB$PARAMETER_NAME);
			const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

			isqlGlob.printf("%s ", IUTILS_name_to_string(parameterName).c_str());

			const bool basedOnColumn = relationName.object.hasData() && relationField.hasData();
			if (!fb_utils::implicit_domain(fieldName.object.c_str()) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				if (prm_mech == prm_mech_type_of)
					isqlGlob.printf("TYPE OF ");

				if (basedOnColumn)
				{
					isqlGlob.printf(
						"COLUMN %s.%s",
						IUTILS_name_to_string(relationName).c_str(),
						IUTILS_name_to_string(relationField).c_str());
				}
				else
					isqlGlob.prints(IUTILS_name_to_string(fieldName).c_str());

				// International character sets
				// Print only the collation
				if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
					!prm_collation_id_null)
				{
					ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, prm_collation_id,
						getDefaultCharSetForSchemaFunc(proc_name.schema),
						Get::COLLATE_ONLY, !prm_null_flag_null && prm_null_flag, char_sets);

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (ptype == 0) // input, try to extract default and make Vlad happy.
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source, false, true);
					}
				}
			}
			else
			{
				if (!ISQL_printNumericType(fieldName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
						FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
				{
					return; // ps_ERR;
				}

				// Changed this to return RDB$CHARACTER_LENGTH if available
				// Fix for Bug #122563
				//   FSG 18.Nov.2000
				if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
				{
					isqlGlob.printf("(%d)",
						ISQL_get_char_length(
							FLD.RDB$FIELD_LENGTH,
							FLD.RDB$CHARACTER_LENGTH.NULL, FLD.RDB$CHARACTER_LENGTH,
							FLD.RDB$CHARACTER_SET_ID.NULL, FLD.RDB$CHARACTER_SET_ID
						)
					);
				}

				// Show international character sets and collations
				if ((!FLD.RDB$COLLATION_ID.NULL || !FLD.RDB$CHARACTER_SET_ID.NULL) &&
					!(((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) &&
					  FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_text))
				{
					SSHORT collation = 0;

					if (!prm_collation_id_null)
						collation = prm_collation_id;
					else if (!FLD.RDB$COLLATION_ID.NULL)
						collation = FLD.RDB$COLLATION_ID;

					if (FLD.RDB$CHARACTER_SET_ID.NULL)
						FLD.RDB$CHARACTER_SET_ID = 0;

					ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, collation,
						getDefaultCharSetForSchemaFunc(proc_name.schema),
						Get::BOTH, !prm_null_flag_null && prm_null_flag, char_sets);

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (ptype == 0) // input, try to extract default and make Vlad happy.
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source, false, true);
					}
					else if (!FLD.RDB$DEFAULT_SOURCE.NULL)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE, false, true);
					}
				}
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR

		// If there was at least one param, close parens

		if (!first_time)
			isqlGlob.printf(")%s", NEWLINE);
	}						// end for ptype
}


static void get_function_args_ods12(const QualifiedMetaString& func_name, USHORT out_arg,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	g e t _ f u n c t i o n _ a r g s _ o d s 1 2
 *
 **************************************
 *
 * Functional description
 *	This function extracts the function parameters and adds it to the
 *	extract file.
 *  Make sure to pass here only the names of functions that are global.
 *
 **************************************/
	string char_sets;

	// Pass 0 - inputs, pass 1 - return value

	for (int pass = 0; pass < 2; pass++)
	{
		bool first_time = true;

		FOR ARG IN RDB$FUNCTION_ARGUMENTS CROSS
			FLD IN RDB$FIELDS
			WITH FLD.RDB$SCHEMA_NAME EQUIV ARG.RDB$FIELD_SOURCE_SCHEMA_NAME AND
				 FLD.RDB$FIELD_NAME EQ ARG.RDB$FIELD_SOURCE AND
				 ARG.RDB$SCHEMA_NAME EQUIV NULLIF(func_name.schema.c_str(), '') AND
				 ARG.RDB$FUNCTION_NAME = func_name.object.c_str() AND
				 ARG.RDB$PACKAGE_NAME MISSING
			SORTED BY ARG.RDB$ARGUMENT_POSITION
		{
			if ((pass == 0 && ARG.RDB$ARGUMENT_POSITION == out_arg) ||
				(pass != 0 && ARG.RDB$ARGUMENT_POSITION != out_arg))
			{
				continue;
			}

			bool prm_collation_id_null = ARG.RDB$COLLATION_ID.NULL;
			SSHORT prm_collation_id = ARG.RDB$COLLATION_ID;

			bool prm_default_source_null = ARG.RDB$DEFAULT_SOURCE.NULL;
			ISC_QUAD prm_default_source = ARG.RDB$DEFAULT_SOURCE;

			bool prm_null_flag_null = ARG.RDB$NULL_FLAG.NULL;
			bool prm_null_flag = ARG.RDB$NULL_FLAG;

			prm_mech_t prm_mech = prm_mech_normal;

			if (!ARG.RDB$ARGUMENT_MECHANISM.NULL)
				prm_mech = (prm_mech_t) ARG.RDB$ARGUMENT_MECHANISM;

			const QualifiedMetaString relationName(ARG.RDB$RELATION_NAME, ARG.RDB$RELATION_SCHEMA_NAME);
			const MetaString relationField(ARG.RDB$FIELD_NAME);
			const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

			if (first_time)
			{
				first_time = false;
				if (pass == 0)
				{
					// this is the input part
					isqlGlob.printf("(");
				}
				else
				{
					// we are in the output part
					isqlGlob.printf("RETURNS ");
				}
			}
			else
				isqlGlob.printf(",%s", NEWLINE);

			if (pass == 0)
			{
				const MetaString argumentName(ARG.RDB$ARGUMENT_NAME);
				isqlGlob.printf("%s ", IUTILS_name_to_string(argumentName).c_str());
			}

			const bool basedOnColumn = relationName.object.hasData() && relationField.hasData();
			if (!fb_utils::implicit_domain(fieldName.object.c_str()) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				if (prm_mech == prm_mech_type_of)
					isqlGlob.printf("TYPE OF ");

				if (basedOnColumn)
				{
					isqlGlob.printf(
						"COLUMN %s.%s",
						IUTILS_name_to_string(relationName).c_str(),
						IUTILS_name_to_string(relationField).c_str());
				}
				else
					isqlGlob.prints(IUTILS_name_to_string(fieldName).c_str());

				// International character sets
				// Print only the collation
				if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
					!prm_collation_id_null)
				{
					ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, prm_collation_id,
						getDefaultCharSetForSchemaFunc(func_name.schema),
						Get::COLLATE_ONLY, !prm_null_flag_null && prm_null_flag, char_sets);

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (pass == 0) // input, try to extract default and make Vlad happy.
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source, false, true);
					}
				}
			}
			else
			{
				if (!ISQL_printNumericType(fieldName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
						FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
				{
					return; // ps_ERR;
				}

				// Changed this to return RDB$CHARACTER_LENGTH if available
				// Fix for Bug #122563
				//   FSG 18.Nov.2000
				if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
				{
					isqlGlob.printf("(%d)",
						ISQL_get_char_length(
							FLD.RDB$FIELD_LENGTH,
							FLD.RDB$CHARACTER_LENGTH.NULL, FLD.RDB$CHARACTER_LENGTH,
							FLD.RDB$CHARACTER_SET_ID.NULL, FLD.RDB$CHARACTER_SET_ID
						)
					);
				}

				// Show international character sets and collations
				if ((!FLD.RDB$COLLATION_ID.NULL || !FLD.RDB$CHARACTER_SET_ID.NULL) &&
					!(((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) &&
					  FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_text))
				{
					SSHORT collation = 0;

					if (!prm_collation_id_null)
						collation = prm_collation_id;
					else if (!FLD.RDB$COLLATION_ID.NULL)
						collation = FLD.RDB$COLLATION_ID;

					if (FLD.RDB$CHARACTER_SET_ID.NULL)
						FLD.RDB$CHARACTER_SET_ID = 0;

					ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, collation,
						getDefaultCharSetForSchemaFunc(func_name.schema), Get::BOTH,
						!prm_null_flag_null && prm_null_flag, char_sets);

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
				}
				else if (!prm_null_flag_null && prm_null_flag)
					isqlGlob.printf(" NOT NULL");

				if (pass == 0) // input, try to extract default
				{
					if (!prm_default_source_null)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source, false, true);
					}
					else if (!FLD.RDB$DEFAULT_SOURCE.NULL)
					{
						isqlGlob.printf(" ");
						SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE, false, true);
					}
				}
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR

		// If there was at least one param, close parens

		if (!first_time)
		{
			if (pass == 0)
				isqlGlob.printf(")%s", NEWLINE);
			else
				isqlGlob.printf("%s", NEWLINE);
		}
	}						// end for ptype
}


static processing_state list_all_grants(bool extract, const SCHAR* terminator)
{
/**************************************
 *
 *	l i s t _ a l l _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Print the permissions on all user tables.
 *
 *	Get separate permissions on table/views and then procedures.
 *
 **************************************/
	bool first_role = true;
	MetaString prev_owner;

	// Process GRANT roles
	if (isqlGlob.major_ods >= ODS_VERSION9 && extract)
	{
		prev_owner[0] = '\0';

		FOR XX IN RDB$ROLES
			SORTED BY XX.RDB$ROLE_NAME
		{
			bool system_flag = !XX.RDB$SYSTEM_FLAG.NULL && XX.RDB$SYSTEM_FLAG > 0;

			if (!system_flag)
			{
				const MetaString roleName(XX.RDB$ROLE_NAME);
				const MetaString ownerName(XX.RDB$OWNER_NAME);

				if (first_role)
				{
					isqlGlob.printf("%s/* Grant roles for this database */%s", NEWLINE, NEWLINE);
					first_role = false;
				}

				if (ownerName != prev_owner)
				{
					isqlGlob.printf("%s/* Role: %s, Owner: %s */%s",
							 NEWLINE,
							 IUTILS_name_to_string(roleName).c_str(),
							 IUTILS_name_to_string(ownerName).c_str(),
							 NEWLINE);
					prev_owner = ownerName;
				}

				isqlGlob.printf("CREATE ROLE %s", IUTILS_name_to_string(roleName).c_str());

				SHOW_system_privileges(XX.RDB$ROLE_NAME, " SET SYSTEM PRIVILEGES TO", false);
				isqlGlob.printf(";%s", NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
		    return OBJECT_NOT_FOUND;
		END_ERROR
	}

	// This version of cursor gets only sql tables identified by security class
	// and misses views, getting only null view_source

	char banner[100];
	fb_utils::snprintf(banner, sizeof(banner), "%s/* Grant permissions for this database */%s", NEWLINE, NEWLINE);

	bool first = true;

	FOR REL IN RDB$RELATIONS
		WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			  REL.RDB$SECURITY_CLASS STARTING "SQL$"
		SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_NAME
	{
		const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

		const processing_state rc =
			SHOW_grants(relationName, terminator, obj_relation, (first ? banner : nullptr));

		if (rc == SKIP)
			first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return OBJECT_NOT_FOUND;
	END_ERROR

	if (first)
		SHOW_grant_roles(terminator, &first, banner);
	else
		SHOW_grant_roles(terminator, nullptr, nullptr);

	// For stored procedures, but ignore procedures inside packages.
	FOR PRC IN RDB$PROCEDURES
		WITH (PRC.RDB$SYSTEM_FLAG NE 1 OR PRC.RDB$SYSTEM_FLAG MISSING) AND
			 PRC.RDB$PACKAGE_NAME MISSING
		SORTED BY PRC.RDB$SCHEMA_NAME, PRC.RDB$PROCEDURE_NAME
	{
		const QualifiedMetaString procedureName(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

		const processing_state rc =
			SHOW_grants(procedureName, terminator, obj_procedure, (first ? banner : nullptr));

		if (rc == SKIP)
			first = false;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return OBJECT_NOT_FOUND;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR PACK IN RDB$PACKAGES
			WITH (PACK.RDB$SYSTEM_FLAG NE 1 OR PACK.RDB$SYSTEM_FLAG MISSING)
			SORTED BY PACK.RDB$SCHEMA_NAME, PACK.RDB$PACKAGE_NAME
		{
			const QualifiedMetaString packageName(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);

			const processing_state rc =
				SHOW_grants(packageName, terminator, obj_package_header, (first ? banner : nullptr));

			if (rc == SKIP)
				first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return OBJECT_NOT_FOUND;
		END_ERROR

		FOR FUN IN RDB$FUNCTIONS
			WITH (FUN.RDB$SYSTEM_FLAG NE 1 OR FUN.RDB$SYSTEM_FLAG MISSING) AND
				 FUN.RDB$PACKAGE_NAME MISSING
			SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$FUNCTION_NAME
		{
			const QualifiedMetaString functionName(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

			const processing_state rc =
				SHOW_grants(functionName, terminator, obj_udf, (first ? banner : nullptr));

			if (rc == SKIP)
				first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return OBJECT_NOT_FOUND;
		END_ERROR

		FOR GEN IN RDB$GENERATORS
			WITH (GEN.RDB$SYSTEM_FLAG NE 1 OR GEN.RDB$SYSTEM_FLAG MISSING)
			SORTED BY GEN.RDB$SCHEMA_NAME, GEN.RDB$GENERATOR_NAME
		{
			const QualifiedMetaString generatorName(GEN.RDB$GENERATOR_NAME, GEN.RDB$SCHEMA_NAME);

			const processing_state rc =
				SHOW_grants(generatorName, terminator, obj_generator, (first ? banner : nullptr));

			if (rc == SKIP)
				first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return OBJECT_NOT_FOUND;
		END_ERROR

		FOR XCP IN RDB$EXCEPTIONS
			WITH (XCP.RDB$SYSTEM_FLAG NE 1 OR XCP.RDB$SYSTEM_FLAG MISSING)
			SORTED BY XCP.RDB$SCHEMA_NAME, XCP.RDB$EXCEPTION_NAME
		{
			const QualifiedMetaString exceptionName(XCP.RDB$EXCEPTION_NAME, XCP.RDB$SCHEMA_NAME);

			const processing_state rc =
				SHOW_grants(exceptionName, terminator, obj_exception, (first ? banner : nullptr));

			if (rc == SKIP)
				first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return OBJECT_NOT_FOUND;
		END_ERROR

		if (isqlGlob.major_ods >= ODS_VERSION14)
		{
			FOR SCH IN RDB$SCHEMAS
				WITH SCH.RDB$SYSTEM_FLAG NE 1 OR SCH.RDB$SYSTEM_FLAG MISSING
				SORTED BY SCH.RDB$SCHEMA_NAME
			{
				const QualifiedMetaString schemaName(SCH.RDB$SCHEMA_NAME);

				const processing_state rc = SHOW_grants(schemaName, terminator, obj_schema, (first ? banner : nullptr));

				if (rc == SKIP)
					first = false;
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return OBJECT_NOT_FOUND;
			END_ERROR
		}

		if (SHOW_ddl_grants(std::nullopt, terminator, obj_any, (first ? banner : 0)) == SKIP)
			first = false;
	}

	return first_role && first ? OBJECT_NOT_FOUND : SKIP;
}


static void print_proc_prefix(int obj_type, bool headerOnly)
{
	if (obj_type == obj_procedure || obj_type == obj_udf ||
		obj_type == obj_package_header || obj_type == obj_package_body)
	{
		isqlGlob.printf("%sCOMMIT WORK%s%s", NEWLINE, isqlGlob.global_Term, NEWLINE);
	}

	if (obj_type != obj_trigger)
		isqlGlob.printf("SET AUTODDL OFF%s%s", isqlGlob.global_Term, NEWLINE);

	isqlGlob.printf("SET TERM %s %s%s", Procterm, isqlGlob.global_Term, NEWLINE);

	const char* legend = NULL;
	switch (obj_type)
	{
	case obj_procedure:
		legend = headerOnly ? "Stored procedures headers" : "Stored procedures bodies";
		break;
	case obj_udf:
		legend = headerOnly ? "Stored functions headers" : "Stored functions bodies";
		break;
	case obj_trigger:
		legend = "Triggers only will work for SQL triggers";
		break;
	case obj_package_header:
		legend = "Package headers";
		break;
	case obj_package_body:
		legend = "Package bodies";
		break;
	}
	if (legend)
		isqlGlob.printf("%s/* %s */%s", NEWLINE, legend, NEWLINE);
}


static void print_proc_suffix(int obj_type)
{
	isqlGlob.printf("%sSET TERM %s %s%s", NEWLINE, isqlGlob.global_Term, Procterm, NEWLINE);
	isqlGlob.printf("COMMIT WORK%s%s", isqlGlob.global_Term, NEWLINE);

	if (obj_type != obj_trigger)
		isqlGlob.printf("SET AUTODDL ON%s%s", isqlGlob.global_Term, NEWLINE);
}

static void list_procedure_headers(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	l i s t _ p r o c e d u r e _ h e a d e r s
 *
 **************************************
 *
 * Functional description
 * Create all procedure declarations
 * with empty body. This will allow us to create objects
 * that depend on them. The alteration to their
 * correct form is postponed to list_procedure_bodies.
 * Add the parameter names when these procedures are created.
 *
 **************************************/

	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool header = true;
	static const char* const create_procedure	= "CREATE OR ALTER PROCEDURE %s ";
	static const char* const body_execut_proc	= "BEGIN EXIT; END %s%s";
	static const char* const body_select_proc	= "BEGIN SUSPEND; END %s%s";

	//  First the dummy procedures
	// create the procedures with their parameters

	FOR PRC IN RDB$PROCEDURES
		WITH (PRC.RDB$SYSTEM_FLAG NE 1 OR PRC.RDB$SYSTEM_FLAG MISSING) AND
			 PRC.RDB$PACKAGE_NAME MISSING
		SORTED BY PRC.RDB$SCHEMA_NAME, PRC.RDB$PROCEDURE_NAME
	{
		const QualifiedMetaString name(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

		if (header)
		{
			print_proc_prefix(obj_procedure, true);
			header = false;
		}

		isqlGlob.printf(create_procedure, IUTILS_name_to_string(name).c_str());

		get_procedure_args(name, getDefaultCharSetForSchemaFunc);

		isqlGlob.printf("AS %s", NEWLINE);

		prc_t proc_type = PRC.RDB$PROCEDURE_TYPE.NULL ? prc_legacy : (prc_t) PRC.RDB$PROCEDURE_TYPE;

		// We'll assume for safety that prc_legacy can be mapped to prc_selectable.
		if (proc_type == prc_executable)
			isqlGlob.printf(body_execut_proc, Procterm, NEWLINE);
		else
			isqlGlob.printf(body_select_proc, Procterm, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// Only reset the terminators if there were procs to print
	if (!header)
		print_proc_suffix(obj_procedure);
}



static void list_procedure_bodies(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	l i s t _  p r o c e d u r e _ b o d i e s
 *
 **************************************
 *
 * Functional description
 *	Fill them with life
 *
 **************************************/

	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool header = true;

	// This query gets the procedure name and the source.  We then nest a query
	// to retrieve the parameters. Alter is used, because the procedures are already there
	TEXT msg[MSG_LENGTH];

	FOR PRC IN RDB$PROCEDURES
		WITH (PRC.RDB$SYSTEM_FLAG NE 1 OR PRC.RDB$SYSTEM_FLAG MISSING) AND
			 PRC.RDB$PACKAGE_NAME MISSING
		SORTED BY PRC.RDB$SCHEMA_NAME, PRC.RDB$PROCEDURE_NAME
	{
		const QualifiedMetaString name(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

		if (header)
		{
			print_proc_prefix(obj_procedure, false);
			header = false;
		}

		isqlGlob.printf("%sALTER PROCEDURE %s ", NEWLINE, IUTILS_name_to_string(name).c_str());

		get_procedure_args(name, getDefaultCharSetForSchemaFunc);

		// Print the procedure body

		if (!PRC.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENTRYPOINT);
			IUTILS_copy_SQL_id(PRC.RDB$ENTRYPOINT, SQL_identifier2, SINGLE_QUOTE);
			isqlGlob.printf("EXTERNAL NAME %s%s", SQL_identifier2, NEWLINE);
		}

		if (!PRC.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = PRC.RDB$SQL_SECURITY ? "SQL SECURITY DEFINER" : "SQL SECURITY INVOKER";
			isqlGlob.printf("%s%s", ss, NEWLINE);
		}

		if (!PRC.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENGINE_NAME);
			isqlGlob.printf("ENGINE %s", PRC.RDB$ENGINE_NAME);

			if (!PRC.RDB$PROCEDURE_SOURCE.NULL)
			{
				isqlGlob.printf("%sAS '", NEWLINE);
				SHOW_print_metadata_text_blob(isqlGlob.Out, &PRC.RDB$PROCEDURE_SOURCE, true);
				isqlGlob.printf("'%s", NEWLINE);
			}
		}
		else if (!PRC.RDB$PROCEDURE_SOURCE.NULL)
		{
			isqlGlob.printf("AS %s", NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &PRC.RDB$PROCEDURE_SOURCE);
		}

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
	}
	END_FOR
	ON_ERROR
		IUTILS_msg_get(GEN_ERR, msg, SafeArg() << isc_sqlcode(fbStatus->getErrors()));
		STDERROUT(msg);			// Statement failed, SQLCODE = %d\n\n
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// Only reset the terminators if there were procs to print
	if (!header)
		print_proc_suffix(obj_procedure);
}



static void list_all_tables(LegacyTables flag, GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	l i s t _ a l l _ t a b l e s
 *
 **************************************
 *
 * Functional description
 *	Extract the names of all user tables from
 *	rdb$relations.  Filter SQL tables by
 *	security class after we fetch them
 *	Parameters:  flag -- 0, get all tables
 *
 **************************************/

	// This version of cursor gets only sql tables identified by security class
	// and misses views, getting only null view_source

	FOR REL IN RDB$RELATIONS
		WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			 REL.RDB$VIEW_BLR MISSING
		SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_NAME
	{
		// If this is not an SQL table and we aren't doing ALL objects
		if ((REL.RDB$FLAGS.NULL || !(REL.RDB$FLAGS & REL_sql)) && (flag != ALL_objects) )
			continue;

		const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

		if (flag || !strncmp (REL.RDB$SECURITY_CLASS, "SQL$", 4))
			EXTRACT_list_table(relationName, {}, false, getDefaultCharSetForSchemaFunc);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		ROLLBACK;
		return;
	END_ERROR
}


static void list_all_triggers()
{
/**************************************
 *
 *	l i s t _ a l l _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 *	Lists triggers in general on non-system
 *	tables with sql source only.
 *
 **************************************/
	bool header = true;

	// Query gets the trigger info for non-system triggers with
	// source that are not part of an SQL constraint.

	FOR TRG IN RDB$TRIGGERS
		WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
			 TRG.RDB$RELATION_NAME MISSING
		SORTED BY TRG.RDB$TRIGGER_TYPE, TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$SCHEMA_NAME, TRG.RDB$TRIGGER_NAME
	{
		if (header)
		{
			print_proc_prefix(obj_trigger, false);
			header = false;
		}

		const QualifiedMetaString name(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);

		if (TRG.RDB$TRIGGER_INACTIVE.NULL)
			TRG.RDB$TRIGGER_INACTIVE = 0;

		//  If trigger is not SQL put it in comments
		if (!(TRG.RDB$FLAGS & TRG_sql))
			isqlGlob.printf("/* ");

		isqlGlob.printf("CREATE TRIGGER %s %s%s %s POSITION %d %s",
				 IUTILS_name_to_string(name).c_str(),
				 NEWLINE,
				 (TRG.RDB$TRIGGER_INACTIVE ? "INACTIVE" : "ACTIVE"),
				 SHOW_trigger_action(TRG.RDB$TRIGGER_TYPE).c_str(), TRG.RDB$TRIGGER_SEQUENCE,
				 NEWLINE);

		if (!TRG.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = TRG.RDB$SQL_SECURITY ? "SQL SECURITY DEFINER" : "SQL SECURITY INVOKER";
			isqlGlob.printf("%s%s", ss, NEWLINE);
		}

		if (!TRG.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(TRG.RDB$ENTRYPOINT);
			IUTILS_copy_SQL_id(TRG.RDB$ENTRYPOINT, SQL_identifier2, SINGLE_QUOTE);
			isqlGlob.printf("EXTERNAL NAME %s%s", SQL_identifier2, NEWLINE);
		}

		if (!TRG.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(TRG.RDB$ENGINE_NAME);
			isqlGlob.printf("ENGINE %s", TRG.RDB$ENGINE_NAME);

			if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			{
				isqlGlob.printf("%sAS '", NEWLINE);
				SHOW_print_metadata_text_blob(isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE, true);
				isqlGlob.printf("'%s", NEWLINE);
			}
		}
		else if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			SHOW_print_metadata_text_blob(isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
		isqlGlob.printf(NEWLINE);

		if (!(TRG.RDB$FLAGS & TRG_sql))
		{
			isqlGlob.printf("*/%s", NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	FOR TRG IN RDB$TRIGGERS CROSS
		REL IN RDB$RELATIONS
		//WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
		//NOT (ANY CHK IN RDB$CHECK_CONSTRAINTS WITH
		//TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME)
		WITH REL.RDB$SCHEMA_NAME EQUIV TRG.RDB$SCHEMA_NAME AND
			 REL.RDB$RELATION_NAME EQ TRG.RDB$RELATION_NAME AND
			 (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TRG.RDB$SCHEMA_NAME, TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_TYPE,
				  TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$TRIGGER_NAME
	{
		if (header)
		{
			isqlGlob.printf("SET TERM %s %s%s", Procterm, isqlGlob.global_Term, NEWLINE);
			isqlGlob.printf("%s/* Triggers only will work for SQL triggers */%s",
					 NEWLINE,
					 NEWLINE);
			header = false;
		}

		const QualifiedMetaString name(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);
		const MetaString relationName(TRG.RDB$RELATION_NAME);

		if (TRG.RDB$TRIGGER_INACTIVE.NULL)
			TRG.RDB$TRIGGER_INACTIVE = 0;

		//  If trigger is not SQL put it in comments
		if (!(TRG.RDB$FLAGS & TRG_sql))
			isqlGlob.printf("/* ");

		isqlGlob.printf("CREATE TRIGGER %s FOR %s %s%s %s POSITION %d %s",
				 IUTILS_name_to_string(name).c_str(),
				 IUTILS_name_to_string(relationName).c_str(),
				 NEWLINE,
				 (TRG.RDB$TRIGGER_INACTIVE ? "INACTIVE" : "ACTIVE"),
				 SHOW_trigger_action(TRG.RDB$TRIGGER_TYPE).c_str(), TRG.RDB$TRIGGER_SEQUENCE,
				 NEWLINE);

		if (!TRG.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = TRG.RDB$SQL_SECURITY ? "SQL SECURITY DEFINER" : "SQL SECURITY INVOKER";
			isqlGlob.printf("%s%s", ss, NEWLINE);
		}

		if (!TRG.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(TRG.RDB$ENTRYPOINT);
			IUTILS_copy_SQL_id(TRG.RDB$ENTRYPOINT, SQL_identifier2, SINGLE_QUOTE);
			isqlGlob.printf("EXTERNAL NAME %s%s", SQL_identifier2, NEWLINE);
		}

		if (!TRG.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(TRG.RDB$ENGINE_NAME);
			isqlGlob.printf("ENGINE %s", TRG.RDB$ENGINE_NAME);

			if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			{
				isqlGlob.printf("%sAS '", NEWLINE);
				SHOW_print_metadata_text_blob(isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE, true);
				isqlGlob.printf("'%s", NEWLINE);
			}
		}
		else if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			SHOW_print_metadata_text_blob(isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
		isqlGlob.printf(NEWLINE);

		if (!(TRG.RDB$FLAGS & TRG_sql))
		{
			isqlGlob.printf("*/%s", NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (!header)
		print_proc_suffix(obj_trigger);
}


static void list_check()
{
/**************************************
 *
 *	l i s t _ c h e c k
 *
 **************************************
 *
 * Functional description
 *	List check constraints for all objects to allow forward references
 *
 **************************************/

	// Query gets the check clauses for triggers stored for check constraints

	bool first = true;

	FOR TRG IN RDB$TRIGGERS CROSS
		CHK IN RDB$CHECK_CONSTRAINTS
		WITH TRG.RDB$TRIGGER_TYPE EQ 1 AND
			 TRG.RDB$SYSTEM_FLAG EQ int(fb_sysflag_check_constraint) AND
			 TRG.RDB$SCHEMA_NAME EQUIV CHK.RDB$SCHEMA_NAME AND
			 TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME AND
			 (ANY RELC IN RDB$RELATION_CONSTRAINTS
			 	WITH CHK.RDB$SCHEMA_NAME EQUIV RELC.RDB$SCHEMA_NAME AND
			 		 CHK.RDB$CONSTRAINT_NAME EQ RELC.RDB$CONSTRAINT_NAME AND
			 		 RELC.RDB$CONSTRAINT_TYPE EQ "CHECK")
		REDUCED TO CHK.RDB$SCHEMA_NAME, CHK.RDB$CONSTRAINT_NAME
		SORTED BY CHK.RDB$SCHEMA_NAME, CHK.RDB$CONSTRAINT_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/* Table constraints */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString relationName(TRG.RDB$RELATION_NAME, TRG.RDB$SCHEMA_NAME);

		isqlGlob.printf(NEWLINE);

		isqlGlob.printf("ALTER TABLE %s ADD %s%s", IUTILS_name_to_string(relationName).c_str(), NEWLINE, TAB_AS_SPACES);

		// If the name of the constraint is not INTEG_..., print it
		if (!fb_utils::implicit_integrity(CHK.RDB$CONSTRAINT_NAME))
		{
			const MetaString constraintName(CHK.RDB$CONSTRAINT_NAME);
			isqlGlob.printf("CONSTRAINT %s ", IUTILS_name_to_string(constraintName).c_str());
		}

		if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_charsets()
{
/**************************************
 *
 *	l i s t _ c h a r s e t s
 *
 **************************************
 *
 * Functional description
 *	Alter character sets.
 *
 **************************************/

	bool first = true;

	FOR CS IN RDB$CHARACTER_SETS
		WITH NOT (
				CS.RDB$SCHEMA_NAME EQUIV CS.RDB$DEFAULT_COLLATE_SCHEMA_NAME AND
				CS.RDB$CHARACTER_SET_NAME EQ CS.RDB$DEFAULT_COLLATE_NAME)
		SORTED BY CS.RDB$SCHEMA_NAME, CS.RDB$CHARACTER_SET_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/*  Character sets */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);
		const QualifiedMetaString defaultCollateName(
			CS.RDB$DEFAULT_COLLATE_NAME, CS.RDB$DEFAULT_COLLATE_SCHEMA_NAME);

		isqlGlob.printf(
			"ALTER CHARACTER SET %s SET DEFAULT COLLATION %s",
			IUTILS_name_to_string(name).c_str(),
			IUTILS_name_to_string(defaultCollateName).c_str());

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (! first)
		isqlGlob.printf(NEWLINE);
}


static void list_collations()
{
/**************************************
 *
 *	l i s t _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Re create all non-system collations
 *
 **************************************/

	if (isqlGlob.major_ods < ODS_VERSION11)
		return;

	bool first = true;

	FOR CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS
		WITH CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID AND
			 (CL.RDB$SYSTEM_FLAG MISSING OR CL.RDB$SYSTEM_FLAG NE 1)
		SORTED BY CS.RDB$SCHEMA_NAME, CS.RDB$CHARACTER_SET_NAME, CL.RDB$SCHEMA_NAME, CL.RDB$COLLATION_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/*  Collations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(CL.RDB$COLLATION_NAME, CL.RDB$SCHEMA_NAME);
		const QualifiedMetaString charSetName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);

		isqlGlob.printf(
			"CREATE COLLATION %s FOR %s",
			IUTILS_name_to_string(name).c_str(),
			IUTILS_name_to_string(charSetName).c_str());

		if (!CL.RDB$BASE_COLLATION_NAME.NULL)
		{
			fb_utils::exact_name(CL.RDB$BASE_COLLATION_NAME);
			IUTILS_copy_SQL_id (CL.RDB$BASE_COLLATION_NAME, SQL_identifier, SINGLE_QUOTE);
			isqlGlob.printf(" FROM EXTERNAL (%s)", SQL_identifier);
		}

		if (!CL.RDB$COLLATION_ATTRIBUTES.NULL)
		{
			if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_PAD_SPACE)
				isqlGlob.printf(" PAD SPACE");

			if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_CASE_INSENSITIVE)
				isqlGlob.printf(" CASE INSENSITIVE");

			if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_ACCENT_INSENSITIVE)
				isqlGlob.printf(" ACCENT INSENSITIVE");
		}

		if (!CL.RDB$SPECIFIC_ATTRIBUTES.NULL)
		{
			isqlGlob.printf(" '");
			SHOW_print_metadata_text_blob (isqlGlob.Out, &CL.RDB$SPECIFIC_ATTRIBUTES);
			isqlGlob.printf("'");
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	isqlGlob.printf(NEWLINE);
}


static void list_create_db()
{
/**************************************
 *
 *	l i s t _ c r e a t e _ d b
 *
 **************************************
 *
 * Functional description
 *	Print the create database command if requested.  At least put
 *	the page size in a comment with the extracted db name
 *
 **************************************/
	static const UCHAR page_items[] =
	{
		isc_info_page_size,
		isc_info_end
	};

	// Comment out the create database if no db param was specified
	bool nodb = false;
	if (!*isqlGlob.global_Target_db)
	{
		isqlGlob.printf("/* ");
		strcpy(isqlGlob.global_Target_db, isqlGlob.global_Db_name);
		nodb = true;
	}
	isqlGlob.printf("CREATE DATABASE '%s' ", isqlGlob.global_Target_db);

	// Get the page size from db_info call
	// CVC: Finally I got the idea: translate is associated with WISQL that
	// no longer exists. Localizing the messages means also not printing
	// any CRLF and therefore the output looks ugly.
	const bool translate = true;
	SHOW_dbb_parameters(DB, page_items, sizeof(page_items), translate, " ");

	FOR DBP IN RDB$DATABASE
		WITH DBP.RDB$CHARACTER_SET_NAME NOT MISSING AND
			 DBP.RDB$CHARACTER_SET_NAME != " "
	{
		const QualifiedMetaString charSetName(
			DBP.RDB$CHARACTER_SET_NAME, DBP.RDB$CHARACTER_SET_SCHEMA_NAME);

		isqlGlob.printf("DEFAULT CHARACTER SET %s%s",
			IUTILS_name_to_string(charSetName).c_str(),
			isqlGlob.global_Term);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	FOR DBP2 IN RDB$DATABASE
		WITH DBP2.RDB$LINGER NOT MISSING AND
			 DBP2.RDB$LINGER > 0
	{
		isqlGlob.printf("%sALTER DATABASE SET LINGER TO %d%s", NEWLINE, DBP2.RDB$LINGER,
			isqlGlob.global_Term);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	FOR DBPSS IN RDB$DATABASE
		WITH DBPSS.RDB$SQL_SECURITY NOT MISSING AND
			 DBPSS.RDB$SQL_SECURITY == FB_TRUE
	{
		isqlGlob.printf("%sALTER DATABASE SET DEFAULT SQL SECURITY DEFINER%s", NEWLINE, isqlGlob.global_Term);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (nodb)
		isqlGlob.printf(" */%s", NEWLINE);
	else
		isqlGlob.printf("%s", NEWLINE);

	// List secondary files and shadows as alter db and create shadow in comment

	bool first = true;

	FOR FIL IN RDB$FILES
		SORTED BY FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_SEQUENCE
	{
		// reset nulls to zero
		if (FIL.RDB$FILE_FLAGS.NULL)
			FIL.RDB$FILE_FLAGS = 0;
		if (FIL.RDB$FILE_LENGTH.NULL)
			FIL.RDB$FILE_LENGTH = 0;
		if (FIL.RDB$FILE_SEQUENCE.NULL)
			FIL.RDB$FILE_SEQUENCE = 0;
		if (FIL.RDB$FILE_START.NULL)
			FIL.RDB$FILE_START = 0;
		if (!FIL.RDB$FILE_NAME.NULL)
			fb_utils::exact_name(FIL.RDB$FILE_NAME);

		// Pure secondary files
		if (FIL.RDB$FILE_FLAGS == 0)
		{
			if (first)
			{
				isqlGlob.printf("%s/* Add secondary files in comments %s", NEWLINE, NEWLINE);
				first = false;
			}

			isqlGlob.printf("%sALTER DATABASE ADD FILE '%s'", NEWLINE, FIL.RDB$FILE_NAME);
			if (FIL.RDB$FILE_START)
			{
				isqlGlob.printf(" STARTING %ld", FIL.RDB$FILE_START);
			}
			if (FIL.RDB$FILE_LENGTH)
			{
				isqlGlob.printf(" LENGTH %ld", FIL.RDB$FILE_LENGTH);
			}
			isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
		}
		else if (FIL.RDB$FILE_FLAGS & FILE_shadow)
		{
			if (first)
			{
				isqlGlob.printf("%s/* Add secondary files in comments %s", NEWLINE, NEWLINE);
				first = false;
			}

			if (FIL.RDB$FILE_SEQUENCE)
			{
				isqlGlob.printf("%sFILE '%s' ", TAB_AS_SPACES, FIL.RDB$FILE_NAME);
			}
			else
			{
				isqlGlob.printf("%sCREATE SHADOW %d '%s' ",
						 NEWLINE,
						 FIL.RDB$SHADOW_NUMBER,
						 FIL.RDB$FILE_NAME);
				if (FIL.RDB$FILE_FLAGS & FILE_inactive)
					isqlGlob.printf("INACTIVE ");
				if (FIL.RDB$FILE_FLAGS & FILE_manual)
					isqlGlob.printf("MANUAL ");
				else
					isqlGlob.printf("AUTO ");
				if (FIL.RDB$FILE_FLAGS & FILE_conditional)
					isqlGlob.printf("CONDITIONAL ");
			}
			if (FIL.RDB$FILE_LENGTH)
			{
				isqlGlob.printf("LENGTH %ld ", FIL.RDB$FILE_LENGTH);
			}
			if (FIL.RDB$FILE_START)
			{
				isqlGlob.printf("STARTING %ld ", FIL.RDB$FILE_START);
			}
			isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
		}
		else if ((FIL.RDB$FILE_FLAGS & FILE_difference) && !FIL.RDB$FILE_NAME.NULL)
		{
			if (first)
			{
				isqlGlob.printf("%s/* Add secondary files in comments %s", NEWLINE, NEWLINE);
				first = false;
			}

			// This is an explicit name for the difference file typically named <db_name>.delta
			isqlGlob.printf("%sALTER DATABASE ADD DIFFERENCE FILE '%s'", NEWLINE, FIL.RDB$FILE_NAME);
			isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (!first)
	{
		isqlGlob.printf("%s */%s", NEWLINE, NEWLINE);
		//isqlGlob.printf("%s%s%s", isqlGlob.global_Term, NEWLINE, NEWLINE);
	}
}


static void list_domain_table(const QualifiedMetaString& table_name,
	GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	l i s t _ d o m a i n _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	List domains as identified by fields with any constraints on them
 *	for the named table
 *
 *	Parameters:  table_name == only extract domains for this table
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
	bool first = true;
	string char_sets;

	FOR FLD IN RDB$FIELDS CROSS
		RFR IN RDB$RELATION_FIELDS
		WITH RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
			 RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
			 RFR.RDB$SCHEMA_NAME EQUIV NULLIF(table_name.schema.c_str(), '') AND
			 RFR.RDB$RELATION_NAME EQ table_name.object.c_str()
		SORTED BY FLD.RDB$SCHEMA_NAME, FLD.RDB$FIELD_NAME
	{
		// Skip over artificial domains
		if (fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) &&
			(FLD.RDB$SYSTEM_FLAG.NULL || FLD.RDB$SYSTEM_FLAG != 1))
		{
			continue;
		}

		if (first)
		{
			isqlGlob.printf("/* Domain definitions */%s", NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

		isqlGlob.printf("CREATE DOMAIN %s AS ", IUTILS_name_to_string(name).c_str());

		if (!ISQL_printNumericType(name, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
				FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
		{
			return; // ps_ERR;
		}

		if (FLD.RDB$FIELD_TYPE == blr_blob)
		{
			const int subtype = FLD.RDB$FIELD_SUB_TYPE;
			isqlGlob.printf(" SUB_TYPE ");
			if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}
			isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) FLD.RDB$SEGMENT_LENGTH);
		}
		else if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
		{
			// Length for chars
			isqlGlob.printf("(%d)", ISQL_get_field_length(name));
		}

		if (!FLD.RDB$DIMENSIONS.NULL)
			ISQL_array_dimensions(name);

		// Bug 8261: do not show the collation information just yet!  If you
		// do, then the domain syntax when printed is not correct.

		// Since the character set is part of the field type, display that information now.
		if (!FLD.RDB$CHARACTER_SET_ID.NULL &&
			!(((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) &&
			  FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_text))
		{
			ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, FLD.RDB$COLLATION_ID,
				getDefaultCharSetForSchemaFunc(name.schema),
				Get::CHARSET_ONLY, false, char_sets);

			if (char_sets.hasData())
				isqlGlob.prints(char_sets.c_str());
		}

		if (!FLD.RDB$DEFAULT_SOURCE.NULL)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE, false, true);
		}
		if (!FLD.RDB$VALIDATION_SOURCE.NULL)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			ISQL_print_validation (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE, false, fbTrans);
		}
		if (FLD.RDB$NULL_FLAG == 1)
			isqlGlob.printf(" NOT NULL");

		// Bug 8261:  Now show the collation order information
		/* Show the collation order if one has been specified.  If the collation
		   order is the default for the character set being used, then no collation
		   order will be shown ( because it isn't needed ).

		Even if the collation id is 0, it may be non-default for the character set.*/

		if (!FLD.RDB$COLLATION_ID.NULL)
		{
			ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, FLD.RDB$COLLATION_ID,
				getDefaultCharSetForSchemaFunc(name.schema),
				Get::COLLATE_ONLY, false, char_sets);

			if (char_sets.hasData())
				isqlGlob.prints(char_sets.c_str());
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_domains(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
/**************************************
 *
 *	l i s t _ d o m a i n s
 *
 **************************************
 *
 * Functional description
 *	List domains
 *
 *	Parameters:
 *	default_char_set_id -- character set def to supress
 *
 **************************************/
	bool first = true;
	string char_sets;

	FOR FLD IN RDB$FIELDS
		WITH FLD.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
			 FLD.RDB$SYSTEM_FLAG NE 1
		SORTED BY FLD.RDB$SCHEMA_NAME, FLD.RDB$FIELD_NAME
	{
		if (first)
		{
			isqlGlob.printf("/* Domain definitions */%s", NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

		isqlGlob.printf("CREATE DOMAIN %s AS ", IUTILS_name_to_string(name).c_str());

		if (!ISQL_printNumericType(name, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
				FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
		{
			return; // ps_ERR;
		}

		if (FLD.RDB$FIELD_TYPE == blr_blob)
		{
			const int subtype = FLD.RDB$FIELD_SUB_TYPE;
			isqlGlob.printf(" SUB_TYPE ");

			if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}
			isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) FLD.RDB$SEGMENT_LENGTH);
		}
		else if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
		{
			// Length for chars
			isqlGlob.printf("(%d)", ISQL_get_field_length(name));
		}

		if (!FLD.RDB$DIMENSIONS.NULL)
			ISQL_array_dimensions(name);

		// Bug 8261: do not show the collation information just yet!  If you
		// do, then the domain syntax when printed is not correct.

		// Since the character set is part of the field type, display that information now.
		if (!FLD.RDB$CHARACTER_SET_ID.NULL &&
			!(((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) &&
			  FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_text))
		{
			ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, FLD.RDB$COLLATION_ID,
				getDefaultCharSetForSchemaFunc(name.schema),
				Get::CHARSET_ONLY, false, char_sets);

			if (char_sets.hasData())
				isqlGlob.prints(char_sets.c_str());
		}

		if (!FLD.RDB$DEFAULT_SOURCE.NULL)
		{
			isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE, false, true);
		}
		// Validation moved to listDomainConstraints().
		if (FLD.RDB$NULL_FLAG == 1)
			isqlGlob.printf(" NOT NULL");

		// Bug 8261:  Now show the collation order information
		/* Show the collation order if one has been specified.  If the collation
		   order is the default for the character set being used, then no collation
		   order will be shown ( because it isn't needed

		   Even if the collation id is 0, it may be non-default for the character.*/

		if (!FLD.RDB$COLLATION_ID.NULL)
		{
			ISQL_get_character_sets(FLD.RDB$CHARACTER_SET_ID, FLD.RDB$COLLATION_ID,
				getDefaultCharSetForSchemaFunc(name.schema),
				Get::COLLATE_ONLY, false, char_sets);

			if (char_sets.hasData())
				isqlGlob.prints(char_sets.c_str());
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
    ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	isqlGlob.printf("COMMIT WORK%s%s", isqlGlob.global_Term, NEWLINE);
}


static void listDomainConstraints()
{
	bool first = true;

	FOR FLD IN RDB$FIELDS
		WITH FLD.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
			 FLD.RDB$SYSTEM_FLAG NE 1 AND
			 FLD.RDB$VALIDATION_SOURCE NOT MISSING
		SORTED BY FLD.RDB$SCHEMA_NAME, FLD.RDB$FIELD_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/* Domain constraints */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

		isqlGlob.printf("ALTER DOMAIN %s ADD CONSTRAINT", IUTILS_name_to_string(name).c_str());

		isqlGlob.printf("%s%s ", NEWLINE, TAB_AS_SPACES);
		ISQL_print_validation (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE, false, fbTrans);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


// Fix computed field expressions.
static void listRelationComputed(LegacyTables flag, GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
	// This version of cursor gets only sql tables identified by security class
	// and misses views, getting only null view_source

	QualifiedMetaString lastRelation;
	string char_sets;

	FOR REL IN RDB$RELATIONS CROSS
		RFR IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS
		WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			 REL.RDB$VIEW_BLR MISSING AND
			 FLD.RDB$COMPUTED_BLR NOT MISSING AND
			 RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
			 RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
			 RFR.RDB$SCHEMA_NAME EQUIV REL.RDB$SCHEMA_NAME AND
			 RFR.RDB$RELATION_NAME EQ REL.RDB$RELATION_NAME
		SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_NAME, RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME
	{
		// If this is not an SQL table and we aren't doing ALL objects
		if ((REL.RDB$FLAGS.NULL || !(REL.RDB$FLAGS & REL_sql)) && (flag != ALL_objects) )
			continue;

		SSHORT collation = 0;
		SSHORT char_set_id = 0;

		const QualifiedMetaString relationName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);
		const QualifiedMetaString fieldName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);

		if (flag || !strncmp(REL.RDB$SECURITY_CLASS, "SQL$", 4))
		{
			if (lastRelation.object.isEmpty())
				isqlGlob.printf("%s/* Computed fields */%s%s", NEWLINE, NEWLINE, NEWLINE);

			if (lastRelation != relationName)
			{
				if (!lastRelation.object.isEmpty())
					isqlGlob.printf("%s%s%s", isqlGlob.global_Term, NEWLINE, NEWLINE);

				isqlGlob.printf("ALTER TABLE %s", IUTILS_name_to_string(relationName).c_str());

				lastRelation = relationName;
			}
			else
				isqlGlob.printf(",");

			const MetaString columnName(RFR.RDB$FIELD_NAME);

			isqlGlob.printf("%s%sALTER %s ", NEWLINE, TAB_AS_SPACES, IUTILS_name_to_string(columnName).c_str());
			isqlGlob.printf("TYPE ");

			/*
			** If this is a known domain, then just print the domain rather than type
			** Domains won't have length, array, or blob definitions, but they
			** may have not null, default and check overriding their definitions
			*/

			if (!(fb_utils::implicit_domain(fieldName.object.c_str()) && FLD.RDB$SYSTEM_FLAG != 1))
			{
				isqlGlob.prints(IUTILS_name_to_string(fieldName).c_str());

				// International character sets
				// Print only the collation
				if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
					!RFR.RDB$COLLATION_ID.NULL)
				{
					collation = RFR.RDB$COLLATION_ID;
					char_set_id = FLD.RDB$CHARACTER_SET_ID;
					ISQL_get_character_sets(char_set_id, collation,
						getDefaultCharSetForSchemaFunc(relationName.schema),
						Get::COLLATE_ONLY, false, char_sets);

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
				}
			}
			else
			{
				if (!ISQL_printNumericType(fieldName, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
						FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
				{
					return;
				}

				if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying))
				{
					isqlGlob.printf("(%d)",
						ISQL_get_char_length(
							FLD.RDB$FIELD_LENGTH,
							FLD.RDB$CHARACTER_LENGTH.NULL, FLD.RDB$CHARACTER_LENGTH,
							FLD.RDB$CHARACTER_SET_ID.NULL, FLD.RDB$CHARACTER_SET_ID
						)
					);
				}

				// Catch arrays after printing the type

				if (!FLD.RDB$DIMENSIONS.NULL)
					ISQL_array_dimensions(fieldName);

				if (FLD.RDB$FIELD_TYPE == blr_blob)
				{
					const int subtype = FLD.RDB$FIELD_SUB_TYPE;
					isqlGlob.printf(" SUB_TYPE ");

					if ((subtype > 0) && (subtype <= MAX_BLOBSUBTYPES))
						isqlGlob.prints(Sub_types[subtype]);
					else
						isqlGlob.printf("%d", subtype);

					isqlGlob.printf(" SEGMENT SIZE %u", (USHORT) FLD.RDB$SEGMENT_LENGTH);
				}

				// International character sets
				if ((((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
					  FLD.RDB$FIELD_SUB_TYPE == fb_text_subtype_text) ||
					 FLD.RDB$FIELD_TYPE == blr_blob) &&
					!FLD.RDB$CHARACTER_SET_ID.NULL)
				{
					char_sets.clear();

					// Override rdb$fields id with relation_fields if present

					if (!RFR.RDB$COLLATION_ID.NULL)
						collation = RFR.RDB$COLLATION_ID;
					else if (!FLD.RDB$COLLATION_ID.NULL)
						collation = FLD.RDB$COLLATION_ID;

					if (!FLD.RDB$CHARACTER_SET_ID.NULL)
						char_set_id = FLD.RDB$CHARACTER_SET_ID;
					if (char_set_id != getDefaultCharSetForSchemaFunc(relationName.schema))
					{
						// Currently ALTER TABLE syntax doesn't allow collation here.
						ISQL_get_character_sets(char_set_id, collation,
							getDefaultCharSetForSchemaFunc(relationName.schema),
							Get::CHARSET_ONLY, false, char_sets);
					}

					if (char_sets.hasData())
						isqlGlob.prints(char_sets.c_str());
					// CVC: Someone deleted the code that checks intchar when handling collations
					// several lines below, so it didn't have any effect. Commented it.
					//if (!char_set_id)
					//	intchar = true;
				}
			}

			isqlGlob.printf(" COMPUTED BY ");

			if (!FLD.RDB$COMPUTED_SOURCE.NULL)
				ISQL_print_validation(isqlGlob.Out, &FLD.RDB$COMPUTED_SOURCE, true, fbTrans);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		ROLLBACK;
		return;
	END_ERROR

	if (lastRelation.object.hasData())
		isqlGlob.printf("%s%s%s", isqlGlob.global_Term, NEWLINE, NEWLINE);
}


static void list_exceptions()
{
/**************************************
 *
 *	l i s t _ e x c e p t i o n s
 *
 **************************************
 *
 * Functional description
 *	List all exceptions defined in the database
 *
 *	Parameters:  none
 *
 **************************************/
	bool first = true;

	FOR EXC IN RDB$EXCEPTIONS
		SORTED BY EXC.RDB$SCHEMA_NAME, EXC.RDB$EXCEPTION_NAME
	{
		if (first)
			isqlGlob.printf("%s/*  Exceptions */%s", NEWLINE, NEWLINE);

		first = false;

		const QualifiedMetaString name(EXC.RDB$EXCEPTION_NAME, EXC.RDB$SCHEMA_NAME);

		IUTILS_copy_SQL_id (EXC.RDB$MESSAGE, SQL_identifier2, SINGLE_QUOTE);

		isqlGlob.printf(
			"CREATE EXCEPTION %s %s%s%s",
			IUTILS_name_to_string(name).c_str(),
			SQL_identifier2,
			isqlGlob.global_Term,
			NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_filters()
{
/**************************************
 *
 *	l i s t _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 *	List all blob filters
 *
 *	Parameters:  none
 * Results in
 * DECLARE FILTER <fname> INPUT_TYPE <blob_sub_type> OUTPUT_TYPE <blob_subtype>
 *		 ENTRY_POINT <string> MODULE_NAME <string>
 **************************************/
	bool first = true;

	FOR FIL IN RDB$FILTERS
		SORTED BY FIL.RDB$FUNCTION_NAME
	{
		fb_utils::exact_name(FIL.RDB$MODULE_NAME);
		fb_utils::exact_name(FIL.RDB$ENTRYPOINT);

		if (first)
		{
			isqlGlob.printf("%s/*  BLOB Filter declarations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const MetaString name(FIL.RDB$FUNCTION_NAME);

		isqlGlob.printf("DECLARE FILTER %s INPUT_TYPE %d OUTPUT_TYPE %d%s",
			IUTILS_name_to_string(name).c_str(), FIL.RDB$INPUT_SUB_TYPE, FIL.RDB$OUTPUT_SUB_TYPE, NEWLINE);

		IUTILS_copy_SQL_id(FIL.RDB$ENTRYPOINT, SQL_identifier, SINGLE_QUOTE);
		IUTILS_copy_SQL_id(FIL.RDB$MODULE_NAME, SQL_identifier2, SINGLE_QUOTE);

		isqlGlob.printf("%sENTRY_POINT %s MODULE_NAME %s%s%s%s",
			TAB_AS_SPACES, SQL_identifier, SQL_identifier2,
			isqlGlob.global_Term, NEWLINE, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_foreign()
{
/**************************************
 *
 *	l i s t _ f o r e i g n
 *
 **************************************
 *
 * Functional description
 *	List all foreign key constraints and alter the tables
 *
 **************************************/
	SCHAR collist[BUFFER_LENGTH512 * 2];

	// Static queries for obtaining foreign constraints, where RELC1 is the
	// foreign key constraints, RELC2 is the primary key lookup and REFC is the join table

	FOR RELC1 IN RDB$RELATION_CONSTRAINTS CROSS
		RELC2 IN RDB$RELATION_CONSTRAINTS CROSS
		REFC IN RDB$REF_CONSTRAINTS
		WITH RELC1.RDB$CONSTRAINT_TYPE EQ "FOREIGN KEY" AND
			 REFC.RDB$CONST_SCHEMA_NAME_UQ EQUIV RELC2.RDB$SCHEMA_NAME AND
			 REFC.RDB$CONST_NAME_UQ EQ RELC2.RDB$CONSTRAINT_NAME AND
			 REFC.RDB$SCHEMA_NAME EQUIV RELC1.RDB$SCHEMA_NAME AND
			 REFC.RDB$CONSTRAINT_NAME EQ RELC1.RDB$CONSTRAINT_NAME AND
			 (RELC2.RDB$CONSTRAINT_TYPE EQ "UNIQUE" OR
			 RELC2.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY")
		SORTED BY RELC1.RDB$SCHEMA_NAME, RELC1.RDB$RELATION_NAME, RELC1.RDB$CONSTRAINT_NAME
	{
		const QualifiedMetaString relationName1(RELC1.RDB$RELATION_NAME, RELC1.RDB$SCHEMA_NAME);
		const QualifiedMetaString indexName1(RELC1.RDB$INDEX_NAME, RELC1.RDB$SCHEMA_NAME);
		const QualifiedMetaString relationName2(RELC2.RDB$RELATION_NAME, RELC2.RDB$SCHEMA_NAME);
		const QualifiedMetaString indexName2(RELC2.RDB$INDEX_NAME, RELC2.RDB$SCHEMA_NAME);
		const MetaString constraintName(RELC1.RDB$CONSTRAINT_NAME);

		ISQL_get_index_segments(collist, sizeof(collist), indexName1);

		isqlGlob.printf(NEWLINE);

		isqlGlob.printf("ALTER TABLE %s ADD ", IUTILS_name_to_string(relationName1).c_str());

		// If the name of the constraint is not INTEG..., print it.
	    // INTEG_... are internally generated names.
		if (!RELC1.RDB$CONSTRAINT_NAME.NULL &&
			!fb_utils::implicit_integrity(constraintName.c_str()))
		{
			isqlGlob.printf(
				"CONSTRAINT %s ",
				IUTILS_name_to_string(constraintName).c_str());
		}

		isqlGlob.printf("FOREIGN KEY (%s) REFERENCES %s ", collist, IUTILS_name_to_string(relationName2).c_str());

		// Get the column list for the primary key

		ISQL_get_index_segments(collist, sizeof(collist), indexName2);

		isqlGlob.printf("(%s)", collist);

		// Add the referential actions, if any
		if (!REFC.RDB$UPDATE_RULE.NULL)
		{
			IUTILS_truncate_term (REFC.RDB$UPDATE_RULE, static_cast<USHORT>(strlen(REFC.RDB$UPDATE_RULE)));
			ISQL_ri_action_print (REFC.RDB$UPDATE_RULE, " ON UPDATE", true);
		}

		if (!REFC.RDB$DELETE_RULE.NULL)
		{
			IUTILS_truncate_term (REFC.RDB$DELETE_RULE, static_cast<USHORT>(strlen(REFC.RDB$DELETE_RULE)));
			ISQL_ri_action_print (REFC.RDB$DELETE_RULE, " ON DELETE", true);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_functions_legacy()
{
/**************************************
 *
 *	l i s t _ f u n c t i o n s _ l e g a c y
 *
 **************************************
 *
 * Functional description
 *	List all external functions
 *
 *	Parameters:  none
 * Results in
 * DECLARE EXTERNAL FUNCTION function_name
 *               CHAR(256) , INTEGER, ....
 *               RETURNS INTEGER BY VALUE
 *               ENTRY_POINT entrypoint MODULE_NAME module;
 **************************************/
	string type_buffer;
	string return_buffer;

	bool first = true;

	FOR FUN IN RDB$FUNCTIONS
		WITH (FUN.RDB$SYSTEM_FLAG NE 1 OR FUN.RDB$SYSTEM_FLAG MISSING) AND
			 FUN.RDB$MODULE_NAME NOT MISSING AND
			 FUN.RDB$PACKAGE_NAME MISSING
		SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$FUNCTION_NAME
	{
		fb_utils::exact_name(FUN.RDB$MODULE_NAME);
		fb_utils::exact_name(FUN.RDB$ENTRYPOINT);
		if (first)
		{
			isqlGlob.printf("%s/*  External Function declarations */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

		// Start new function declaration
		isqlGlob.printf("DECLARE EXTERNAL FUNCTION %s%s", IUTILS_name_to_string(name).c_str(), NEWLINE);

		bool firstarg = true;

		FOR FNA IN RDB$FUNCTION_ARGUMENTS
			WITH FNA.RDB$SCHEMA_NAME EQUIV FUN.RDB$SCHEMA_NAME AND
				 FNA.RDB$FUNCTION_NAME EQ FUN.RDB$FUNCTION_NAME AND
				 FNA.RDB$PACKAGE_NAME MISSING
			SORTED BY FNA.RDB$ARGUMENT_POSITION
		{
			// Find parameter type
			int i = 0;
			while (FNA.RDB$FIELD_TYPE != Column_types[i].type)
				i++;

			fb_assert(Column_types[i].type != 0);

			// Print length where appropriate
			if ((FNA.RDB$FIELD_TYPE == blr_text) ||
				(FNA.RDB$FIELD_TYPE == blr_varying) ||
				(FNA.RDB$FIELD_TYPE == blr_cstring))
			{
				bool did_charset = false;
				FOR CHARSET IN RDB$CHARACTER_SETS
					WITH CHARSET.RDB$CHARACTER_SET_ID = FNA.RDB$CHARACTER_SET_ID
				{
					const QualifiedMetaString charSetName(
						CHARSET.RDB$CHARACTER_SET_NAME, CHARSET.RDB$SCHEMA_NAME);

					did_charset = true;
					type_buffer.printf("%s(%d) CHARACTER SET %s",
							 Column_types[i].type_name,
							 (FNA.RDB$FIELD_LENGTH / MAX (1, CHARSET.RDB$BYTES_PER_CHARACTER)),
							 IUTILS_name_to_string(charSetName).c_str());
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg (fbStatus);
					return;
				END_ERROR

				if (!did_charset)
				{
					type_buffer.printf("%s(%d)",
							Column_types[i].type_name, FNA.RDB$FIELD_LENGTH);
				}
			}
			else
			{
				bool precision_known = false;

				if (isqlGlob.major_ods >= ODS_VERSION10 &&
					(FNA.RDB$FIELD_TYPE == blr_short ||
					 FNA.RDB$FIELD_TYPE == blr_long ||
					 FNA.RDB$FIELD_TYPE == blr_int64 ||
					 FNA.RDB$FIELD_TYPE == blr_int128))
				{
					// We are ODS >= 10 and could be any Dialect
					// We are Dialect >=3 since FIELD_PRECISION is non-NULL
					if (!FNA.RDB$FIELD_PRECISION.NULL &&
						FNA.RDB$FIELD_SUB_TYPE > 0 &&
						FNA.RDB$FIELD_SUB_TYPE <= MAX_INTSUBTYPES)
					{
						type_buffer.printf("%s(%d, %d)",
								Integral_subtypes[FNA.RDB$FIELD_SUB_TYPE],
								FNA.RDB$FIELD_PRECISION,
								-FNA.RDB$FIELD_SCALE);
						precision_known = true;
					}
				} // if isqlGlob.major_ods >= ods_version10 &&

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((FNA.RDB$FIELD_TYPE == blr_short) && (FNA.RDB$FIELD_SCALE < 0))
						type_buffer.printf("NUMERIC(4, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_long) && (FNA.RDB$FIELD_SCALE < 0))
						type_buffer.printf("NUMERIC(9, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_double) && (FNA.RDB$FIELD_SCALE < 0))
						type_buffer.printf("NUMERIC(15, %d)", -FNA.RDB$FIELD_SCALE);
					else
						type_buffer.printf("%s", Column_types[i].type_name);
				} // if !precision_known
			} // if blr_text or blr_varying or blr_cstring ... else

			// If a return argument, save it for the end, otherwise print

			/*
			 * Changed the following to not return a BLOB by value.
			 * To be sincere, this code doesn't cater for the RETURNS PARAMETER syntax but
			 * it would require more surgery than I'm willing to do, since I'm sick of isql
			 * so I started my own metadata extraction utility based on IBO that does this
			 * trick and others.
			 * Claudio Valderrama (by way of) MOD 23-Apr-2001

			 CVC: Finally enhanced the UDF metadata extraction.
			*/

			int ptype = (int) abs(FNA.RDB$MECHANISM);
			if (ptype > MAX_UDFPARAM_TYPES)
				ptype = MAX_UDFPARAM_TYPES;

			bool printarg = true;

			if (FUN.RDB$RETURN_ARGUMENT == FNA.RDB$ARGUMENT_POSITION)
			{
				if (FUN.RDB$RETURN_ARGUMENT)
					return_buffer.printf("RETURNS PARAMETER %d", FUN.RDB$RETURN_ARGUMENT);
				else
				{
					return_buffer.printf("RETURNS %s%s %s", type_buffer.c_str(),
							 UDF_param_types[ptype],
							 (FNA.RDB$MECHANISM < 0 ? "FREE_IT" : ""));
					printarg = false;
				}
			}

			if (printarg)
			{
				// First arg needs no comma
				isqlGlob.printf("%s%s%s", (firstarg ? "" : ", "), type_buffer.c_str(), UDF_param_types[ptype]);
				firstarg = false;
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return;
		END_ERROR

		// Print the return type -- All functions return a type
		isqlGlob.printf("%s%s%s", NEWLINE, return_buffer.c_str(), NEWLINE);

		// Print out entrypoint information
		IUTILS_copy_SQL_id(FUN.RDB$ENTRYPOINT, SQL_identifier, SINGLE_QUOTE);
		IUTILS_copy_SQL_id(FUN.RDB$MODULE_NAME, SQL_identifier2, SINGLE_QUOTE);

		isqlGlob.printf("ENTRY_POINT %s MODULE_NAME %s%s%s%s",
				 SQL_identifier,
				 SQL_identifier2,
				 isqlGlob.global_Term,
				 NEWLINE,
				 NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}

static void list_functions_ods12_headers(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool header = true;
	static const char* const create_function	= "CREATE OR ALTER FUNCTION %s ";
	static const char* const body_function		= "BEGIN END %s%s";

	//  First the dummy functions (without bodies)

	FOR FUN IN RDB$FUNCTIONS
		WITH (FUN.RDB$SYSTEM_FLAG NE 1 OR FUN.RDB$SYSTEM_FLAG MISSING) AND
			 FUN.RDB$PACKAGE_NAME MISSING AND
			 FUN.RDB$MODULE_NAME MISSING
		SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$FUNCTION_NAME
	{
		const QualifiedMetaString name(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

		if (header)
		{
			print_proc_prefix(obj_udf, true);
			header = false;
		}

		isqlGlob.printf(create_function, IUTILS_name_to_string(name).c_str());

		get_function_args_ods12(name, FUN.RDB$RETURN_ARGUMENT, getDefaultCharSetForSchemaFunc);

		if (!FUN.RDB$DETERMINISTIC_FLAG.NULL && FUN.RDB$DETERMINISTIC_FLAG)
			isqlGlob.printf("DETERMINISTIC %s", NEWLINE);

		isqlGlob.printf("AS %s", NEWLINE);
		isqlGlob.printf(body_function, Procterm, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// Only reset the terminators if there were procs to print
	if (!header)
		print_proc_suffix(obj_udf);
}

static void list_functions_ods12_bodies(GetDefaultCharSetForSchemaFunc getDefaultCharSetForSchemaFunc)
{
	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool header = true;

	// This query gets the function name and the source.  We then nest a query
	// to retrieve the parameters. Alter is used, because the functions are already there
	TEXT msg[MSG_LENGTH];

	FOR FUN IN RDB$FUNCTIONS
		WITH (FUN.RDB$SYSTEM_FLAG NE 1 OR FUN.RDB$SYSTEM_FLAG MISSING) AND
			 FUN.RDB$PACKAGE_NAME MISSING AND
			 FUN.RDB$MODULE_NAME MISSING
		SORTED BY FUN.RDB$SCHEMA_NAME, FUN.RDB$FUNCTION_NAME
	{
		const QualifiedMetaString name(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

		if (header)
		{
			print_proc_prefix(obj_udf, false);
			header = false;
		}

		isqlGlob.printf("%sALTER FUNCTION %s ", NEWLINE, IUTILS_name_to_string(name).c_str());

		get_function_args_ods12(name, FUN.RDB$RETURN_ARGUMENT, getDefaultCharSetForSchemaFunc);

		if (!FUN.RDB$DETERMINISTIC_FLAG.NULL && FUN.RDB$DETERMINISTIC_FLAG)
			isqlGlob.printf("DETERMINISTIC %s", NEWLINE);

		// Print the function body

		if (!FUN.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENTRYPOINT);
			IUTILS_copy_SQL_id(FUN.RDB$ENTRYPOINT, SQL_identifier2, SINGLE_QUOTE);
			isqlGlob.printf("EXTERNAL NAME %s%s", SQL_identifier2, NEWLINE);
		}

		if (!FUN.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = FUN.RDB$SQL_SECURITY ? "SQL SECURITY DEFINER" : "SQL SECURITY INVOKER";
			isqlGlob.printf("%s%s", ss, NEWLINE);
		}

		if (!FUN.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENGINE_NAME);
			isqlGlob.printf("ENGINE %s", FUN.RDB$ENGINE_NAME);

			if (!FUN.RDB$FUNCTION_SOURCE.NULL)
			{
				isqlGlob.printf("%sAS '", NEWLINE);
				SHOW_print_metadata_text_blob(isqlGlob.Out, &FUN.RDB$FUNCTION_SOURCE, true);
				isqlGlob.printf("'%s", NEWLINE);
			}
		}
		else if (!FUN.RDB$FUNCTION_SOURCE.NULL)
		{
			isqlGlob.printf("AS %s", NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &FUN.RDB$FUNCTION_SOURCE);
		}

		isqlGlob.printf(" %s%s", Procterm, NEWLINE);
	}
	END_FOR
	ON_ERROR
		IUTILS_msg_get(GEN_ERR, msg, SafeArg() << isc_sqlcode(fbStatus->getErrors()));
		STDERROUT(msg);			// Statement failed, SQLCODE = %d\n\n
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	// Only reset the terminators if there were procs to print
	if (!header)
		print_proc_suffix(obj_udf);
}


static void list_generators()
{
/**************************************
 *
 *	l i s t _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Re create all non-system generators
 *
 **************************************/

	bool first = true;

	FOR GEN IN RDB$GENERATORS
		WITH GEN.RDB$GENERATOR_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *" AND
			 GEN.RDB$GENERATOR_NAME NOT MATCHING "SQL$+" USING "+=[0-9][0-9]* *" AND
			 (GEN.RDB$SYSTEM_FLAG MISSING OR GEN.RDB$SYSTEM_FLAG NE 1)
		SORTED BY GEN.RDB$SCHEMA_NAME, GEN.RDB$GENERATOR_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/*  Generators or sequences */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(GEN.RDB$GENERATOR_NAME, GEN.RDB$SCHEMA_NAME);

		isqlGlob.printf("CREATE GENERATOR %s", IUTILS_name_to_string(name).c_str());

		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			if (!GEN.RDB$INITIAL_VALUE.NULL && GEN.RDB$INITIAL_VALUE != 0)
				isqlGlob.printf(" START WITH %" SQUADFORMAT, GEN.RDB$INITIAL_VALUE);

			if (GEN.RDB$GENERATOR_INCREMENT != 1)
				isqlGlob.printf(" INCREMENT %" SLONGFORMAT, GEN.RDB$GENERATOR_INCREMENT);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;

	isqlGlob.printf(NEWLINE);
}


static void list_indexes()
{
/**************************************
 *
 *	l i s t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Define all non-constraint indices
 *	Use a static SQL query to get the info and print it.
 *
 *	Uses get_index_segment to provide a key list for each index
 *
 **************************************/
	char collist[BUFFER_LENGTH512 * 2];

	bool first = true;

	FOR IDX IN RDB$INDICES CROSS
		RELC IN RDB$RELATIONS
		WITH RELC.RDB$SCHEMA_NAME EQUIV IDX.RDB$SCHEMA_NAME AND
			 RELC.RDB$RELATION_NAME EQ IDX.RDB$RELATION_NAME AND
			 (RELC.RDB$SYSTEM_FLAG NE 1 OR RELC.RDB$SYSTEM_FLAG MISSING) AND
			 NOT (
				ANY RC IN RDB$RELATION_CONSTRAINTS
				WITH RC.RDB$SCHEMA_NAME EQUIV IDX.RDB$SCHEMA_NAME AND
					 RC.RDB$INDEX_NAME EQ IDX.RDB$INDEX_NAME)
		SORTED BY IDX.RDB$SCHEMA_NAME, IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME
	{
		if (first)
		{
			isqlGlob.printf("%s/*  Index definitions for all user tables */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const QualifiedMetaString name(IDX.RDB$INDEX_NAME, IDX.RDB$SCHEMA_NAME);
		const MetaString relationName(IDX.RDB$RELATION_NAME);

		isqlGlob.printf(
			"CREATE%s%s INDEX %s%s ON %s",
			(IDX.RDB$UNIQUE_FLAG ? " UNIQUE" : ""),
			(IDX.RDB$INDEX_TYPE ? " DESCENDING" : ""),
			IUTILS_name_to_string(name).c_str(),
			(IDX.RDB$INDEX_INACTIVE ? " INACTIVE" : ""),
			IUTILS_name_to_string(relationName).c_str());

		// Get index expression or column names

		if (!IDX.RDB$EXPRESSION_BLR.NULL)
		{
			isqlGlob.printf(" COMPUTED BY ");
			if (!IDX.RDB$EXPRESSION_SOURCE.NULL)
				SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX.RDB$EXPRESSION_SOURCE, false, true);
		}
		else if (ISQL_get_index_segments(collist, sizeof(collist), name))
			isqlGlob.printf(" (%s)", collist);

		// Get index condition, if present

		if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_13_1 && !IDX.RDB$CONDITION_SOURCE.NULL)
		{
			isqlGlob.printf("%s ", NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX.RDB$CONDITION_SOURCE, false, true);
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


static void list_package_bodies()
{
/**************************************
 *
 *	l i s t _ p a c k a g e _ b o d i e s
 *
 **************************************
 *
 * Functional description
 *	Create body of packages
 *	Use a SQL query to get the info and print it.
 *	Ignore the packages whose body has not been defined yet.
 *
 **************************************/

	if (isqlGlob.major_ods < ODS_VERSION12)
		return;

	bool header = true;

	FOR PACK IN RDB$PACKAGES
		WITH (PACK.RDB$SYSTEM_FLAG NE 1 OR PACK.RDB$SYSTEM_FLAG MISSING) AND
			 PACK.RDB$PACKAGE_BODY_SOURCE NOT MISSING
		SORTED BY PACK.RDB$SCHEMA_NAME, PACK.RDB$PACKAGE_NAME
	{
		if (header)
		{
			print_proc_prefix(obj_package_body, false);
			header = false;
		}

		const QualifiedMetaString name(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);
		const MetaString ownerName(PACK.RDB$OWNER_NAME);

		isqlGlob.printf("%s/* Package body: %s, Owner: %s%s */%s",
				 NEWLINE,
				 IUTILS_name_to_string(name).c_str(),
				 IUTILS_name_to_string(ownerName).c_str(),
				 (!PACK.RDB$VALID_BODY_FLAG.NULL && PACK.RDB$VALID_BODY_FLAG != 0 ? "" : ", Invalid"),
				 NEWLINE);

		if (!PACK.RDB$VALID_BODY_FLAG.NULL && PACK.RDB$VALID_BODY_FLAG != 0)
		{
			isqlGlob.printf("CREATE PACKAGE BODY %s AS%s", IUTILS_name_to_string(name).c_str(), NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &PACK.RDB$PACKAGE_BODY_SOURCE);
			isqlGlob.printf("%s%s", Procterm, NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (!header)
		print_proc_suffix(obj_package_body);
}


static void list_package_headers()
{
/**************************************
 *
 *	l i s t _ p a c k a g e _ h e a d e r s
 *
 **************************************
 *
 * Functional description
 *	Show header of packages
 *	Use a SQL query to get the info and print it.
 *
 **************************************/

 	if (isqlGlob.major_ods < ODS_VERSION12)
 		return;

 	bool header = true;

	FOR PACK IN RDB$PACKAGES
		WITH (PACK.RDB$SYSTEM_FLAG NE 1 OR PACK.RDB$SYSTEM_FLAG MISSING)
		SORTED BY PACK.RDB$SCHEMA_NAME, PACK.RDB$PACKAGE_NAME
	{
		if (header)
		{
			print_proc_prefix(obj_package_header, false);
			header = false;
		}

		const QualifiedMetaString name(PACK.RDB$PACKAGE_NAME, PACK.RDB$SCHEMA_NAME);
		const MetaString ownerName(PACK.RDB$OWNER_NAME);

		isqlGlob.printf("%s/* Package header: %s, Owner: %s */%s",
				 NEWLINE,
				 IUTILS_name_to_string(name).c_str(),
				 IUTILS_name_to_string(ownerName).c_str(),
				 NEWLINE);

		const char* ss = PACK.RDB$SQL_SECURITY.NULL ? "" :
						(PACK.RDB$SQL_SECURITY ? " SQL SECURITY DEFINER" : " SQL SECURITY INVOKER");

		isqlGlob.printf("CREATE PACKAGE %s%s AS%s", IUTILS_name_to_string(name).c_str(), ss, NEWLINE);

		if (!PACK.RDB$PACKAGE_HEADER_SOURCE.NULL)
			SHOW_print_metadata_text_blob(isqlGlob.Out, &PACK.RDB$PACKAGE_HEADER_SOURCE);
		else
			isqlGlob.printf("BEGIN END /* Missing package header info. */");

		isqlGlob.printf("%s%s", Procterm, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (!header)
		print_proc_suffix(obj_package_header);
}


// Show schemas.
static void list_schemas()
{
	if (isqlGlob.major_ods < ODS_VERSION14)
		return;

	bool first = true;

	FOR SCH IN RDB$SCHEMAS
		CROSS DB IN RDB$DATABASE
		WITH (SCH.RDB$SYSTEM_FLAG NE 1 OR SCH.RDB$SYSTEM_FLAG MISSING)
		SORTED BY SCH.RDB$SCHEMA_NAME
	{
		const MetaString name(SCH.RDB$SCHEMA_NAME);
		const MetaString ownerName(SCH.RDB$OWNER_NAME);

		if (first)
		{
			isqlGlob.printf("%s/* Schema definitions */%s", NEWLINE, NEWLINE);
			first = false;
		}

		const bool isPublicSchema = name == "PUBLIC";

		isqlGlob.printf("%s/* Schema: %s, Owner: %s */%s",
				 NEWLINE,
				 IUTILS_name_to_string(name).c_str(),
				 IUTILS_name_to_string(ownerName).c_str(),
				 NEWLINE);

		isqlGlob.printf(
			"CREATE%s SCHEMA %s",
			(isPublicSchema ? " OR ALTER" : ""),
			IUTILS_name_to_string(name).c_str());

		if (!SCH.RDB$CHARACTER_SET_NAME.NULL)
		{
			const QualifiedMetaString defaultCharSetName(
				SCH.RDB$CHARACTER_SET_NAME, SCH.RDB$CHARACTER_SET_SCHEMA_NAME);

			isqlGlob.printf(
				" DEFAULT CHARACTER SET %s",
				IUTILS_name_to_string(defaultCharSetName).c_str());
		}

		if (!SCH.RDB$SQL_SECURITY.NULL)
		{
			isqlGlob.printf(
				" DEFAULT SQL SECURITY %s",
				(SCH.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER"));
		}

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	if (!first)
		isqlGlob.printf("%sCOMMIT WORK%s%s", NEWLINE, isqlGlob.global_Term, NEWLINE);
}


static void list_views()
{
/**************************************
 *
 *	l i s t _ v i e w s
 *
 **************************************
 *
 * Functional description
 *	Create text of views.
 *	Use a SQL query to get the info and print it.
 *	Note: This should also contain check option
 *
 **************************************/

	// If this is a view, use print_blob to print the view text

	FOR REL IN RDB$RELATIONS
		WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			 REL.RDB$VIEW_BLR NOT MISSING AND
			 REL.RDB$FLAGS = REL_sql
		SORTED BY REL.RDB$SCHEMA_NAME, REL.RDB$RELATION_ID
	{
		const QualifiedMetaString name(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);
		const MetaString ownerName(REL.RDB$OWNER_NAME);

		isqlGlob.printf("%s/* View: %s, Owner: %s */%s",
				 NEWLINE,
				 IUTILS_name_to_string(name).c_str(),
				 IUTILS_name_to_string(ownerName).c_str(),
				 NEWLINE);
		isqlGlob.printf("CREATE VIEW %s (", IUTILS_name_to_string(name).c_str());

		bool first = true;

		// Get column list
		FOR RFR IN RDB$RELATION_FIELDS
			WITH RFR.RDB$SCHEMA_NAME EQUIV NULLIF(REL.RDB$SCHEMA_NAME, '') AND
				 RFR.RDB$RELATION_NAME = REL.RDB$RELATION_NAME
			SORTED BY RFR.RDB$FIELD_POSITION
		{
			const MetaString columnName(RFR.RDB$FIELD_NAME);
			isqlGlob.printf("%s%s", (first ? "" : ", "), IUTILS_name_to_string(columnName).c_str());
			first = false;
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return;
		END_ERROR

		isqlGlob.printf(") AS%s", NEWLINE);

		if (!REL.RDB$VIEW_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &REL.RDB$VIEW_SOURCE);

		isqlGlob.printf("%s%s", isqlGlob.global_Term, NEWLINE);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}
