/*
 *	PROGRAM:	Interactive SQL utility
 *	MODULE:		isql.epp
 *	DESCRIPTION:	Main line routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
  Revision 1.5  2000/11/18 16:49:24  fsg
  Increased PRINT_BUFFER_LENGTH to 2048 to show larger plans
  Fixed Bug #122563 in extract.e get_procedure_args
  Apparently this has to be done in show.e also,
  but that is for another day :-)

  2001/05/20  Neil McCalden  add planonly option
  2001.09.09  Claudio Valderrama: put double quotes around identifiers
	in dialect 3 only when needed. Solve mischievous declaration/invocation
	of IUTILS_copy_SQL_id that made no sense and caused pointer problems.
  2001/10/03  Neil McCalden  pick up Firebird version from database server
	and display it with client version when -z used.
  2001.10.09 Claudio Valderrama: try to disconnect gracefully in batch mode.
  2001.11.23 Claudio Valderrama: skip any number of -- comments but only at
	the beginning and ignore void statements like block comments followed by
	a semicolon.
  2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
  2003-08-15 Fred Polizo, Jr. - Fixed print_item() to correctly print
  string types as their hex represention for CHARACTER SET OCTETS.
  2004-11-16 Damyan Ivanov - bail out on error in non-interactive mode.

*/

#include "firebird.h"
#include <cmath>
#include <stdio.h>
#include "../jrd/intl.h"
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <limits.h>
#include <math.h>
#include <ctype.h>
#include <errno.h>
#include <optional>
#include "../isql/FrontendLexer.h"
#include "../isql/FrontendParser.h"
#include "../common/StdHelper.h"
#include "../common/utils_proto.h"
#include "../common/classes/array.h"
#include "../common/classes/init.h"
#include "../common/classes/ClumpletWriter.h"
#include "../common/classes/TempFile.h"
#include "../common/classes/FpeControl.h"
#include "../common/classes/GenericMap.h"
#include "../common/os/os_utils.h"
#include "../common/os/path_utils.h"
#include "../common/StatusHolder.h"
#include "../common/Tokens.h"
#include "../common/TimeZoneUtil.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#ifdef HAVE_EDITLINE_H
// This is a local file included in our distribution - but not always
// compiled into the system
#include "editline.h"
#endif

enum literal_string_type
{
	INIT_STR_FLAG			= 0,
	SINGLE_QUOTED_STRING	= 1,
	DOUBLE_QUOTED_STRING	= 2,
	NO_MORE_STRING			= 3,
	INCOMPLETE_STRING		= 4
};

#include "../common/classes/timestamp.h"

#if defined(WIN_NT)
#include <windows.h>
#endif
#include "ibase.h"
#include "../isql/isql.h"
#include "../yvalve/perf.h"
#include "../jrd/license.h"
#include "../jrd/constants.h"
#include "../jrd/ods.h"
#include "../common/file_params.h"
#include "../common/classes/ImplementHelper.h"
#include "../isql/extra_proto.h"
#include "../isql/isql_proto.h"
#include "../isql/show_proto.h"
#include "../isql/iutils_proto.h"
#include "../yvalve/perf_proto.h"
#include "../yvalve/utl_proto.h"
#include "../yvalve/why_proto.h"
#include "../common/gdsassert.h"

#include "../isql/Extender.h"
#include "../isql/PtrSentry.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/MsgPrint.h"
#include "../common/classes/array.h"

using namespace Firebird;
using MsgFormat::SafeArg;

#include "../isql/ColList.h"
#include "../isql/InputDevices.h"
#include "../isql/OptionsBase.h"

#include "../common/classes/Switches.h"
#include "../isql/isqlswi.h"

#include "../intl/charsets.h"
#include <unicode/utf8.h>


//DATABASE DB = COMPILETIME "yachts.lnk";
DATABASE DB = COMPILETIME "yachts.lnk" RUNTIME isqlGlob.global_Db_name;

IsqlGlobals isqlGlob;

#define DIGIT(c)		((c) >= '0' && (c) <= '9')
#define INT64_LIMIT	 ((((SINT64) 1) << 62) / 5)	// same as in cvt.cpp

//  Print lengths of numeric values

const int SHORT_LEN		= 7;	// NUMERIC (4,2) = -327.68
const int LONG_LEN		= 12;	// NUMERIC (9,2) = -21474836.48
const int INT64_LEN		= 21;	// NUMERIC(18,2) = -92233720368547758.08
//const int QUAD_LEN		= 19;
const int FLOAT_LEN		= 14;	// -1.2345678E+38
const int DOUBLE_LEN		= 23;	// -1.234567890123456E+300
const int DATE_LEN		= 11;	// 11 for date only
const int DATETIME_LEN		= 25;	// 25 for date-time
const int DATETIME_TZ_LEN	= DATETIME_LEN - 1 + 1 + TimeZoneUtil::MAX_LEN;	// DATETIME_LEN should be 24
const int TIME_ONLY_LEN		= 13;	// 13 for time only
const int TIME_TZ_ONLY_LEN	= TIME_ONLY_LEN + 1 + TimeZoneUtil::MAX_LEN;
const int DATE_ONLY_LEN		= 11;
const int BOOLEAN_LEN		= 7;	// <false>
const int UNKNOWN_LEN		= 20;	// Unknown type: %d

const int MAX_TERMS		= 10;	// max # of terms in an interactive cmd

const char* ISQL_COUNTERS_SET = "CurrentMemory, MaxMemory, RealTime, UserTime, Buffers, Reads, Writes, Fetches";
const int ISQL_COUNTERS = 8;

const char* UNKNOWN = "*unknown*";

namespace IcuUtil
{
	// Duplicate from ICU to not need to link ISQL with it. It's used by U8_NEXT_UNSAFE.
	static const uint8_t utf8_countTrailBytes[256] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3,
		3, 3, 3,    /* illegal in Unicode */
		4, 4, 4, 4, /* illegal in Unicode */
		5, 5,       /* illegal in Unicode */
		0, 0        /* illegal bytes 0xfe and 0xff */
	};

	// Return the number of characters of a string.
	static unsigned charLength(SSHORT charset, unsigned len, const char* str)
	{
		charset = TTYPE_TO_CHARSET(charset);

		if (charset != CS_UNICODE_FSS && charset != CS_UTF8)
			return len;

		unsigned charLen = 0;
		unsigned i = 0;

		while (i < len)
		{
			UChar32 c;
			U8_NEXT_UNSAFE(str, i, c);
			++charLen;
		}

		return charLen;
	}

	// Pads a string to a specified column width.
	static void pad(char* buffer, SSHORT charset, unsigned len, const char* str, unsigned width,
		bool right)
	{
		charset = TTYPE_TO_CHARSET(charset);

		if (charset != CS_UNICODE_FSS && charset != CS_UTF8)
		{
			// Truncate if necessary.
			if (len > width)
				len = width;

			if (right)
			{
				memcpy(buffer + width - len, str, len);
				if (width > len)
					memset(buffer, ' ', width - len);
			}
			else
			{
				memcpy(buffer, str, len);
				if (width > len)
					memset(buffer + len, ' ', width - len);
			}
			buffer[width] = '\0';
			return;
		}

		unsigned i = 0;

		while (i < len && width > 0)
		{
			UChar32 c;
			U8_NEXT_UNSAFE(str, i, c);
			--width;
		}

		if (right)
		{
			while (width-- > 0)
				*buffer++ = ' ';
		}

		memcpy(buffer, str, i);
		buffer += i;

		if (!right)
		{
			while (width-- > 0)
				*buffer++ = ' ';
		}

		*buffer = '\0';
	}
}


static inline bool commit_trans(Firebird::ITransaction** x)
{
	(*x)->commit(fbStatus);
	if (ISQL_errmsg (fbStatus))
	{
		(*x)->rollback(fbStatus);
		if (!(fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
		{
			*x = NULL;
		}

		return false;
	}

	*x = NULL;
	return true;
}

static inline int fb_isdigit(const char c)
{
	return isdigit((int)(UCHAR)c);
}


#ifdef WIN_NT
// This function is highly based on code written by https://github.com/xenu
// He permitted our usage here: https://github.com/Perl/perl5/pull/18702#issuecomment-1156050577
static int win32ReadConsole(FILE* file, char* buffer, size_t bufferSize)
{
	// This function is a workaround for a bug in Windows:
	// https://github.com/microsoft/terminal/issues/4551
	// tl;dr: ReadFile() and ReadConsoleA() return garbage when reading
	// non-ASCII characters from the console with the 65001 codepage.
	auto handle = (HANDLE) _get_osfhandle(fileno(file));

	if (handle == INVALID_HANDLE_VALUE)
	{
		fb_assert(false);
		return -1;
	}

	DWORD mode;
	if (!GetConsoleMode(handle, &mode))
	{
		fb_assert(false);
		return -1;
	}

	size_t leftToRead = bufferSize;

	while (leftToRead)
	{
		// The purpose of convertedBuf is to preserve partial UTF-8 (or of any
		// other multibyte encoding) code points between read() calls. Since
		// there's only one console, the buffer is global. It's needed because
		// ReadConsoleW() returns a string of UTF-16 code units and its result,
		// after conversion to the current console codepage, may not fit in the
		// return buffer.
		//
		// The buffer's size is 8 because it will contain at most two UTF-8 code
		// points.
		static char convertedBuf[8];
		static size_t convertedBufLen = 0;

		if (convertedBufLen)
		{
			bool newline = false;
			const size_t toWrite = MIN(convertedBufLen, leftToRead);

			// Don't read anything if the *first* character is ^Z and
			// ENABLE_PROCESSED_INPUT is enabled. On some versions of Windows,
			// ReadFile() ignores ENABLE_PROCESSED_INPUT, but apparently it's a
			// bug: https://github.com/microsoft/terminal/issues/4958
			if (leftToRead == bufferSize && (mode & ENABLE_PROCESSED_INPUT) && convertedBuf[0] == 0x1A)
				break;

			// Are we returning a newline?
			if (memchr(convertedBuf, '\n', toWrite) != 0)
				newline = true;

			memcpy(buffer, convertedBuf, toWrite);
			buffer += toWrite;

			// If there's anything left in convertedBuf, move it to the beginning of the buffer.
			convertedBufLen -= toWrite;

			if (convertedBufLen)
				memmove(convertedBuf, convertedBuf + toWrite, convertedBufLen);

			leftToRead -= toWrite;

			// With ENABLE_LINE_INPUT enabled, we stop reading after the first
			// newline, otherwise we stop reading after the first character.
			if (!leftToRead || newline || (mode & ENABLE_LINE_INPUT) == 0)
				break;
		}

		WCHAR wideBuf[2];
		DWORD charsRead;

		// Reading one code unit at a time is inefficient, but since this code
		// is used only for the interactive console, that shouldn't matter.
		if (!ReadConsoleW(handle, wideBuf, 1, &charsRead, 0))
			return -1;

		if (!charsRead)
			break;

		DWORD wideBufLen = 1;

		if (wideBuf[0] >= 0xD800 && wideBuf[0] <= 0xDBFF)
		{
			// High surrogate, read one more code unit.
			if (!ReadConsoleW(handle, wideBuf + 1, 1, &charsRead, 0))
				return -1;

			if (charsRead)
				++wideBufLen;
		}

		convertedBufLen = WideCharToMultiByte(GetConsoleCP(), 0, wideBuf, wideBufLen,
			convertedBuf, sizeof(convertedBuf), NULL, NULL);

		if (!convertedBufLen)
			return -1;
	}

	return bufferSize - leftToRead;
}
#endif


IsqlGlobals::IsqlGlobals()
{
	Firebird::AutoPtr<Firebird::IStatus, Firebird::SimpleDispose>
		status_vector(fbMaster->getStatus());
	Firebird::CheckStatusWrapper statusWrapper(status_vector);

	df16 = Firebird::UtilInterfacePtr()->getDecFloat16(&statusWrapper);
	df34 = Firebird::UtilInterfacePtr()->getDecFloat34(&statusWrapper);
	i128 = Firebird::UtilInterfacePtr()->getInt128(&statusWrapper);
}

// I s q l G l o b a l s : : p r i n t f
// Output to the Out stream.
void IsqlGlobals::printf(const char* buffer, ...)
{
	va_list args;
	va_start(args, buffer);
	vfprintf(Out, buffer, args);
	va_end(args);
	fflush(Out); // John's fix.
}

// I s q l G l o b a l s : : p r i n t s
// Output to the Out stream a literal string. No escape characters recognized.
void IsqlGlobals::prints(const char* buffer)
{
	fprintf(Out, "%s", buffer);
	fflush(Out); // John's fix.
}



struct ri_actions
{
	const SCHAR* ri_action_name;
	const SCHAR* ri_action_print_caps;
	const SCHAR* ri_action_print_mixed;
};

static processing_state add_row(const QualifiedMetaString&);
static processing_state blobedit(ISC_QUAD, const char*);
static processing_state bulk_insert_hack(const char* command);
static bool bulk_insert_retriever(const char* prompt);
static void check_autoterm();
static bool check_date(const tm& times);
static bool check_time(const tm& times);
static bool check_timestamp(const tm& times, const int msec);
static void col_check(const QualifiedMetaString&, unsigned*);
static processing_state copy_table(const QualifiedMetaString&, const QualifiedMetaString&, const TEXT*);
static processing_state create_db(const FrontendParser::CreateDatabaseNode& node);
static void do_isql();
static processing_state drop_db();
static processing_state edit(const TEXT*);
static processing_state end_trans();
static processing_state escape(const TEXT*);
static processing_state execSetDebugCommand();
static processing_state frontend(const std::string&);
static processing_state do_set_command(const TEXT*, bool*);
static processing_state get_dialect(const char* const dialect_str,
	char* const bad_dialect_buf, bool& bad_dialect);
static bool get_numeric(const UCHAR*, USHORT, SSHORT*, SINT64*);
static void print_set(const char* str, bool v);
static processing_state print_sets();
static processing_state explain(const TEXT*);
static processing_state help(const TEXT*);
static bool isyesno(const TEXT*);
static processing_state newdb(const TEXT*, const TEXT*, const TEXT*, int, const TEXT*, bool);
static processing_state newinput(const TEXT*);
static processing_state newoutput(const TEXT*);
static processing_state newsize(const TEXT*, const TEXT*);
static processing_state newMaxRows(const TEXT* newMaxRowsStr);
static processing_state newtrans(const TEXT*);
static processing_state parse_arg(int, SCHAR**, QualifiedMetaString&); //, FILE**);
static unsigned print_item(TEXT**, const IsqlVar*, const unsigned);
static void print_item_numeric(SINT64, int, int, TEXT*);
static processing_state print_line(Firebird::IMessageMetadata*, UCHAR*, const unsigned pad[], TEXT line[]);
static processing_state print_performance(const SINT64* perf_before);
static void print_message(Firebird::IMessageMetadata* msg, const char* dir);
static void process_header(Firebird::IMessageMetadata*, const unsigned pad[], TEXT header[], TEXT header2[]);
static void process_plan();
static void process_exec_path();
static SINT64 process_record_count(const unsigned statement_type);
static unsigned process_message_display(Firebird::IMessageMetadata* msg, unsigned pad[]);
static processing_state process_statement(const std::string&);
#ifdef WIN_NT
static BOOL CALLBACK query_abort(DWORD);
#else
static int query_abort(const int, const int, void*);
#endif
static bool stdin_redirected();
static void strip_quotes(const TEXT*, TEXT*);
static const char* sqltype_to_string(unsigned);
static const QualifiedMetaString& charset_to_string(unsigned);

// The dialect spoken by the database, should be 0 when no database is connected.
USHORT global_dialect_spoken = 0;
USHORT requested_SQL_dialect = SQL_DIALECT_V6;
//bool connecting_to_pre_v6_server = false; Not used now.
bool Quiet = false;
#ifdef TRUSTED_AUTH
bool Trusted_auth = false;
#endif
bool Version_info = false;

// Utility transaction handle
static Firebird::ITransaction* D__trans = NULL;
static Firebird::ITransaction* M__trans = NULL;
static int global_numbufs;	// # of cache buffers on connect
static Firebird::IStatement* global_Stmt = NULL;
static SCHAR Password[128];
static bool Merge_stderr;

static Firebird::GlobalPtr<Firebird::UCharBuffer> global_Buffer;
static bool Abort_flag = false;
static bool Interrupt_flag = false;
static Firebird::GlobalPtr<InputDevices> Filelist;
static int Pagelength = 20;
static bool Nodbtriggers = false; // No database triggers
static int Exit_value = 0;
static bool Interactive = true;
static bool Input_file = false;

static const char* DEFAULT_DML_TRANS_SQL = "SET TRANSACTION";
static Firebird::GlobalPtr<string> TranParams;

// Values used in the SET command.
// Initial options set exclusively from the command line are not included here.
class SetValues
{
public:
	SetValues()
	{
		//ColList global_Cols;
		global_Col_default = 0; // Need to write code for it in the future.
		Echo = false;
		Time_display = false;
		Sqlda_display = false;
		ExecPathDisplay[0] = 0;
		Stats = false;
		Autocommit = true;	// Commit ddl
		Warnings = true;	// Print warnings
		Doblob = 1;			// Default to printing only text types
		List = false;
		Docount = false;
		maxRows = 0;
		Plan = false;
		Planonly = false;
		ExplainPlan = false;
		AutoTerm = false;
		Heading = true;
		BailOnError = false;
		StmtTimeout = 0;
		KeepTranParams = true;
		TranParams->assign(DEFAULT_DML_TRANS_SQL);
		PerTableStats = false;
		WireStats = false;
		ExplainCommand = false;
	}

	ColList global_Cols;
	int global_Col_default;	// Need to write code for it in the future.
	bool Echo;
	bool Time_display;
	bool Sqlda_display;
	UCHAR ExecPathDisplay[10];
	bool Stats;
	bool Autocommit;	// Commit ddl
	bool Warnings;		// Print warnings
	int Doblob;			// Default to printing only text types
	bool List;
	bool Docount;
	size_t maxRows;
	bool Plan;
	bool Planonly;
	bool ExplainPlan;
	bool AutoTerm;
	bool Heading;
	bool BailOnError;
	unsigned int StmtTimeout;
	std::optional<QualifiedMetaString> ISQL_charset;
	bool KeepTranParams;
	bool PerTableStats;
	bool WireStats;
	bool ExplainCommand;
};

static SetValues setValues;


static bool Merge_diagnostic = false;
static FILE* Diag;
static FILE* Help;

static const TEXT* const sql_prompt = "SQL> ";

// Keep in sync with the chars that have their own "case" in the frontend lexer.
static const char FORBIDDEN_TERM_CHARS[] = { '\n', '-', '*', '/', SINGLE_QUOTE, DBL_QUOTE };
static const char FORBIDDEN_TERM_CHARS_DISPLAY[] = "<ENTER>, -, *, /, SINGLE_QUOTE, DOUBLE_QUOTE";

static bool global_psw = false;
static bool global_usr = false;
static bool global_role = false;
static bool global_search_path = false;
static bool has_global_numbufs = false;
static bool have_trans = false; // translation of word "Yes"
static TEXT yesword[BUFFER_LENGTH128];

// Didn't replace it by FB_SHORT_MONTHS because these are uppercased.
static const SCHAR* alpha_months[] =
{
	"JAN",
	"FEB",
	"MAR",
	"APR",
	"MAY",
	"JUN",
	"JUL",
	"AUG",
	"SEP",
	"OCT",
	"NOV",
	"DEC"
};

class PerTableStats
{
public:
	PerTableStats(Firebird::MemoryPool& pool) :
		m_initialized(false),
		m_stat(pool),
		m_relNames(pool)
	{}

	void getStats(Firebird::IAttachment* att, bool initial);
	void reset();

private:
	void printStats(Firebird::IAttachment* att);
	unsigned loadRelNames(Firebird::IAttachment* att);

	struct StatItem
	{
		StatItem() :
			relId(0),
			statId(0),
			value(0)
		{}

		StatItem(USHORT aRelId, UCHAR  aStatID) :
			relId(aRelId),
			statId(aStatID),
			value(0)
		{}

		USHORT relId;
		UCHAR  statId;
		SINT64 value;

		static bool greaterThan(const StatItem& i1, const StatItem& i2)
		{
			if (i1.relId < i2.relId)
				return false;

			if (i1.relId > i2.relId)
				return true;

			if (i1.statId <= i2.statId)
				return false;

			return true;
		}
	};

	using StatArray = Firebird::SortedArray<
		StatItem,
		Firebird::EmptyStorage<StatItem>,
		StatItem,
		Firebird::DefaultKeyValue<StatItem>,
		StatItem>;

	bool m_initialized;		// initial (before) stats loaded OK
	StatArray m_stat;
	RightPooledMap<USHORT, string> m_relNames;

	static const unsigned ITEM_COUNT = 8;
	static const unsigned char m_items[ITEM_COUNT + 1];
	static const char* m_itemNames[ITEM_COUNT];
};

static Firebird::GlobalPtr<PerTableStats> perTableStats;


class StatementGetter
{
public:
	StatementGetter()
	{
		// Lookup the continuation prompt once
		if (!*conPrompt)
			IUTILS_msg_get(CON_PROMPT, conPrompt);
	}

public:
	std::pair<FrontendLexer::SingleStatement, processing_state> getStatement();

	void rewind()
	{
		lexer.rewind();
	}

private:
	static TEXT conPrompt[MSG_LENGTH];
	FrontendLexer lexer;
};

TEXT StatementGetter::conPrompt[MSG_LENGTH] = "";


static UCHAR predefined_blob_subtype_bpb[] =
{
	isc_bpb_version1,
	isc_bpb_source_type, 1, 0,
	isc_bpb_target_type, 1, isc_blob_text
};

// No check on input argument for now.
inline void set_bpb_for_translation(const unsigned int blob_sub_type)
{
	predefined_blob_subtype_bpb[3] = (UCHAR) blob_sub_type;
}

// Note that these transaction options aren't understood in Version 3.3
static const UCHAR default_tpb[] =
{
	isc_tpb_version1, isc_tpb_write,
	isc_tpb_read_committed, isc_tpb_wait,
	isc_tpb_no_rec_version
};

#ifdef NOT_USED_OR_REPLACED
// CVC: Just in case we need it for R/O operations in the future.
static const UCHAR	batch_tpb[] =
{
	isc_tpb_version3, isc_tpb_read,
	isc_tpb_read_committed, isc_tpb_nowait,
	isc_tpb_rec_version
};
#endif

// If the action is restrict, do not print anything at all
static const ri_actions ri_actions_all[] =
{
	{RI_ACTION_CASCADE, RI_ACTION_CASCADE, "Cascade"},
	{RI_ACTION_NULL, RI_ACTION_NULL, "Set Null"},
	{RI_ACTION_DEFAULT, RI_ACTION_DEFAULT, "Set Default"},
	{RI_ACTION_NONE, RI_ACTION_NONE, "No Action"},
	{RI_RESTRICT, "", ""},
	{"", "", ""},
	{0, 0, 0}
};


static bool startTransaction(Firebird::ITransaction** t, unsigned len = 0, const UCHAR* tpb = NULL)
{
	if (DB && !*t)
	{
		*t = DB->startTransaction(fbStatus, len, tpb);
		if (ISQL_errmsg(fbStatus))
			return false;
	}

	return DB != NULL;
}

static bool M_Transaction()
{
	if (DB && !M__trans && setValues.KeepTranParams)
	{
		M__trans = DB->execute(fbStatus, nullptr,
							   TranParams->length(), TranParams->c_str(),
							   isqlGlob.SQL_dialect, nullptr, nullptr, nullptr, nullptr);

		if (ISQL_errmsg(fbStatus))
			return false;

		return DB != NULL;
	}
	return startTransaction(&M__trans);
}

static bool D_Transaction()
{
	return startTransaction(&D__trans, sizeof(default_tpb), default_tpb);
}

// Transaction for all frontend commands
static bool frontendTransaction()
{
	return startTransaction(&fbTrans);
}

static void atexit_fb_shutdown()
{
	fb_shutdown(0, fb_shutrsn_app_stopped);
}

int ISQL_main(int argc, char* argv[])
{
/**************************************
 *
 *	I S Q L _ m a i n
 *
 **************************************
 *
 * Functional description
 *	Choose between reading and executing or generating SQL
 *	ISQL_main isolates this from main for PC Clients.
 *
 **************************************/

#if defined(HAVE_EDITLINE_H) && defined(HAVE_LOCALE_H)
	setlocale(LC_CTYPE, "");
#endif
	atexit(&atexit_fb_shutdown);

	QualifiedMetaString tabname;

	// Initialize globals
	isqlGlob.major_ods = 0;
	isqlGlob.minor_ods = 0;
	isqlGlob.db_SQL_dialect = 0;
	isqlGlob.att_charset = 0;

	// Output goes to stdout by default
	isqlGlob.Out = stdout;
	isqlGlob.Errfp = stderr;

	const processing_state ret = parse_arg(argc, argv, tabname);

	// Can't do a simple assignment because parse_arg may set Interactive to false.
	if (stdin_redirected())
		Interactive = false;

	// Init the diagnostics and help files
	if (Merge_diagnostic)
	    Diag = isqlGlob.Out;
	else
		Diag = stdout;

	Help = stdout;

	if (Merge_stderr)
		isqlGlob.Errfp = isqlGlob.Out;

	switch (ret)
	{
	case EXTRACT:
	case EXTRACTALL:
		if (*isqlGlob.global_Db_name)
		{
			Interactive = false; // "extract" option only can be called from command-line

			// Let's use user and password if provided.
			// This should solve bug #112263 FSG 28.Jan.2001
			if (newdb(isqlGlob.global_Db_name, isqlGlob.User, Password, global_numbufs,
				isqlGlob.Role, false) == SKIP)
			{
				LegacyTables flag = ret == EXTRACT ? SQL_objects : ALL_objects;
				Exit_value = EXTRACT_ddl(flag, tabname);
				ISQL_disconnect_database(true);
			}
			else
				Exit_value = FINI_ERROR;
		}
		break;

	case ps_ERR:
	    {
			TEXT helpstring[158];
			IUTILS_msg_get(USAGE, sizeof(helpstring), helpstring);
			STDERROUT(helpstring);
			for (FB_SIZE_T i = 0; i < FB_NELEM(isql_in_sw_table); i++)
			{
				if (isql_in_sw_table[i].in_sw_msg > 0)
				{
					IUTILS_msg_get(isql_in_sw_table[i].in_sw_msg, sizeof(helpstring), helpstring);
					STDERROUT(helpstring);
				}
			}
			Exit_value = FINI_ERROR;
			break;
		}

	default:
		do_isql();
		// keep Exit_value to whatever it is set
		// by do_isql()
		// Exit_value = FINI_OK;
		break;
	}
#ifdef DEBUG_GDS_ALLOC
	// As ISQL can run under windows, all memory should be freed before
	// returning.  In debug mode this call will report unfreed blocks.

	//gds_alloc_report(0 ALLOC_ARGS);
	char fn[] = __FILE__;
	fn[strlen(fn) - 8] = 0; // all isql files in gen dir
	gds_alloc_report(0, fn, 0);
#endif

	return Exit_value;
}


void ISQL_array_dimensions(const QualifiedMetaString& fieldname)
{
/**************************************
 *
 *	I S Q L _ a r r a y _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 *	Retrieves the dimensions of arrays and prints them.
 *
 *	Parameters:  fieldname -- the actual name of the array field
 *
 **************************************/

	isqlGlob.printf("[");

	if (!frontendTransaction())
		return;

	FOR FDIM IN RDB$FIELD_DIMENSIONS
		WITH FDIM.RDB$SCHEMA_NAME EQUIV NULLIF(fieldname.schema.c_str(), '') AND
			 FDIM.RDB$FIELD_NAME EQ fieldname.object.c_str()
		SORTED BY FDIM.RDB$DIMENSION
	{
		// Format is [lower:upper, lower:upper,..]
		// When lower == 1 no need to print a range. Done.
		// When upper == 1 no need to print a range either, but it's confusing. Not done.

		if (FDIM.RDB$DIMENSION > 0) {
			isqlGlob.printf(", ");
		}
		if (FDIM.RDB$LOWER_BOUND == 1)
			isqlGlob.printf("%ld", FDIM.RDB$UPPER_BOUND);
		else
			isqlGlob.printf("%ld:%ld", FDIM.RDB$LOWER_BOUND, FDIM.RDB$UPPER_BOUND);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR

	isqlGlob.printf("]");
}



bool ISQL_dbcheck()
{
/**************************************
 *
 *	I S Q L _ d b c h e c k
 *
 **************************************
 *
 * Functional description
 *	Check to see if we are connected to a database.
 *  	Return true if connected, false otherwise
 *
 * Change from miroslavp on 2005.04.25
 *   Value assigned here on Exit_value is not used anywhere in the source
 *   and cause isql.exe to return 1 in Quiet mode even there is no error.
 *   If there is error Exit_value is set by callers - so it is removed from here.
 **************************************/
	TEXT errbuf[MSG_LENGTH];

	if (!(DB && isqlGlob.global_Db_name[0]))
	{
		if (!Quiet)
		{
			IUTILS_msg_get(NO_DB, errbuf);
			STDERROUT(errbuf);
		}
		return false;
	}

	return true;
}

static char userPrompt2[MSG_LENGTH];
static const char* const userPrompt = userPrompt2;
static char* lastInputLine = NULL;
static int getColumn = -1;



void ISQL_prompt(const TEXT* string)
{
/**************************************
 *
 *	I S Q L _ p r o m p t
 *
 **************************************
 *
 * Functional description
 *	Print a prompt string for interactive user
 *	Not for Windows, otherwise flush the string
 **************************************/
	//userPrompt = (const char*) string;
	fb_utils::copy_terminate(userPrompt2, string, MSG_LENGTH);

	//#ifndef HAVE_READLINE_READLINE_H
	//	fprintf(stdout, userPrompt.c_str());
	//	fflush(stdout);
	//#endif

}

static void readNextInputLine(const char* prompt)
{
/**************************************
 *
 *	r e a d N e x t I n p u t L i n e
 *
 **************************************
 *
 * Functional description
 *  Get next input line and put it in lastInputLine
 *  If the first read is EOF set lineInputLine to NULL
 *  Otherwise return the line up to EOF (excluded) or '\n' (included)
 * WARNING: If you bypass getNextInputChar() and call this directly,
 * remember to set getColumn = -1; immediately after calling this function
 * to avoid side effects or reading invalid memory locations.
 **************************************/

	if (lastInputLine != NULL)
	{
		free(lastInputLine);
		lastInputLine = NULL;
	}

	getColumn = 0;

#ifdef HAVE_EDITLINE_H
	if (Filelist->readingStdin())
	{
		// CVC: On 2005-04-02, use an empty prompt when not working in
		// interactive mode to behave like @@@ below at request by Pavel.
		const char* new_prompt = Interactive ? prompt : "";
		lastInputLine = readline(new_prompt);

		if (lastInputLine != NULL && strlen(lastInputLine) != 0) {
			add_history(lastInputLine);
		}
		// Let's count lines if someone wants to enable line number error messages
		// for console reading for whatever reason.
		++Filelist->Ifp().indev_aux;
		return;
	}

#endif
	// @@@ CVC: On 2005-04-02, take the "|| Echo" out at request by Pavel.
	if (Interactive && !Input_file)// || setValues.Echo)
	{
		// Write the prompt out.
		fprintf(stdout, "%s", prompt);
		fflush(stdout);
	}

	string line;
	bool end = false;

	do
	{
		// Read the line
		char buffer[MAX_USHORT];
		int lineSize;

#ifdef WIN_NT
		if (!Input_file && isatty(fileno(Filelist->Ifp().indev_fpointer)))
			lineSize = win32ReadConsole(Filelist->Ifp().indev_fpointer, buffer, sizeof(buffer));
		else
#endif
		{
			if (fgets(buffer, sizeof(buffer), Filelist->Ifp().indev_fpointer) != NULL)
				lineSize = strlen(buffer);
			else
				lineSize = -1;
		}

		if (lineSize > 0)
		{
			// If the last non empty line doesn't end in '\n', indev_aux won't be
			// updated, but then there're no more commands, so it's irrelevant.
			while (lineSize > 0 &&
				   (buffer[lineSize - 1] == '\n' || buffer[lineSize - 1] == '\r'))
			{
				buffer[--lineSize] = '\0';
				++Filelist->Ifp().indev_aux;
				end = true;
			}

			line.append(buffer, lineSize);
		}
		else if (line.isEmpty())
			return;
		else
			end = true;
	} while (!end);

	lastInputLine = (char*) malloc(line.length() + 1);
	memcpy(lastInputLine, line.c_str(), line.length() + 1);
}

static void readNextInputLine()
{
	readNextInputLine(userPrompt);
	if (setValues.Echo && (lastInputLine != NULL)) {
		isqlGlob.printf("%s%s", lastInputLine, NEWLINE);
	}
}

int getNextInputChar()
{
/**************************************
 *
 *	g e t N e x t I n p u t C h a r
 *
 **************************************
 *
 * Functional description
 *	Read next char from input
 *
 *
 **************************************/
	static int inputLen = 0;
	// At end of line try and read next line
	if (getColumn == -1)
	{
		readNextInputLine();
		if (lastInputLine)
			inputLen = (int) strlen(lastInputLine);
	}

	// readline found EOF
	if (lastInputLine == NULL) {
		return EOF;
	}

	// If at end of line return \n
	if (getColumn == inputLen) //(int) strlen(lastInputLine))
	{
		getColumn = -1;
		return '\n';
	}
    // cast to unsigned char to prevent sign expansion
    // this way we can distinguish russian ya (0xFF) and EOF (usually (-1))
	return (unsigned char)lastInputLine[getColumn++];
}


bool ISQL_errmsg(Firebird::IStatus* st)
{
/**************************************
 *
 *	I S Q L _ e r r m s g
 *
 **************************************
 *
 * Functional description
 *	Report error conditions
 *	Simulate isc_print_status exactly, to control stderr
 **************************************/
	TEXT errbuf[MSG_LENGTH];
	const ISC_STATUS* const status = st->getErrors();

	const unsigned state = st->getState();
	if (Quiet && (state & Firebird::IStatus::STATE_ERRORS))
		Exit_value = FINI_ERROR;
	//else
	{
		const ISC_STATUS* vec = status;
		if (vec[0] != isc_arg_gds)
			return false;

		if (!(state & Firebird::IStatus::STATE_ERRORS) &&
			(!(state & Firebird::IStatus::STATE_WARNINGS) || !setValues.Warnings))
		{
			return false;
		}

		if (state & Firebird::IStatus::STATE_ERRORS)
		{
			FB_SQLSTATE_STRING sqlstate;
			fb_sqlstate(sqlstate, status);
			IUTILS_msg_get(GEN_ERR, errbuf, SafeArg() << sqlstate);
			STDERROUT(errbuf);
			TEXT* err = errbuf;
			unsigned es = sizeof(errbuf);
			if (fb_interpret(err, es, &vec))
			{
				STDERROUT(errbuf);

				// Continuation of error
				*err++ = '-';
				--es;
				while (fb_interpret(err, es, &vec))
					STDERROUT(errbuf);
			}
		}

		if (Input_file)
		{
			// This must be done before call ISQL_warning, as it init the status object.

			int linenum = -1;
			if (status[0] == isc_arg_gds && status[1] == isc_dsql_error &&
				status[2] == isc_arg_gds && status[3] == isc_sqlerr && vec > &status[9])
			{
				switch (status[7])
				{
				case isc_dsql_field_err:
				case isc_dsql_procedure_err:
				case isc_dsql_relation_err:
				case isc_dsql_procedure_use_err:
				case isc_dsql_no_dup_name:
					vec = &status[8];
					while (*vec++ != isc_arg_end)
						if (vec[0] == isc_dsql_line_col_error && vec[1] == isc_arg_number)
						{
							linenum  = vec[2];
							//STDERROUT(s);
							break;
						}
					break;
				case isc_dsql_token_unk_err:
					if (status[8] == isc_arg_number)
					{
						linenum = status[9];
						//s = errbuf;
						//STDERROUT(s);
					}
					break;
				}
			}
			/* CVC: Obsolete on 2005.10.06 because now line & column are numeric arguments.
			if (s)
			{
				while (*s && !fb_isdigit(*s))
					++s;
				if (isdigit(*s))
				{
					linenum = 0;
					for (; *s && isdigit(*s); ++s)
						linenum = linenum * 10 + *s - '0';
				}
			}
			*/
			const InputDevices::indev& Ifp = Filelist->Ifp();
			if (linenum != -1)
			{
				linenum += Ifp.indev_line;
				IUTILS_msg_get(EXACTLINE, errbuf, SafeArg() << linenum << Ifp.fileName(true).c_str());
			}
			else
                IUTILS_msg_get(AFTERLINE, errbuf, SafeArg() << Ifp.indev_line << Ifp.fileName(true).c_str());

			ISQL_warning(st);

			STDERROUT(errbuf);
		}
		else
			ISQL_warning(st);
	}

	return (state & Firebird::IStatus::STATE_ERRORS);
}


void ISQL_warning(Firebird::IStatus* st)
{
/**************************************
 *
 *	I S Q L _ w a r n i n g
 *
 **************************************
 *
 * Functional desription
 *	Report warning
 *	Simulate isc_print_status exactly, to control stderr
 **************************************/

	if ((st->getState() & Firebird::IStatus::STATE_WARNINGS) && setValues.Warnings)
	{
		const ISC_STATUS* vec = st->getWarnings();
		TEXT buf[MSG_LENGTH];
		if (fb_interpret(buf, sizeof(buf), &vec))
		{
			STDERROUT(buf);

			// Continuation of warning
			buf[0] = '-';
			while (fb_interpret(buf + 1, sizeof(buf) - 1, &vec)) {
				STDERROUT(buf);
			}
		}
	}

	st->init();
}


SSHORT ISQL_get_default_char_set_id()
{
/*************************************
*
*	I S Q L _ g e t _ d e f a u l t _ c h a r _ s e t _ i d
*
**************************************
*
* Functional description
*	Return the database default character set
*	id.
*
*	-1 if the value can not be determined.
*
**************************************/

/* What is the default character set for this database?
   There are three states:
   1.	There is no entry available in RDB$DATABASE
	Then - NONE
   2.   The entry in RDB$DATABASE does not exist in
	RDB$CHARACTER_SETS
	Then - -1 to cause all character set defs to show
   3.	An entry in RDB$CHARACTER_SETS
	Then - RDB$CHARACTER_SET_ID
*/
	SSHORT default_char_set_id = 0;
	FOR FIRST 1 EXT IN RDB$DATABASE
		WITH EXT.RDB$CHARACTER_SET_NAME NOT MISSING;

		default_char_set_id = -1;

		FOR FIRST 1 CHI IN RDB$CHARACTER_SETS
		WITH CHI.RDB$CHARACTER_SET_NAME = EXT.RDB$CHARACTER_SET_NAME

			default_char_set_id = CHI.RDB$CHARACTER_SET_ID;

		END_FOR;
	END_FOR;

	return (default_char_set_id);
}


SSHORT ISQL_get_field_length(const QualifiedMetaString& field_name)
{
/**************************************
 *
 *	I S Q L _ g e t _ f i e l d _ l e n g t h
 *
 **************************************
 *
 *	Retrieve character or field length of character types.
 *
 **************************************/

	if (!frontendTransaction())
		return 0;

	SSHORT l = 0;

	FOR FLD IN RDB$FIELDS
		WITH FLD.RDB$SCHEMA_NAME EQUIV NULLIF(field_name.schema.c_str(), '') AND
			 FLD.RDB$FIELD_NAME EQ field_name.object.c_str()
	{
		if (FLD.RDB$CHARACTER_LENGTH.NULL)
			l = FLD.RDB$FIELD_LENGTH;
		else
			l = FLD.RDB$CHARACTER_LENGTH;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return 0;
	END_ERROR

	return l;
}


SSHORT ISQL_get_char_length(
	SSHORT fieldLength,
	SSHORT characterLengthNull, SSHORT characterLength,
	SSHORT characterSetIdNull, SSHORT characterSetId)
{
	if (characterLengthNull || characterLength == 0)
	{
		if (!characterSetIdNull)
		{
			FOR CS IN RDB$CHARACTER_SETS
				WITH CS.RDB$CHARACTER_SET_ID EQ characterSetId AND
					 CS.RDB$BYTES_PER_CHARACTER > 0
			{
				fieldLength /= CS.RDB$BYTES_PER_CHARACTER;
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
			END_ERROR;
		}

		return fieldLength;
	}
	else
		return characterLength;
}


bool ISQL_get_character_sets(SSHORT char_set_id, SSHORT collation,
							 SSHORT default_char_set_id, Get what,
							 bool not_null, string& text)
{
/**************************************
 *
 *	I S Q L _ g e t _ c h a r a c t e r _ s e t s
 *
 **************************************
 *
 *	Retrieve character set and collation order and format it
 *
 **************************************/
#ifdef	DEV_BUILD
	bool found = false;
#endif

	const char* notNullStr = not_null ? " NOT NULL" : "";
	text.clear();

	if (!frontendTransaction())
		return false;

	FOR FIRST 1
		COL IN RDB$COLLATIONS CROSS
		CST IN RDB$CHARACTER_SETS
		WITH COL.RDB$CHARACTER_SET_ID EQ CST.RDB$CHARACTER_SET_ID AND
			 COL.RDB$COLLATION_ID EQ collation AND
			 CST.RDB$CHARACTER_SET_ID EQ char_set_id
		SORTED BY COL.RDB$COLLATION_NAME, CST.RDB$CHARACTER_SET_NAME
	{
#ifdef DEV_BUILD
		found = true;
#endif

		const QualifiedMetaString charSetName(CST.RDB$CHARACTER_SET_NAME, CST.RDB$SCHEMA_NAME);
		const QualifiedMetaString collationName(COL.RDB$COLLATION_NAME, COL.RDB$SCHEMA_NAME);
		const QualifiedMetaString defaultCollateName(
			CST.RDB$DEFAULT_COLLATE_NAME, CST.RDB$DEFAULT_COLLATE_SCHEMA_NAME);

		const bool charsetIsDefault = char_set_id == default_char_set_id;
		const bool collationIsDefault = defaultCollateName == collationName;

		switch (what)
		{
		case Get::CHARSET_ONLY:
			// Charset is printed if it is not default one
			// or if collation is not default to preserve stability of output script
			// Because otherwise it would fail with "collation not found for character set" error
			// if global default charset has been changed.
			if (!charsetIsDefault || !collationIsDefault)
			{
				text.printf(" CHARACTER SET %s%s", IUTILS_name_to_string(charSetName).c_str(), notNullStr);
				return true;
			}
			break;

		case Get::COLLATE_ONLY:
			// Default colation is not printed to allow easy global change
			if (!collationIsDefault)
			{
				text.printf("%s COLLATE %s%s", notNullStr, IUTILS_name_to_string(collationName).c_str());
				return true;
			}
			break;

		case Get::BOTH:
			// If they both are default - suppress output completely
			if (!charsetIsDefault || !collationIsDefault)
			{
				if (collationIsDefault) // Suppress collation only
					text.printf(" CHARACTER SET %s%s", IUTILS_name_to_string(charSetName).c_str(), notNullStr);
				else
				{
					text.printf(
						" CHARACTER SET %s%s COLLATE %s",
						IUTILS_name_to_string(charSetName).c_str(),
						notNullStr,
						IUTILS_name_to_string(collationName).c_str());
				}
				return true;
			}
			break;
		}

		// No need to write charset or collation but still must print "NOT NULL"
		if (not_null)
			text.printf("%s", notNullStr);
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return text.hasData();
	END_ERROR

#ifdef DEV_BUILD
	if (!found)
	{
		TEXT Print_buffer[PRINT_BUFFER_LENGTH];
		sprintf(Print_buffer,
				"ISQL_get_character_set: charset %d collation %d not found.\n",
				char_set_id, collation);
		STDERROUT(Print_buffer);
	}
#endif

	return text.hasData();
}


inline static bool failed()
{
	return (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS);
}


inline static bool succeeded()
{
	return !failed();
}


processing_state ISQL_fill_var(IsqlVar* var,
							   Firebird::IMessageMetadata* msg,
							   unsigned index,
							   UCHAR* buf)
{
	var->field = msg->getField(fbStatus, index);		if (failed()) return ps_ERR;
	var->relation = msg->getRelation(fbStatus, index);	if (failed()) return ps_ERR;
	var->owner = msg->getOwner(fbStatus, index);		if (failed()) return ps_ERR;
	var->alias = msg->getAlias(fbStatus, index);		if (failed()) return ps_ERR;
	var->subType = msg->getSubType(fbStatus, index);	if (failed()) return ps_ERR;
	var->scale = msg->getScale(fbStatus, index);		if (failed()) return ps_ERR;
	var->type = msg->getType(fbStatus, index);			if (failed()) return ps_ERR;
	var->length = msg->getLength(fbStatus, index);		if (failed()) return ps_ERR;
	var->charSet = msg->getCharSet(fbStatus, index);	if (failed()) return ps_ERR;
	var->nullable = msg->isNullable(fbStatus, index);	if (failed()) return ps_ERR;

	if (buf)
	{
		var->nullInd = (short*) &buf[msg->getNullOffset(fbStatus, index)];	if (failed()) return ps_ERR;
		var->value.setPtr = &buf[msg->getOffset(fbStatus, index)];			if (failed()) return ps_ERR;
	}
	else
	{
		var->nullInd = 0;
		var->value.setPtr = 0;
	}

	return CONT;
}


// Check if statement ends with single-line comment.
bool ISQL_statement_ends_in_comment(const char* statement)
{
	const char* const statementStart = statement;
	const char* commentStart = nullptr;
	const char* commentEnd = nullptr;
	char altQuoteChar = '\0';

	enum
	{
		normal,
		in_single_line_comment,
		in_block_comment,
		in_single_quoted_string,
		in_double_quoted_string
	} state = normal;

	while (char c = *statement++)
	{
		char lastChar = statement - 1 == statementStart ? '\0' : statement[-2];

		switch (c)
		{
			case '\n':
				if (state == in_single_line_comment)
					state = normal;
				break;

			case '-':
				// Could this the be start of a single-line comment.
				if (state == normal && lastChar == '-')
					state = in_single_line_comment;
				break;

			case '*':
				// Could this the be start of a comment. We can only look back, not forward.
				// Ignore possibilities of a comment beginning inside quoted strings.
				if (state == normal && lastChar == '/' && statement - commentEnd > 3)
				{
					state = in_block_comment;
					commentStart = statement - 2;
				}
				break;

			case '/':
				// Perhaps this is the end of a comment.
				// Ignore possibilities of a comment ending inside quoted strings.
				// Ignore things like /*/ since it isn't a block comment; only the start of it. Or end.
				if (state == in_block_comment && lastChar == '*' && statement - commentStart > 3)
				{
					state = normal;
					commentEnd = statement - 2;	// mark start of non-comment to track this: /**/*
				}
				break;

			case SINGLE_QUOTE:
				switch (state)
				{
					case normal:
						if (lastChar == 'q' || lastChar == 'Q')
						{
							if (!(altQuoteChar = *statement++))
								return false;

							switch (altQuoteChar)
							{
								case '{':
									altQuoteChar = '}';
									break;
								case '(':
									altQuoteChar = ')';
									break;
								case '[':
									altQuoteChar = ']';
									break;
								case '<':
									altQuoteChar = '>';
									break;
							}
						}
						else
							altQuoteChar = '\0';

						state = in_single_quoted_string;
						break;

					case in_single_quoted_string:
						if (!altQuoteChar || lastChar == altQuoteChar)
							state = normal;
						break;
				}
				break;

			case DBL_QUOTE:
				switch (state)
				{
					case normal:
						state = in_double_quoted_string;
						break;
					case in_double_quoted_string:
						state = normal;
						break;
				}
				break;

			default:
				break;
		}
	}

	return state == in_single_line_comment;
}


void ISQL_get_domain_default_source(const QualifiedMetaString& fieldName, ISC_QUAD* blobId)
{
/**************************************
 *
 *	I S Q L _ g e t _ d o m a i n _ d e f a u l t _ s o u r c e
 *
 **************************************
 *
 *	Retrieve the default source of a field.
 *
 **************************************/

	*blobId = fbBlobNull;

	if (!frontendTransaction())
		return;

	FOR FLD IN RDB$FIELDS
		WITH FLD.RDB$SCHEMA_NAME EQUIV NULLIF(fieldName.schema.c_str(), '') AND
			 FLD.RDB$FIELD_NAME EQ fieldName.object.c_str()
	{
		if (!FLD.RDB$DEFAULT_SOURCE.NULL)
			*blobId = FLD.RDB$DEFAULT_SOURCE;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR
}


SLONG ISQL_get_index_segments(TEXT* segs,
								const size_t buf_size,
								const QualifiedMetaString& indexname)
{
/**************************************
 *
 *	I S Q L _ g e t _ i n d e x _ s e g m e n t s
 *
 **************************************
 *
 * Functional description
 *	returns the list of columns in an index.
 *
 **************************************/
	TEXT SQL_identifier[BUFFER_LENGTH256];

	*segs = '\0';

	if (!frontendTransaction())
		return 0;

	TEXT* const segs_end = segs + buf_size - 1;
	// Query to get column names
	SLONG n = 0;
	bool count_only = false;

	FOR SEG IN RDB$INDEX_SEGMENTS
		WITH SEG.RDB$SCHEMA_NAME EQUIV NULLIF(indexname.schema.c_str(), '') AND
			 SEG.RDB$INDEX_NAME EQ indexname.object.c_str()
		SORTED BY SEG.RDB$FIELD_POSITION
	{
		++n;
		if (count_only)
			continue;

		// Place a comma and a blank between each segment column name

		const auto fieldNameStr = IUTILS_name_to_string(SEG.RDB$FIELD_NAME);
		const auto fieldNameStrLen = fieldNameStr.length();

		if (n == 1)
		{
			// We assume the buffer is at least size(metadata name), so no initial check.
			strcpy(segs, fieldNameStr.c_str());
			segs += fieldNameStrLen;
		}
		else
		{
			if (segs + fieldNameStrLen + 2 >= segs_end)
			{
				strncpy(segs, ", ...", segs_end - segs);
				*segs_end = '\0';
				count_only = true;
			}
			else
			{
				sprintf(segs, ", %s", fieldNameStr.c_str());
				segs += fieldNameStrLen + 2;
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		ROLLBACK;
		return 0;
	END_ERROR

	return n;
}


bool ISQL_get_base_column_null_flag(const QualifiedMetaString& view_name,
									const SSHORT view_context,
									const MetaString& base_field)
{
/**************************************
 *
 *	I S Q L _ g e t _ b a s e _ c o l u m n _ n u l l _ f l a g
 *
 **************************************
 *
 *	Determine if a field on which view column is based
 *	is nullable. We are passed the view_name
 *	view_context and the base_field of the view column.
 *
 **************************************/
	QualifiedMetaString save_view_name(view_name);
	MetaString save_base_field(base_field);

	SSHORT save_view_context = view_context;

	if (!frontendTransaction())
		return false;

	/*
	Using view_name and view_context get the relation name from
	RDB$VIEW_RELATIONS which contains the base_field for this view column.
	Get row corresponding to this base field and relation from
	rdb$field_relations. This will contain info on field's nullability unless
	it is a view column itself, in which case repeat this procedure till
	we get to a "real" column.
	*/
	bool null_flag = true;
	bool done = false;
	bool error = false;
	while (!done && !error)
	{
		bool found = false;
		FOR FIRST 1
			VR IN RDB$VIEW_RELATIONS
			CROSS NEWRFR IN RDB$RELATION_FIELDS
			WITH VR.RDB$SCHEMA_NAME EQUIV NULLIF(save_view_name.schema.c_str(), '') AND
				 VR.RDB$VIEW_NAME EQ save_view_name.object.c_str() AND
				 VR.RDB$VIEW_CONTEXT EQ save_view_context AND
				 NEWRFR.RDB$SCHEMA_NAME EQUIV VR.RDB$RELATION_SCHEMA_NAME AND
				 NEWRFR.RDB$RELATION_NAME = VR.RDB$RELATION_NAME AND
				 NEWRFR.RDB$FIELD_NAME = save_base_field.c_str()
		{
			found = true;
			if (NEWRFR.RDB$BASE_FIELD.NULL)
			{
				if (!NEWRFR.RDB$NULL_FLAG.NULL && NEWRFR.RDB$NULL_FLAG == 1)
					null_flag = false;

				done = true;
			}
			else
			{
				save_view_name = QualifiedMetaString(NEWRFR.RDB$RELATION_NAME, NEWRFR.RDB$SCHEMA_NAME);
				save_view_context = NEWRFR.RDB$VIEW_CONTEXT;
				save_base_field = NEWRFR.RDB$BASE_FIELD;
			}
		}
		END_FOR
		ON_ERROR
			error = true;
		END_ERROR

		if (!found)
		{
			if (isqlGlob.major_ods >= ODS_VERSION12)
			{
				// Copy/paste from DYN_UTIL_find_field_source
				FOR FIRST 1
					VRL IN RDB$VIEW_RELATIONS CROSS
					PPR IN RDB$PROCEDURE_PARAMETERS
					WITH VRL.RDB$RELATION_SCHEMA_NAME EQUIV PPR.RDB$SCHEMA_NAME AND
						 VRL.RDB$RELATION_NAME EQ PPR.RDB$PROCEDURE_NAME AND
						 VRL.RDB$SCHEMA_NAME EQUIV NULLIF(save_view_name.schema.c_str(), '') AND
						 VRL.RDB$VIEW_NAME EQ save_view_name.object.c_str() AND
						 VRL.RDB$VIEW_CONTEXT EQ save_view_context AND
						 VRL.RDB$CONTEXT_TYPE EQ VCT_PROCEDURE AND
						 PPR.RDB$PACKAGE_NAME EQUIV VRL.RDB$PACKAGE_NAME AND
						 PPR.RDB$PARAMETER_NAME EQ save_base_field.c_str() AND
						 PPR.RDB$PARAMETER_TYPE = 1 // output
				{
					found = true;
					if (!PPR.RDB$NULL_FLAG.NULL && PPR.RDB$NULL_FLAG == 1)
						null_flag = false;

					done = true;
				}
				END_FOR
				ON_ERROR
					error = true;
				END_ERROR
			}
			else if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_2)
			{
				FOR FIRST 1
					VR IN RDB$VIEW_RELATIONS
					CROSS NEWPP IN RDB$PROCEDURE_PARAMETERS
					WITH VR.RDB$SCHEMA_NAME EQUIV NULLIF(save_view_name.schema.c_str(), '') AND
						 VR.RDB$VIEW_NAME EQ save_view_name.object.c_str() AND
						 VR.RDB$VIEW_CONTEXT EQ save_view_context AND
						 NEWPP.RDB$SCHEMA_NAME EQUIV VR.RDB$RELATION_SCHEMA_NAME AND
						 NEWPP.RDB$PROCEDURE_NAME = VR.RDB$RELATION_NAME AND
						 NEWPP.RDB$PARAMETER_NAME = save_base_field.c_str() AND
						 NEWPP.RDB$PARAMETER_TYPE = 1 // output param
				{
					found = true;
					if (!NEWPP.RDB$NULL_FLAG.NULL && NEWPP.RDB$NULL_FLAG == 1)
						null_flag = false;

					done = true;
				}
				END_FOR
				ON_ERROR
					error = true;
				END_ERROR
			}
		}

		if (!found)
			error = true;
	}

	// The error shouldn't be masked here. It should be propagated.
	return null_flag;
}

bool ISQL_get_null_flag(const QualifiedMetaString& rel_name,
						const MetaString& field_name)
{
/**************************************
 *
 *	I S Q L _ g e t _ n u l l _ f l a g
 *
 **************************************
 *
 *	Determine if a field has the null flag set.
 *	Look for either rdb$relation_fields or rdb$fields to be
 *	Set to 1 (NOT NULL), then this field cannot be null
 *	We are passed the relation name and the relation_field name
 *  	For domains, the relation name is null.
 **************************************/
	bool null_flag = true;

	if (!frontendTransaction())
		return false;

	FOR FLD IN RDB$FIELDS CROSS
		RFR IN RDB$RELATION_FIELDS
		WITH RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQUIV FLD.RDB$SCHEMA_NAME AND
			 RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
			 RFR.RDB$SCHEMA_NAME EQUIV NULLIF(rel_name.schema.c_str(), '') AND
			 RFR.RDB$RELATION_NAME EQ rel_name.object.c_str() AND
			 RFR.RDB$FIELD_NAME EQ field_name.c_str()
	{
		if (!FLD.RDB$NULL_FLAG.NULL && FLD.RDB$NULL_FLAG == 1)
			null_flag = false;
		else
		{

			// If RDB$BASE_FIELD is not null then it is a view column

			if (RFR.RDB$BASE_FIELD.NULL)
			{

				// Simple column. Did user define it not null?

				if (!RFR.RDB$NULL_FLAG.NULL && RFR.RDB$NULL_FLAG == 1)
					null_flag = false;
			}
			else
			{
				null_flag = ISQL_get_base_column_null_flag(rel_name,
					RFR.RDB$VIEW_CONTEXT, RFR.RDB$BASE_FIELD);
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return null_flag;
	END_ERROR

	return null_flag;
}


void ISQL_disconnect_database(bool nQuietMode)
 {
/**************************************
 *
 *	I S Q L _ d i s c o n n e c t _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Disconnect from the current database.  First commit work and then
 *	call detach to detach from the database and then zero
 *	out the DB handle.
 *
 * Change from miroslavp on 2005.05.06
 * Quiet global variable is preserved in local variable and restored at the end.
 **************************************/

	const bool OriginalQuiet = Quiet;
	// Ignore error msgs during disconnect
	Quiet = nQuietMode;

	// If we were in a database, commit before proceeding
	if (DB && (M__trans || D__trans))
		end_trans();

	// Commit transaction that was started on behalf of the request
	// Don't worry about the error if one occurs it will be network
	// related and caught later.
	if (DB && fbTrans)
	{
		fbTrans->rollback(fbStatus);
		if (succeeded())
			fbTrans = NULL;
	}

	// If there is  current user statement, free it
	if (global_Stmt)
	{
		global_Stmt->free(fbStatus);
		if (succeeded())
			global_Stmt = NULL;
	}

	// Detach from old database
	if (DB)
	{
		DB->detach(fbStatus);
		if (succeeded())
			DB = NULL;
	}

	// Restore original value of the flag
	Quiet = OriginalQuiet;

	// Zero database handle and transaction handles
	global_Stmt = NULL;
	DB = NULL;
	isqlGlob.global_Db_name[0] = '\0';
	D__trans = NULL;
	M__trans = NULL;
	fbTrans = NULL;

	// CVC: If we aren't connected to a db anymore, then the db's dialect is reset.
	// This should fix SF Bug #910430.
	isqlGlob.db_SQL_dialect = 0;
	// BRS this is also needed to fix #910430.
	global_dialect_spoken = 0;
	return;
}


// Print the numeric type as accurately as possible, depending on the ODS.
// If it isn't numeric/decimal or is another non-numeric data type, print only the type.
bool ISQL_printNumericType(const QualifiedMetaString& fieldName, const int fieldType, const int fieldSubType,
	const int fieldPrecision, const int fieldScale)
{
	// Look through types array
	int i = 0;
	while (Column_types[i].type && fieldType != Column_types[i].type)
		++i;

	fb_assert(Column_types[i].type != 0);
	if (Column_types[i].type == 0)
	{
		isqlGlob.printf("Unknown data type %d for field name %s%s", fieldType,
			IUTILS_name_to_string(fieldName).c_str(),
			NEWLINE);
		return false;
	}

	switch (fieldType)
	{
	case blr_short:
	case blr_long:
	case blr_int64:
	case blr_double:
	case blr_int128:
		// Handle Integral subtypes NUMERIC and DECIMAL
		// We are ODS >= 10 and could be any Dialect

		// We are Dialect >=3 since FIELD_PRECISION is non-NULL
		if (isqlGlob.major_ods >= ODS_VERSION10 &&
			fieldPrecision != 0 &&
			fieldType != blr_double &&
			fieldSubType > 0 && fieldSubType <= MAX_INTSUBTYPES)
		{
			isqlGlob.printf("%s(%d, %d)",
				Integral_subtypes[fieldSubType],
				fieldPrecision,
				-fieldScale);
		}
		else
		{
			if (fieldScale < 0)
			{
				// Take a stab at numerics and decimals
				switch (fieldType)
				{
				case blr_short:
					isqlGlob.printf("NUMERIC(4, %d)", -fieldScale);
					break;
				case blr_long:
					isqlGlob.printf("NUMERIC(9, %d)", -fieldScale);
					break;
				case blr_int64:
					isqlGlob.printf("NUMERIC(18, %d)", -fieldScale);
					break;
				case blr_double:
					isqlGlob.printf("NUMERIC(15, %d)", -fieldScale);
					break;
				case blr_int128:
					isqlGlob.printf("NUMERIC(38, %d)", -fieldScale);
					break;
				}
			}
			else
			{
				break;
			}
		}
		return true;
	case blr_text:
		if (fieldSubType >= 0 && fieldSubType <= MAX_TEXTSUBTYPES)
		{
			isqlGlob.printf("%s", Text_subtypes[fieldSubType]);
			return true;
		}
		break;
	case blr_varying:
		if (fieldSubType >= 0 && fieldSubType <= MAX_VARYINGSUBTYPES)
		{
			isqlGlob.printf("%s", Varying_subtypes[fieldSubType]);
			return true;
		}
		break;
	}

	// Field type without recognizable subtypes
	isqlGlob.printf("%s", Column_types[i].type_name);

	return true;
}


void ISQL_print_validation(FILE* fp,
						   ISC_QUAD* blobid,
						   bool isComputedField,
						   Firebird::ITransaction* trans)
{
/**************************************
 *
 *	I S Q L _ p r i n t _ v a l i d a t i o n
 *
 **************************************
 *
 * Functional description
 *	This does some minor syntax adjustmet for extracting
 *	validation blobs and computed fields.
 *	if it does not start with the word CHECK
 *	if this is a computed field blob, look for () or insert them.
 *	if flag == false, this is a validation clause,
 *	if flag == true, this is a computed field
 *
 **************************************/
	// Don't bother with null blobs

	if (blobid->gds_quad_high == 0 || !DB)
		return;

	Firebird::IBlob* blob = DB->openBlob(fbStatus, trans, blobid, 0, NULL);
	if (ISQL_errmsg(fbStatus))
		return;

	bool issql = false;
	bool firsttime = true;
	TEXT buffer[BUFFER_LENGTH512];
	string fullText;

	do
	{
		unsigned int length;
		int cc = blob->getSegment(fbStatus, sizeof(buffer) - 1, buffer, &length);
		if (cc == Firebird::IStatus::RESULT_NO_DATA || cc == Firebird::IStatus::RESULT_ERROR)
			break;

		buffer[length] = 0;
		const TEXT* p = buffer;
		if (isComputedField)
		{
			// computed field SQL syntax correction

			while (fb_utils::isspace(*p))
				p++;
			if (*p == '(')
				issql = true;
		}
		else
		{
			// Validation SQL syntax correction

			while (fb_utils::isspace(*p))
				p++;
			if (!fb_utils::strnicmp(p, "CHECK", 5))
				issql = true;
		}
		if (firsttime)
		{
			firsttime = false;
			if (!issql) {
				IUTILS_printf2(fp, "%s ", (isComputedField ? "/* " : "("));
			}
		}

		IUTILS_printf(fp, buffer);
		fullText += buffer;
	} while (true);

	// CVC: If firsttime == true, then it didn't write the "/*" or the "(".
	if (!issql && !firsttime)
		IUTILS_printf2(fp, "%s", (isComputedField ? " */" : ")"));

	if (failed())
		ISQL_errmsg(fbStatus);

	blob->close(fbStatus);

	if (ISQL_statement_ends_in_comment(fullText.c_str()))
		fputc('\n', fp);
}


static string get_numeric_value(const char* fromStr)
{
/**************************************
 *
 *	g e t _ n u m e r i c _ v a l u e
 *
 **************************************
 *
 * Functional description
 *	Prepares data for converting into decfloat by interface function.
 *
 **************************************/
	string val;
	for (const char* q = fromStr; *q; ++q)
	{
		switch (*q)
		{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case '.':
		case '+':
		case '-':
		case 'e':
		case 'E':
			val += *q;
			break;

		default:
			return val;
		}
	}

	return val;
}


static processing_state add_row(const QualifiedMetaString& tabname)
{
/**************************************
 *
 *	a d d _ r o w
 *
 **************************************
 *
 * Functional description
 *	Allows interactive insert of row, prompting for every column
 *
 *	The technique is to describe a select query of select * from the table.
 *	Then generate an insert with ? in every position, using the same sqlda.
 *	It will allow edits of blobs, skip arrays and computed fields
 *
 *	Parameters:
 *	tabname -- Name of table to insert into
 *
 **************************************/
	if (tabname.object.isEmpty())
		return (ps_ERR);

	if (!Interactive)
		return (ps_ERR);

	if (Input_file || !DB)
		return ps_ERR;

	// There may have been a commit transaction before we got here
	if (!M_Transaction())
	{
		return FAIL;
	}

	// Start default transaction for prepare
	if (!D_Transaction())
	{
		return FAIL;
	}

	// Query to obtain relation information
	string str2;
	str2.printf("SELECT * FROM %s", IUTILS_name_to_string(tabname).c_str());

	if (global_Stmt)
	{
		global_Stmt->free(fbStatus);
		if (ISQL_errmsg(fbStatus))
			return (SKIP);
	}

	global_Stmt = DB->prepare(fbStatus, D__trans, 0, str2.c_str(), isqlGlob.SQL_dialect,
		Firebird::IStatement::PREPARE_PREFETCH_METADATA);
	if (ISQL_errmsg(fbStatus))
		return (SKIP);

	Firebird::RefPtr<Firebird::IMessageMetadata> msg(Firebird::REF_NO_INCR, global_Stmt->getOutputMetadata(fbStatus));
	if (ISQL_errmsg(fbStatus))
		return (SKIP);

	const unsigned n_cols = msg->getCount(fbStatus);
	if (ISQL_errmsg(fbStatus))
		return (SKIP);

	global_Stmt->free(fbStatus);
	if (ISQL_errmsg(fbStatus))
		return (SKIP);
	global_Stmt = NULL;

	// Array for storing select/insert column mapping, colcheck sets it up
	Firebird::Array<unsigned> coln;
	unsigned* colnumber = coln.getBuffer(n_cols);

	auto fixedTabName = tabname;
	if (fixedTabName.schema.isEmpty() && isqlGlob.major_ods >= ODS_VERSION14)
		fixedTabName.schema = msg->getSchema(fbStatus, 0);

	col_check(fixedTabName, colnumber);

	// Create the new INSERT statement from the sqlda info

	string insertstring;

	// There is a question mark for each column that's known to be updatable.

	insertstring.printf("INSERT INTO %s (", IUTILS_name_to_string(tabname).c_str());

	unsigned i_cols = 0;
	for (unsigned i = 0; i < n_cols; ++i)
	{
		// Skip columns that are computed
		if (colnumber[i] != ~0u)
		{
			const auto fieldNameStr = IUTILS_name_to_string(msg->getField(fbStatus, i));
			if (ISQL_errmsg(fbStatus))
				return (SKIP);

			// Set i_cols to the number of insert columns
			if (i_cols++)
				insertstring += ',';
			insertstring += fieldNameStr;
		}
	}

	insertstring += ") VALUES (";

	for (unsigned i = 0; i < i_cols; i++)
	{
		if (i)
			insertstring += ',';
		insertstring += '?';
	}

	insertstring += ')';

	// Build metadata for insert message
	if (i_cols != n_cols)
	{
		Firebird::RefPtr<Firebird::IMetadataBuilder> bldr(Firebird::REF_NO_INCR, msg->getBuilder(fbStatus));
		if (ISQL_errmsg(fbStatus))
			return (SKIP);

		unsigned i = n_cols;
		while (i-- > 0)
		{
			if (colnumber[i] == ~0u)
			{
				bldr->remove(fbStatus, i);
				if (ISQL_errmsg(fbStatus))
					return (SKIP);
			}
		}
		msg.assignRefNoIncr(bldr->getMetadata(fbStatus));
		if (ISQL_errmsg(fbStatus))
			return (SKIP);
	}

	// Allocate INSERT buffer
	unsigned bSize = msg->getMessageLength(fbStatus);
	if (ISQL_errmsg(fbStatus))
		return (SKIP);
	UCHAR* msgBuf = global_Buffer->getBuffer(bSize);

	// For each column, get the type, and length then prompt for a value
	// and scanf the resulting string into a buffer of the right type.

	SCHAR infobuf[BUFFER_LENGTH180];
	IUTILS_msg_get(ADD_PROMPT, sizeof(infobuf), infobuf);
	STDERROUT(infobuf);

	TEXT txt[MSG_LENGTH];
	bool done = false;
	while (!done)
	{
		for (unsigned i = 0; i < i_cols && !done; ++i)
		{
			short* nullp = (short*)&msgBuf[msg->getNullOffset(fbStatus, i)];
			if (ISQL_errmsg(fbStatus))
				return (SKIP);
			UCHAR* datap = &msgBuf[msg->getOffset(fbStatus, i)];
			if (ISQL_errmsg(fbStatus))
				return (SKIP);

			const char* name = msg->getField(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return (SKIP);
			unsigned type = msg->getType(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return (SKIP);
			const bool nullable = msg->isNullable(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return (SKIP);
			unsigned varLength;
			int scale;

			// Prompt with the name and read the line
			switch (type)
			{
			case SQL_BLOB:
				IUTILS_msg_get(BLOB_PROMPT, txt, SafeArg() << name);
				// Blob: %s, type 'edit' or filename to load>
				break;
			case SQL_TYPE_DATE:
				IUTILS_msg_get(DATE_PROMPT, txt, SafeArg() << name);
				// Enter %s as Y/M/D>
				break;
			case SQL_TYPE_TIME:
				IUTILS_msg_get(TIME_PROMPT, txt, SafeArg() << name);
				// Enter %s as H:M:S>
				break;
			case SQL_TIMESTAMP:
				IUTILS_msg_get(TIMESTAMP_PROMPT, txt, SafeArg() << name);
				// Enter %s as Y/MON/D H:MIN:S[.MSEC]>
				break;
			default:
				IUTILS_msg_get(NAME_PROMPT, txt, SafeArg() << name);
				// Enter %s>
				break;
			}

			// On blank line or EOF, break the two loops without doing an insert.

			readNextInputLine(txt);
			getColumn = -1; // We are bypassing getNextInputChar().
			if (lastInputLine == NULL || strlen(lastInputLine) == 0)
			{
				done = true;
				break;
			}

			unsigned length = static_cast<unsigned>(strlen(lastInputLine));
			if (length > MAX_SQL_LENGTH)
			{
				IUTILS_msg_get(BUFFER_OVERFLOW, txt);
				STDERROUT(txt);
				done = true;
				break;
			}
			STDERROUT("");

			// Convert first 4 chars to upper case for comparison
			SCHAR cmd[5];
			fb_utils::copy_terminate(cmd, lastInputLine, sizeof cmd);
			IUTILS_make_upper(cmd);

			// If the user writes NULL, put a null in the column

			if (!strcmp(cmd, "NULL"))
				*nullp = -1;
			else
			{
				*nullp = 0;
				SLONG res;

				// Data types
				SSHORT* smallint;
				SLONG* integer;
				SINT64* pi64;
				SINT64 n;
				float* fvalue;
				double* dvalue;
				FB_DEC16* d64value;
				FB_DEC34* d128value;
				FB_I128* i128value;
				UCHAR* boolean;
				ISC_QUAD* blobid;
				vary* avary;
				char* achar;
				tm times;
				// Initialize the time structure
				memset(&times, 0, sizeof(times));
				char msec_str[5] = "";
				int msec = 0;

				switch (type)
				{
				case SQL_BLOB:

					blobid = (ISC_QUAD*) datap;

					if (!strcmp(cmd, "EDIT")) // If edit, we edit a temp file.
					{
						const PathName ftmp = TempFile::create(SCRATCH);
						if (ftmp.empty())
							res = 0;
						else
						{
							gds__edit(ftmp.c_str(), 0);
							Firebird::UtilInterfacePtr()->loadBlob(fbStatus, blobid, DB, M__trans,
								ftmp.c_str(), FB_TRUE);
							unlink(ftmp.c_str());
							res = succeeded();
						}
					}
					else	// Otherwise just load the named file
					{
						// We can't be sure if it's a TEXT or BINARY file
						// being loaded.  As we aren't sure, we'll
						// do binary operation - this is NEW data in
						// the database, not updating existing info
						Firebird::UtilInterfacePtr()->loadBlob(fbStatus, blobid, DB, M__trans,
							lastInputLine, FB_FALSE);
						res = succeeded();
					}

					if (!res)
					{
						STDERROUT("Unable to load file");
						done = true;
					}
					break;

				case SQL_FLOAT:
					fvalue = (float*) datap;
					if (sscanf(lastInputLine, "%g", fvalue) != 1)
					{
						STDERROUT("Input parsing problem");
						done = true;
					}
					break;

				case SQL_DOUBLE:
					dvalue = (double*) datap;
					if (sscanf(lastInputLine, "%lg", dvalue) != 1)
					{
						STDERROUT("Input parsing problem");
						done = true;
					}
					break;

				case SQL_DEC16:
					d64value = (FB_DEC16*) datap;
					if (isqlGlob.df16)
						isqlGlob.df16->fromString(fbStatus, lastInputLine, d64value);
					if ((!isqlGlob.df16) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_INT128:
					scale = msg->getScale(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);

					i128value = (FB_I128*) datap;
					if (isqlGlob.i128)
						isqlGlob.i128->fromString(fbStatus, scale, lastInputLine, i128value);
					if ((!isqlGlob.i128) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_DEC34:
					d128value = (FB_DEC34*) datap;
					if (isqlGlob.df34)
						isqlGlob.df34->fromString(fbStatus, lastInputLine, d128value);
					if ((!isqlGlob.df34) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_TYPE_DATE:
					if (3 != sscanf(lastInputLine, "%d/%d/%d", &times.tm_year,
									&times.tm_mon, &times.tm_mday) ||
						!check_date(times))
					{
						IUTILS_msg_get(DATE_ERR, txt, SafeArg() << lastInputLine);
						STDERROUT(txt);	// Bad date %s\n
						done = true;
					}
					else
					{
						--times.tm_mon;
						times.tm_year -= 1900; // tm_year is 1900-based.
						ISC_DATE* date = (ISC_DATE*) datap;
						isc_encode_sql_date(&times, date);
					}
					break;

				case SQL_TYPE_TIME:
					if (3 != sscanf(lastInputLine, "%d:%d:%d", &times.tm_hour,
									&times.tm_min, &times.tm_sec) ||
						!check_time(times))
					{
						IUTILS_msg_get(TIME_ERR, txt, SafeArg() << lastInputLine);
						STDERROUT(txt);	// Bad time %s\n
						done = true;
					}
					else
					{
						ISC_TIME* vtime = (ISC_TIME*) datap;
						isc_encode_sql_time(&times, vtime);
					}
					break;

				case SQL_TIME_TZ_EX:
				case SQL_TIME_TZ:
					{
						string tmp(lastInputLine, length);
						unsigned hours, minutes, seconds;
						char timeZone[TimeZoneUtil::MAX_SIZE];
						fb_assert(TimeZoneUtil::MAX_SIZE - 1 == 32);
						if (3 > sscanf(tmp.c_str(), "%u:%u:%u %32s", &hours, &minutes, &seconds, timeZone))
						{
							IUTILS_msg_get(TIME_ERR, txt, SafeArg() << tmp.c_str());
							STDERROUT(txt);	// Bad time %s\n
							done = true;
						}

						Firebird::UtilInterfacePtr()->encodeTimeTz(fbStatus,
							(ISC_TIME_TZ*) datap, hours, minutes, seconds, 0, timeZone);
						if (ISQL_errmsg(fbStatus))
							done = true;
					}
					break;

				case SQL_TIMESTAMP:
					if (6 <= sscanf(lastInputLine, "%d/%d/%d %d:%d:%d.%4s",
									&times.tm_year, &times.tm_mon, &times.tm_mday,
									&times.tm_hour, &times.tm_min, &times.tm_sec,
									msec_str))
					{
						unsigned int count = 0;
						for (; count < 4; ++count)
						{
							if (fb_isdigit(msec_str[count]))
								msec = msec * 10 + msec_str[count] - '0';
							else
								break;
						}
						if (count != strlen(msec_str))
							done = true;
						else
						{
							while (count++ < 4)
								msec *= 10;
							done = !check_timestamp(times, msec);
						}
					}
					else
						done = true;
					if (done)
					{
						IUTILS_msg_get(TIMESTAMP_ERR, txt, SafeArg() << lastInputLine);
						STDERROUT(txt);	// Bad timestamp %s\n
					}
					else
					{
						--times.tm_mon;
						times.tm_year -= 1900;
						ISC_TIMESTAMP* datetime = (ISC_TIMESTAMP*) datap;
						isc_encode_timestamp(&times, datetime);
						datetime->timestamp_time += msec;
					}
					break;

				case SQL_TIMESTAMP_TZ_EX:
				case SQL_TIMESTAMP_TZ:
					{
						string tmp(lastInputLine, length);
						unsigned year, month, day;
						unsigned hours, minutes, seconds, fractions;
						char timeZone[TimeZoneUtil::MAX_SIZE];
						fb_assert(TimeZoneUtil::MAX_SIZE - 1 == 32);
						if (7 > sscanf(tmp.c_str(), "%u-%u-%u %u:%u:%u.%u %32s", &year, &month, &day,
							&hours, &minutes, &seconds, &fractions, timeZone))
						{
							IUTILS_msg_get(TIMESTAMP_ERR, txt, SafeArg() << tmp.c_str());
							STDERROUT(txt);	// Bad time %s\n
							done = true;
						}

						Firebird::UtilInterfacePtr()->encodeTimeStampTz(fbStatus,
							(ISC_TIMESTAMP_TZ*) datap, year, month, day, hours, minutes, seconds, fractions, timeZone);
						if (ISQL_errmsg(fbStatus))
							done = true;
					}
					break;

				case SQL_TEXT:
				case SQL_VARYING:
					varLength = msg->getLength(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);
					if (length > varLength)
					{
						STDERROUT("String too long");		// msg!
						length = varLength;
					}

					if (type == SQL_VARYING)
					{
						avary = (vary*) datap;
						avary->vary_length = length;
						memcpy(avary->vary_string, lastInputLine, length);
					}
					else
					{
						achar = (char*) datap;
						memcpy(achar, lastInputLine, length);
						memset(&achar[length], ' ', varLength - length);
					}
					break;

				case SQL_SHORT:
				case SQL_LONG:
				case SQL_INT64:
					smallint = (SSHORT*) datap;
					integer = (SLONG*) datap;
					pi64 = (SINT64*) datap;

					scale = msg->getScale(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);

					if (scale < 0)
					{
						SSHORT lscale = 0;
						if (!get_numeric((UCHAR*) lastInputLine, length, &lscale, &n))
						{
							STDERROUT("Input parsing problem");
							done = true;
						}
						else
						{
							int dscale = scale - lscale;
							if (dscale > 0)
							{
								TEXT err_buf[256];
								sprintf(err_buf,
										"input error: input scale %d exceeds the field's scale %d",
										-lscale, -scale);
								STDERROUT(err_buf);
								done = true;
							}
							while (dscale++ < 0)
								n *= 10;
						}
					}
					// sscanf assumes a 64-bit integer target
					else if (sscanf(lastInputLine, "%" SQUADFORMAT, &n) != 1)
					{
						STDERROUT("Input parsing problem");
						done = true;
					}
					if (done)
						break; // Nothing else, we found an error.

					switch (type)
					{
					case SQL_INT64:
						*pi64 = n;
						break;
					case SQL_SHORT:
						*smallint = n;
						if (SINT64(*smallint) != n)
						{
							STDERROUT("Value too big");
							done = true;
						}
						break;
					case SQL_LONG:
						*integer = n;
						if (SINT64(*integer) != n)
						{
							STDERROUT("Value too big");
							done = true;
						}
					}
					break;

				case SQL_BOOLEAN:
					boolean = (FB_BOOLEAN*) datap;

					if (fb_utils::stricmp(lastInputLine, "TRUE") == 0)
						*boolean = 1;
					else if (fb_utils::stricmp(lastInputLine, "FALSE") == 0)
						*boolean = 0;
					else
					{
						STDERROUT("Invalid boolean value");
						done = true;
					}
					break;

				default:
					done = true;
					STDERROUT("Unexpected SQLTYPE in add_row()");
					break;
				}
			}
		}
		if (!done)
		{
			// having completed all columns, try the insert statement with the msg

			DB->execute(fbStatus, M__trans, insertstring.length(), insertstring.c_str(),
				isqlGlob.SQL_dialect, msg, msgBuf, NULL, NULL);
			if (ISQL_errmsg(fbStatus))
			{
				break;
			}
		}
	}

	return (SKIP);
}


static processing_state blobedit(ISC_QUAD blobId, const char* path)
{
/**************************************
 *
 *	b l o b e d i t
 *
 **************************************
 *
 * Functional description
 *	Edit the text blob indicated by blobid
 *
 *	Parameters:  cmd -- Array of words interpreted as file name
 *
 **************************************/
	if (!ISQL_dbcheck())
		return FAIL;

	if (blobId.gds_quad_high == 0 && blobId.gds_quad_low == 0)
		return ps_ERR;

	// If it isn't an explicit blobedit, then do a dump. Since this is a
	// user operation, put it on the M__trans handle.

	processing_state rc = SKIP;
	if (!path)
	{
		Firebird::UtilInterfacePtr utl;
		PathName tmpf = TempFile::create(fbStatus, "blob");
		if (ISQL_errmsg(fbStatus))
			return ps_ERR;
		const char* filename = tmpf.c_str();

		utl->dumpBlob(fbStatus, &blobId, DB, M__trans, filename, FB_TRUE);
		if (ISQL_errmsg(fbStatus))
			rc = ps_ERR;
		else
			gds__edit(filename, 0);

		unlink(filename);
	}
	else if (*path)
	{
		// If this is a blobdump, make sure there is a file name
		// We can't be sure if the BLOB is TEXT or BINARY data,
		// as we're not sure, we'll dump it in BINARY mode.
		Firebird::UtilInterfacePtr()->dumpBlob(fbStatus, &blobId, DB, M__trans, path, FB_FALSE);
	}
	else
		rc = ps_ERR;

	if (rc == SKIP && ISQL_errmsg(fbStatus))
	{
		rc = ps_ERR;
	}

	return rc;
}


// *******************************
// b u l k _ i n s e r t _ h a c k
// *******************************
// Primitive processing for prepared insertions. Invocation is
// SET BULK_INSERT <insert_statement>
// (val1, ..., valN)
// (val1, ..., valN)
// Finish with an empty line or anything different than an opening parenthesis.
// For example, STOP may be explicit, but any word without '(' will do the trick.
// Tuples must go in a single line. Only quoted strings can span more than one line.
// Added a very visible +++ to put other parameters of the same row in another line.
// Use +++ after a comma and continue in the next line. No comments in the middle.
// Only single quote accepted. Strings without special characters can go unquoted.
// Use the default question mark (?) to designate parameters.
// Single line comments are recognized only in the first column on a separate line
// and they can only appear before or after full tuples (not between multi-line tuples).
// The command COMMIT or COMMIT WORK can appear only in the first column in a
// single line and it will be recognized. We do not check if there's more text
// in the same line, thus it can be the terminator or random garbage.
// Two commas are invalid as empty/NULL value, use NULL or the appropriate "empty" value
// for the data type instead (zero for numbers, two single quotes for string, etc.)
// The code needs review, cleanup and moving some messages to the msg db.
// Since the code is forgiving, it will check for double ')' in the row but you can
// write (val1, ..., valN); with the terminator at the end and garbage following it.
// Indeed, the terminator can be replaced by unfamiliar characters to the parser
// like #, $, %, etc., and anything can follow them, including random text.
// It's invalid to put +++ (signaling row continuation) after a tuple is complete.
// If you came here looking for robust parsing code, you're at the wrong place.
static processing_state bulk_insert_hack(const char* command)
{
	if (!*command)
		return ps_ERR;

	processing_state ret = SKIP;

	// If somebody did a commit or rollback, we are out of a transaction

	if (!M_Transaction())
		return ps_ERR;

	// No need to start a default transaction unless there is no current one

	if (setValues.Autocommit)
	{
		if (!D_Transaction())
			return ps_ERR;
	}

	// If statistics are requested, then reserve them here

	SINT64 perf_before[ISQL_COUNTERS];
	if (setValues.Stats)
	{
		Firebird::UtilInterfacePtr()->getPerfCounters(fbStatus,
			DB, ISQL_COUNTERS_SET, perf_before);
		if (ISQL_errmsg(fbStatus))
		{
			return ps_ERR;
		}
	}

	// Prepare the dynamic query stored in string.
	// But put this on the DDL transaction to get maximum visibility of
	// metadata.

	if (global_Stmt)
	{
		global_Stmt->free(fbStatus);
		if (ISQL_errmsg(fbStatus))
			return (SKIP);
	}

	unsigned prepFlags = Firebird::IStatement::PREPARE_PREFETCH_METADATA |
		(setValues.Plan ? Firebird::IStatement::PREPARE_PREFETCH_DETAILED_PLAN : 0);

	global_Stmt = DB->prepare(fbStatus, setValues.Autocommit ? D__trans : M__trans,  0, command,
		isqlGlob.SQL_dialect, prepFlags);

	if (failed())
	{
		if (isqlGlob.SQL_dialect == SQL_DIALECT_V6_TRANSITION && Input_file)
		{
			isqlGlob.printf("%s%s%s%s%s%s",
							NEWLINE,
							"**** Error preparing statement:",
							NEWLINE,
							NEWLINE,
							command,
							NEWLINE);
		}
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	}

	// check for warnings
	ISQL_warning(fbStatus);

	// Find out what kind of statement this is
	const unsigned statement_type = global_Stmt->getType(fbStatus);
	if (!statement_type)
		return ps_ERR;

	/*** ASF: This is util to test others commands too.
	if (statement_type != isc_info_sql_stmt_insert)
	{
		isqlGlob.printf("Only INSERT commands are accepted in bulk mode.%s", NEWLINE);
		return ps_ERR;
	}
	***/

	Firebird::RefPtr<Firebird::IMessageMetadata> message(global_Stmt->getInputMetadata(fbStatus));
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}

	if (setValues.Sqlda_display)
	{
		print_message(message, "IN");
	}

	const unsigned n_cols = message->getCount(fbStatus);
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}
	if (!n_cols) // No input parameters, doesn't make sense for bulk insertions.
	{
		isqlGlob.printf("There must be at least one parameter in the statement.%s", NEWLINE);
		return ps_ERR;
	}

	// If PLAN is set, print out the plan now.

	if (setValues.Plan)
	{
		process_plan();
		if (setValues.Planonly)
			return ret;	// Do not execute.
	}

	unsigned msgSize = message->getMessageLength(fbStatus);
	if (ISQL_errmsg(fbStatus))
		return ps_ERR;
	UCHAR* msgBuf = global_Buffer->getBuffer(msgSize);

	char bulk_prompt[BUFFER_LENGTH180] = "";
	IUTILS_msg_get(BULK_PROMPT, sizeof(bulk_prompt), bulk_prompt);

	// Lookup the continuation prompt once
	TEXT con_prompt[MSG_LENGTH];
	IUTILS_msg_get(CON_PROMPT, con_prompt);

	TEXT msg[MSG_LENGTH];
	bool commit_failedM = false;
	bool commit_failedD = false;
	bool done = false; // This is mostly "done with errors".
	while (!done)
	{
		if (bulk_insert_retriever(bulk_prompt)) // We finished normally, found EOF.
			break;

		// We only support single line comments and they should be at the first column,
		// no spaces before, etc. Go to read the next line.
		if (lastInputLine[0] == '-' && lastInputLine[1] == '-')
			continue;

		const char* insert = lastInputLine;
		while (*insert && *insert != '(')
			++insert;

		if (!*insert || *insert != '(')
		{
			// Again, we are strict, we need COMMIT or COMMIT WORK exactly at the beginning
			// and it will be the only command in the line (we don't care about the rest).
			if (fb_utils::strnicmp(lastInputLine, "COMMIT", 6) == 0 ||
				fb_utils::strnicmp(lastInputLine, "COMMIT WORK", 11) == 0)
			{
				done = true;

				if (!commit_trans(&M__trans))
				{
					commit_failedM = true;
					break; // We failed to commit, quit the bulk insertion.
				}

				if (!M_Transaction())
				{
					commit_failedM = false;
					break; // We failed to start transaction, quit the bulk insertion.
				}

				// CVC: Commit may fail with AUTO-DDL off and DDL changes rejected by DFW.
				if (D__trans)
				{
					if (!commit_trans(&D__trans))
					{
						commit_failedD = true;
						break; // We failed to commit, quit the bulk insertion.
					}

					if (!D_Transaction())
					{
						commit_failedD = false;
						break; // We failed to commit, quit the bulk insertion.
					}
				}

				done = false;
				continue; // Go to read another line.
			}
			break; // For example, STOP or blank line not inside quoted string.
		}

		++insert;

		while (*insert == 0x20 || *insert == '\r' || *insert == '\t')
			++insert;

		if (!*insert) // Did we finish gracefully? The last line may be spaces or tab.
			break;

		const char* lastPos = insert;
		Extender extender; // Used only for multi-line tuples.

		for (unsigned i = 0, textFieldIter = 0; i < n_cols && !done; ++i)
		{
			unsigned offset = message->getNullOffset(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return ps_ERR;
			short* nullp = (short*) &msgBuf[offset];

			offset = message->getOffset(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return ps_ERR;
			void* datap = &msgBuf[offset];

			unsigned type = message->getType(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return (SKIP);
			const bool nullable = message->isNullable(fbStatus, i);
			if (ISQL_errmsg(fbStatus))
				return (SKIP);

			const char* finder = 0;
			int subtract = 0;
			const bool quote = *insert == SINGLE_QUOTE;
			if (quote)
			{
				subtract = 2; // Ignore the quotes at the beginning and end.
				bool finished = false; // Did the string close?
				++insert;
				while (*insert)
				{
					if (*insert == SINGLE_QUOTE)
					{
						++insert;
						if (*insert == SINGLE_QUOTE)
							++subtract;
						else
						{
							finished = true;
							break;
						}
					}
					++insert;
				}
				if (!finished)
				{
					extender.alloc(MAX_USHORT);
					extender.append(lastPos, insert - lastPos);
					while (!finished && !bulk_insert_retriever(con_prompt))
					{
						finder = lastInputLine;
						while (*finder)
						{
							if (*finder == SINGLE_QUOTE)
							{
								++finder;
								if (*finder == SINGLE_QUOTE)
									++subtract;
								else
								{
									finished = true;
									break;
								}
							}
							++finder;
						}
						size_t how_many = finder - lastInputLine;
						if (extender.append(lastInputLine, how_many) <= how_many)
						{
							done = true;
							ret = ps_ERR; // Do not delete, see if() below.
							STDERROUT("Failed to concatenate string");
							break;
						}
					}
					if (ret != ps_ERR && !finished)
					{
						done = true;
						STDERROUT("Failed to find end of quoted string");
					}
					if (done)
						break;

					lastPos = extender.getBuffer();
					insert = lastPos + extender.getUsed();
				}

				if (subtract > 2)
				{
					// Get rid of pairs of single quotes; they are a syntax artifact.
					const char* view = lastPos + 1;
					// We are working over lastInputLine or Extender's buffer, so "unconst" is safe.
					char* mover = const_cast<char*>(lastPos + 1);
					for (int counter = subtract; view < insert; ++view, ++mover)
					{
						*mover = *view;
						if (*view == SINGLE_QUOTE && view[1] == SINGLE_QUOTE && counter > 2)
						{
							++view;
							--counter;
						}
					}
				}
			}
			else
			{
				//if ((type == SQL_TEXT || type == SQL_VARYING || type == SQL_BLOB)
				//	&& fb_utils::strnicmp(insert, "NULL", 4))
				//{
				//	STDERROUT("Looking for unquoted string in:");
				//	STDERROUT(insert);
				//}

				for (bool go = true; go && *insert; ++insert)
				{
					switch (*insert)
					{
					case 0x20:
					//case '\n':
					case '\r':
					case '\t':
					case ',':
					case ')':
						go = false;
						--insert;
						break;
					}
				}
			}

			SCHAR cmd[5] = "";
			unsigned length = insert - lastPos - subtract;
			if (!length && !quote)
			{
				// Go ahead with an aux var and see if we hit end of string.
				const char* ipeek = insert;
				//char s[3] = {ipeek[-1], ipeek[0] ? ipeek[0] : 'Z', 0};
				//STDERROUT(s);
				while (*ipeek == 0x20 || *ipeek == '\r' || *ipeek == '\t')
					++ipeek;

				//s[0] = ipeek[-1];
				//s[1] = ipeek[0] ? ipeek[0] : 'Z';
				//STDERROUT(s);
				switch (*ipeek)
				{
				case ',':
					STDERROUT("Fields with zero length only allowed in quoted strings");
					break;
				case ')':
					STDERROUT("Found ')' before reading all fields in a row");
					break;
				default:
					STDERROUT("Unterminated row, use +++ to put more parameters in another line");
				}

				done = true;
				continue;
			}

			if (quote)
				++lastPos;
			else
			{
				// Convert first 4 chars to upper case for comparison.
				fb_utils::copy_terminate(cmd, lastPos, sizeof cmd);
				IUTILS_make_upper(cmd);
			}

			// If the user writes NULL, put a null in the column.

			if (!strcmp(cmd, "NULL"))
				*nullp = -1;
			else
			{
				*nullp = 0;
				// Data types
				SSHORT* smallint;
				SLONG* integer;
				SINT64* pi64;
				SINT64 n;
				float* fvalue;
				double* dvalue;
				UCHAR* boolean;
				vary* avary;
				char* achar;
				tm times;
				FB_DEC16* d64value;
				FB_DEC34* d128value;
				FB_I128* i128value;
				// Initialize the time structure.
				memset(&times, 0, sizeof(times));
				char msec_str[5] = "";
				int msec = 0;
				ISC_QUAD* blobid;
				unsigned varLength;
				int scale;

				switch (type)
				{
				case SQL_BLOB:
					blobid = (ISC_QUAD*) datap;

					{ // scope
						Firebird::IBlob* bs = DB->createBlob(fbStatus, M__trans, blobid, 0, NULL);
						if (failed())
						{
							STDERROUT("Unable to create blob");
							ISQL_errmsg(fbStatus);
							done = true;
							break; // Quit the switch()
						}

						bs->putSegment(fbStatus, length, lastPos);
						if (failed())
						{
							STDERROUT("Unable to write to blob");
							ISQL_errmsg(fbStatus);
							done = true;
						}
						bs->close(fbStatus);
						if (failed())
						{
							STDERROUT("Unable to close blob");
							ISQL_errmsg(fbStatus);
							done = true;
						}
					} // scope

					break;

				case SQL_FLOAT:
					fvalue = (float*) datap;
					if (sscanf(lastPos, "%g", fvalue) != 1)
					{
						STDERROUT("Input parsing problem in 'float' value");
						done = true;
					}
					break;

				case SQL_DOUBLE:
					dvalue = (double*) datap;
					if (sscanf(lastPos, "%lg", dvalue) != 1)
					{
						STDERROUT("Input parsing problem in 'double' value");
						done = true;
					}
					break;

				case SQL_DEC16:
					d64value = (FB_DEC16*) datap;
					if (isqlGlob.df16)
						isqlGlob.df16->fromString(fbStatus, get_numeric_value(lastPos).c_str(), d64value);
					if ((!isqlGlob.df16) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_DEC34:
					d128value = (FB_DEC34*) datap;
					if (isqlGlob.df34)
						isqlGlob.df34->fromString(fbStatus, get_numeric_value(lastPos).c_str(), d128value);
					if ((!isqlGlob.df34) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_INT128:
					scale = message->getScale(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);

					i128value = (FB_I128*) datap;
					if (isqlGlob.i128)
					{
						isqlGlob.i128->fromString(fbStatus, scale,
							get_numeric_value(lastPos).c_str(), i128value);
					}
					if ((!isqlGlob.i128) || (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
					{
						STDERROUT("Input parsing problem");
						ISQL_errmsg(fbStatus);
						done = true;
					}
					break;

				case SQL_TYPE_DATE:
					if (3 != sscanf(lastPos, "%d-%d-%d", &times.tm_year,
									&times.tm_mon, &times.tm_mday) ||
						!check_date(times))
					{
						IUTILS_msg_get(DATE_ERR, msg, SafeArg() << lastPos);
						STDERROUT(msg);	// Bad date %s\n
						done = true;
					}
					else
					{
						--times.tm_mon;
						times.tm_year -= 1900; // tm_year is 1900-based.
						ISC_DATE* date = (ISC_DATE*) datap;
						isc_encode_sql_date(&times, date);
					}
					break;

				case SQL_TYPE_TIME:
					if (3 != sscanf(lastPos, "%d:%d:%d", &times.tm_hour,
									&times.tm_min, &times.tm_sec) ||
						!check_time(times))
					{
						IUTILS_msg_get(TIME_ERR, msg, SafeArg() << lastPos);
						STDERROUT(msg);	// Bad time %s\n
						done = true;
					}
					else
					{
						ISC_TIME* vtime = (ISC_TIME*) datap;
						isc_encode_sql_time(&times, vtime);
					}
					break;

				case SQL_TIME_TZ_EX:
				case SQL_TIME_TZ:
					{
						string tmp(lastPos, length);
						unsigned hours, minutes, seconds;
						char timeZone[TimeZoneUtil::MAX_SIZE];
						fb_assert(TimeZoneUtil::MAX_SIZE - 1 == 32);
						if (3 > sscanf(tmp.c_str(), "%u:%u:%u %32s", &hours, &minutes, &seconds, timeZone))
						{
							IUTILS_msg_get(TIME_ERR, msg, SafeArg() << tmp.c_str());
							STDERROUT(msg);	// Bad time %s\n
							done = true;
						}

						Firebird::UtilInterfacePtr()->encodeTimeTz(fbStatus,
							(ISC_TIME_TZ*) datap, hours, minutes, seconds, 0, timeZone);
						if (ISQL_errmsg(fbStatus))
							done = true;
					}
					break;

				case SQL_TIMESTAMP:
					if (6 <= sscanf(lastPos, "%d-%d-%d %d:%d:%d.%4s",
									&times.tm_year, &times.tm_mon, &times.tm_mday,
									&times.tm_hour, &times.tm_min, &times.tm_sec,
									msec_str))
					{
						unsigned int count = 0;
						for (; count < 4; ++count)
						{
							if (fb_isdigit(msec_str[count]))
								msec = msec * 10 + msec_str[count] - '0';
							else
								break;
						}
						if (count != strlen(msec_str))
							done = true;
						else
						{
							while (count++ < 4)
								msec *= 10;
							done = !check_timestamp(times, msec);
						}
					}
					else
						done = true;

					if (done)
					{
						IUTILS_msg_get(TIMESTAMP_ERR, msg, SafeArg() << lastPos);
						STDERROUT(msg);	// Bad timestamp %s\n
					}
					else
					{
						--times.tm_mon;
						times.tm_year -= 1900;
						ISC_TIMESTAMP* datetime = (ISC_TIMESTAMP*) datap;
						isc_encode_timestamp(&times, datetime);
						datetime->timestamp_time += msec;
					}
					break;

				case SQL_TIMESTAMP_TZ_EX:
				case SQL_TIMESTAMP_TZ:
					{
						string tmp(lastPos, length);
						unsigned year, month, day;
						unsigned hours, minutes, seconds, fractions;
						char timeZone[TimeZoneUtil::MAX_SIZE];
						fb_assert(TimeZoneUtil::MAX_SIZE - 1 == 32);
						if (7 > sscanf(tmp.c_str(), "%u-%u-%u %u:%u:%u.%u %32s", &year, &month, &day,
							&hours, &minutes, &seconds, &fractions, timeZone))
						{
							IUTILS_msg_get(TIMESTAMP_ERR, msg, SafeArg() << tmp.c_str());
							STDERROUT(msg);	// Bad time %s\n
							done = true;
						}

						Firebird::UtilInterfacePtr()->encodeTimeStampTz(fbStatus,
							(ISC_TIMESTAMP_TZ*) datap, year, month, day, hours, minutes, seconds, fractions, timeZone);
						if (ISQL_errmsg(fbStatus))
							done = true;
					}
					break;

				case SQL_TEXT:
				case SQL_VARYING:
					varLength = message->getLength(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);
					if (length > varLength)
					{
						STDERROUT("String too long");		// msg!
						length = varLength;
					}

					if (type == SQL_VARYING)
					{
						avary = (vary*) datap;
						avary->vary_length = length;
						memcpy(avary->vary_string, lastPos, length);
					}
					else
					{
						achar = (char*) datap;
						memcpy(achar, lastPos, length);
						memset(&achar[length], ' ', varLength - length);
					}
					break;

				case SQL_SHORT:
				case SQL_LONG:
				case SQL_INT64:
					smallint = (SSHORT*) datap;
					integer = (SLONG*) datap;
					pi64 = (SINT64*) datap;

					scale = message->getScale(fbStatus, i);
					if (ISQL_errmsg(fbStatus))
						return (SKIP);

					if (scale < 0)
					{
						SSHORT lscale = 0;
						if (!get_numeric((UCHAR*) lastPos, length, &lscale, &n))
						{
							STDERROUT("Input parsing problem in 'numeric' or 'decimal' value");
							done = true;
						}
						else
						{
							int dscale = scale - lscale;
							if (dscale > 0)
							{
								TEXT err_buf[256];
								sprintf(err_buf,
										"Input error: input scale %d exceeds the field's scale %d",
										-lscale, -scale);
								STDERROUT(err_buf);
								done = true;
							}
							while (dscale++ < 0)
								n *= 10;
						}
					}
					// sscanf assumes a 64-bit integer target
					else if (sscanf(lastPos, "%" SQUADFORMAT, &n) != 1)
					{
						STDERROUT("Input parsing problem in 'integer' value");
						done = true;
					}
					if (done)
						continue; // Nothing else, we found an error.

					switch (type)
					{
					case SQL_INT64:
						*pi64 = n;
						break;
					case SQL_SHORT:
						*smallint = n;
						if (SINT64(*smallint) != n)
						{
							STDERROUT("Integer value too big");
							done = true;
						}
						break;
					case SQL_LONG:
						*integer = n;
						if (SINT64(*integer) != n)
						{
							STDERROUT("Integer value too big");
							done = true;
						}
					}
					break;

				case SQL_BOOLEAN:
					boolean = (FB_BOOLEAN*) datap;
					if (fb_utils::stricmp(lastInputLine, "TRUE") == 0)
						*boolean = 1;
					else if (fb_utils::stricmp(lastInputLine, "FALSE") == 0)
						*boolean = 0;
					else
					{
						STDERROUT("Invalid boolean value");
						done = true;
					}
					break;

				default:
					done = true;
					STDERROUT("Unexpected SQLTYPE in bulk_insert_hack()");
					break;
				}
			}

			if (done)
				break;

			// Restore "insert" pointer if we needed multi-line hack.
			if (finder)
				insert = finder;

			//while (*insert && *insert != ',' && *insert != ')')
			//	++insert;

			int comma_count = 0;
			int parenthesis_count = 0;
			for (bool go = true; go && *insert; ++insert)
			{
				switch (*insert)
				{
				case 0x20:
				//case '\n':
				case '\r':
				case '\t':
					break;
				case ',':
					if (++comma_count > 1)
					{
						go = false;
						--insert;
					}
					else if (i + 1 == n_cols) // We read all the row, no comma allowed!
					{
						go = false;
						done = true;
						STDERROUT("All fields were read but a comma was found");
					}
					break;
				case ')':
					if (++parenthesis_count > 1)
					{
						go = false;
						done = true;
						STDERROUT("Found more than one ')' in a row");
					}
					else if (i + 1 < n_cols) // We didn't read all fields but found closing parenthesis!
					{
						go = false;
						done = true;
						STDERROUT("Found ')' before reading all fields in a row");
					}
					break;
				default:
					go = false;
					--insert;
					break;
				}
			}

			// Allow line continuation after comma.
			if (!done && strncmp(insert, "+++", 3) == 0)
			{
				if (i + 1 == n_cols) // We read all the row, no continuation allowed!
				{
					done = true;
					STDERROUT("All fields were read but the continuation mark +++ was found");
				}
				else
				{
					if (bulk_insert_retriever(con_prompt))
					{
						done = true;
						STDERROUT("The continuation mark +++ was found but EOF was reached");
					}
					insert = lastInputLine;
				}
			}

			lastPos = insert;

		} // for (int i = 0;

		if (!done)
		{
			// Having completed all columns, try the insert statement with the message.
			// This is a non-select DML statement or trans.

			global_Stmt->execute(fbStatus, M__trans, message, msgBuf, NULL, NULL);
			if (ISQL_errmsg(fbStatus))
			{
				break;
			}

			// Check for warnings.
			ISQL_warning(fbStatus);
		}
	} // while (!done)

	if (done)
	{
		// Save whatever we were able to pump, except when the failure was the commit itself.
		if (M__trans)
		{
			if (commit_failedM)
			{
				M__trans->rollback(fbStatus);
				if (succeeded())
					M__trans = NULL;
			}
			else
				commit_trans(&M__trans);
		}

		if (D__trans)
		{
			if (commit_failedD)
			{
				D__trans->rollback(fbStatus);
				if (succeeded())
					D__trans = NULL;
			}
			else
				commit_trans(&D__trans);
		}

		TEXT errbuf[MSG_LENGTH];
		sprintf(errbuf, "Stopped prematurely due to error in line %d with text:",
			Filelist->Ifp().indev_aux);
		STDERROUT(errbuf);
		STDERROUT(lastInputLine);
		STDERROUT("Going to EOF");
		// Avoid thousands of errors. Assume the file is full of bulk insertion data.
		Filelist->gotoEof();

		ret = ps_ERR;
	}

	// Get rid of the statement handle.
	global_Stmt->free(fbStatus);
	if (succeeded())
		global_Stmt = NULL;

	// Statistics printed here upon request
	if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
		ret = ps_ERR;

	return ret;
}


// *****************************************
// b u l k _ i n s e r t _ r e t r i e v e r
// *****************************************
// Helper to the previous bulk_insert_hack to get more lines of input.
// It returns true when it finds end of file or too long string (almost 64K).
static bool bulk_insert_retriever(const char* prompt)
{
	readNextInputLine(prompt);
	getColumn = -1; // We are bypassing getNextInputChar().

	// Stop at end of line only. Empty lines are valid in this mode if inside quoted strings
	// but this function cannot know whether we are in a string because it doesn't parse
	// but only retrieves another line. Therefore, assumes and empty line is valid.
	bool rc = false;
	if (lastInputLine == NULL)
		rc = true;
	else
	{
		size_t length = strlen(lastInputLine);
		/*
		if (length == 0)
			rc = true;
		*/
		if (length > MAX_SQL_LENGTH)
		{
			TEXT msg[MSG_LENGTH];
			IUTILS_msg_get(BUFFER_OVERFLOW, msg);
			STDERROUT(msg);
			rc = true;
		}
	}

	return rc;
}


// Check if SET AUTOTERM is allowed. If not, disable it.
static void check_autoterm()
{
	if (!DB || !setValues.AutoTerm)
		return;

	static const UCHAR protocolInfo[] =
	{
		fb_info_protocol_version,
		isc_info_end
	};

	UCHAR buffer[BUFFER_LENGTH128];

	DB->getInfo(fbStatus, sizeof(protocolInfo), protocolInfo, sizeof(buffer), buffer);
	if (ISQL_errmsg(fbStatus))
		return;

	SLONG protocolVersion = -1;

	for (ClumpletReader p(ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		switch (p.getClumpTag())
		{
			case isc_info_end:
				break;

			case fb_info_protocol_version:
				protocolVersion = p.getInt();
				break;
		}
	}

	if (!(protocolVersion == 0 || protocolVersion >= 19) &&	// PROTOCOL_VERSION19
		  isqlGlob.major_ods >= ODS_VERSION14)
	{
		setValues.AutoTerm = false;

		TEXT errbuf[MSG_LENGTH];
		IUTILS_msg_get(AUTOTERM_NOT_SUPPORTED, errbuf);
		STDERROUT(errbuf);
	}
}


// *******************
// c h e c k _ d a t e
// *******************
// Check date as entered by the user, before adjustment (year - 1900, month - 1).
static bool check_date(const tm& times)
{
	const int y = times.tm_year;
	const int m = times.tm_mon;
	const int d = times.tm_mday;
	if (y < 1 || y > 4999)
		return false;
	if (m < 1 || m > 12)
		return false;
	const bool leap = (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
	const int days[] = {0, 31, leap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	if (d < 1 || d > days[m])
		return false;
	return true;
}


// *******************
// c h e c k _ t i m e
// *******************
// Check time is in range.
static bool check_time(const tm& times)
{
	if (times.tm_hour < 0 || times.tm_hour > 23)
		return false;
	if (times.tm_min < 0 || times.tm_min > 59)
		return false;
	if (times.tm_sec < 0 || times.tm_sec > 59)
		return false;
	return true;
}


// ******************************
// c h e c k _ t i m e s t a  m p
// ******************************
// Check both date and time according to the previous functions
// and also check milliseconds range.
static bool check_timestamp(const tm& times, const int msec)
{
	return check_date(times) && check_time(times) && msec >= 0 && msec <= 9999;
}


static void col_check(const QualifiedMetaString& tabname, unsigned* colnumber)
{
/**************************************
 *
 *	c o l _ c h e c k
 *
 **************************************
 *
 *	Check for peculiarities not currently revealed by the SQLDA
 *	colnumber array records the mapping of select columns to insert
 *	columns which do not have an equivalent for array or computed cols.
 **************************************/

	if (!frontendTransaction())
		return;

	// Query to get array info and computed source not available in the sqlda
	int i = 0, j = 0;
	FOR F IN RDB$FIELDS CROSS
		R IN RDB$RELATION_FIELDS
		WITH F.RDB$SCHEMA_NAME EQUIV R.RDB$FIELD_SOURCE_SCHEMA_NAME AND
			 F.RDB$FIELD_NAME = R.RDB$FIELD_SOURCE AND
			 R.RDB$SCHEMA_NAME EQUIV NULLIF(tabname.schema.c_str(), '') AND
			 R.RDB$RELATION_NAME EQ tabname.object.c_str()
		SORTED BY R.RDB$FIELD_POSITION, R.RDB$FIELD_NAME
	{
		if ((!F.RDB$DIMENSIONS.NULL && F.RDB$DIMENSIONS) || (!F.RDB$COMPUTED_BLR.NULL))
			colnumber[i] = ~0u;
		else
			colnumber[i] = j++;
		++i;
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
	END_ERROR
}


static processing_state copy_table(const QualifiedMetaString& source, const QualifiedMetaString& destination,
	const TEXT* otherdb)
{
/**************************************
 *
 *	c o p y _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	Create a new table based on an existing one.
 *
 *	Parameters:  source -- name of source table
 *			 destination == name of newly created table
 *
 **************************************/
	if (source.object.isEmpty() || destination.object.isEmpty())
	{
		STDERROUT("Either source or destination tables are missing");
		return SKIP;
	}

	TEXT errbuf[MSG_LENGTH];

	// Call list_table with a temporary file, then hand that file to a
	// new version of isql

	FILE* const holdout = isqlGlob.Out;

	// If there is an alternate database, extract the domains
	const bool domain_flag = otherdb[0];

	const PathName ftmp = TempFile::create(SCRATCH);
	isqlGlob.Out = os_utils::fopen(ftmp.c_str(), "w+b");
	if (!isqlGlob.Out)
	{
		// If we can't open a temp file then bail

		IUTILS_msg_get(FILE_OPEN_ERR, errbuf, SafeArg() << ftmp.c_str());
		STDERROUT(errbuf);
		Exit_value = FINI_ERROR;
		isqlGlob.Out = holdout;
		return END;
	}

	if (EXTRACT_list_table(source, destination, domain_flag, [](auto&&) { return -1; }))
	{
		IUTILS_msg_get(NOT_FOUND, errbuf, SafeArg() << IUTILS_name_to_string(source).c_str());
		STDERROUT(errbuf);
		fclose(isqlGlob.Out);
	}
	else
	{
		fclose(isqlGlob.Out);

		// easy to make a copy in another database
		const TEXT* altdb = isqlGlob.global_Db_name;
		if (*otherdb)
			altdb = otherdb;
		TEXT cmd[MAXPATHLEN * 2 + 20];
		sprintf(cmd, "isql -q %s -i %s", altdb, ftmp.c_str());
		if (system(cmd))
		{
			IUTILS_msg_get(COPY_ERR, errbuf, SafeArg() << IUTILS_name_to_string(destination).c_str() << altdb);
			STDERROUT(errbuf);
		}
	}

	unlink(ftmp.c_str());
	isqlGlob.Out = holdout;

	return (SKIP);
}


static processing_state create_db(const FrontendParser::CreateDatabaseNode& node)
{
/**************************************
 *
 *	c r e a t e _ d b
 *
 **************************************
 *
 * Functional description
 *	Intercept create database commands to
 *	adjust the DB and transaction handles
 *
 * Note: SQL ROLE setting must be taken into an account no matter
 *	that the newly created database will not have any user roles defined
 *	in it. Role may affect right to create new database.
 *
 **************************************/

	processing_state ret = SKIP;

	// Disconnect from the database and cleanup
	ISQL_disconnect_database(false);

	for (const auto createWithRole : {true, false})
	{
		std::string statement = "create database " + node.args[0].rawText;

		// If there are global parameters, we will set them into the create statement.

		if (global_usr)
			statement += std::string(" USER ") + isqlGlob.User;

		if (global_psw)
			statement += std::string(" PASSWORD '") + Password + "'";

		if (global_role && createWithRole)
			statement += std::string(" ROLE ") + isqlGlob.Role;

		if (setValues.ISQL_charset)
		{
			if (setValues.ISQL_charset->schema.isEmpty())
				statement += std::string(" SET NAMES '") + setValues.ISQL_charset->object.c_str() + "'";
			else
				statement += std::string(" SET NAMES '") + setValues.ISQL_charset->toQuotedString().c_str() + "'";
		}

		for (std::size_t i = 1; i < node.args.size(); ++i)
			statement += std::string(" ") + node.args[i].rawText;

		// execute the create statement
		// If the isqlGlob.SQL_dialect is not set or set to 2, create the database
		// as a dialect 3 database.
		unsigned dialect =
			(isqlGlob.SQL_dialect == 0 || isqlGlob.SQL_dialect == SQL_DIALECT_V6_TRANSITION) ?
				requested_SQL_dialect : isqlGlob.SQL_dialect;

		// Build up a dpb
		ClumpletWriter dpb(ClumpletReader::dpbList, MAX_DPB_SIZE);

		if (global_search_path && isqlGlob.SearchPath[0])
			dpb.insertString(isc_dpb_search_path, isqlGlob.SearchPath);

		dpb.insertString(isc_dpb_blr_request_search_path, SYSTEM_SCHEMA);

		DB = UtilInterfacePtr()->executeCreateDatabase2(fbStatus, statement.length(),
			statement.c_str(), dialect, dpb.getBufferLength(), dpb.getBuffer(), nullptr);

		if (!DB && createWithRole && fbStatus->getErrors()[1] == isc_dsql_error)
		{
			// Old server failed to parse ROLE clause
			continue;
		}

		if (ISQL_errmsg(fbStatus))
			ret = FAIL;

		break;
	}

	if (DB)
	{
		// Make it read owner name to display grantor correctly
		SHOW_read_owner();

		// No use in cancel when running non-end-user operators
		DB->cancelOperation(fbStatus, fb_cancel_disable);

		// Load isqlGlob.global_Db_name with some value to show a successful attach

		// CVC: Someone may decide to play strange games with undocumented ability
		// to write crap between CREATE DATABASE and the db name, as described by
		// Helen on CORE-932. Let's see if we can discover the real db name.
		strcpy(isqlGlob.global_Db_name, node.args[0].getProcessedString().c_str());

		ISQL_get_version(true);

		// Start the user transaction

		if (!M__trans)
		{
			M_Transaction();
			if (D__trans)
				commit_trans(&D__trans);
			if (setValues.Autocommit)
				D_Transaction();
		}
	}

	return (ret);
}


static void do_isql()
{
/**************************************
 *
 *	d o _ i s q l
 *
 **************************************
 *
 * Functional description
 *	Process incoming SQL statements, using the global message metadata
 *
 **************************************/
	TEXT errbuf[MSG_LENGTH];

	// Initialized user transactions

	M__trans = 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400 && _MSC_VER < 1900
	_set_output_format(_TWO_DIGIT_EXPONENT);
#endif

#ifdef WIN_NT
	// Enable Ctrl+C processing
	SetConsoleCtrlHandler(NULL, FALSE);
	SetConsoleCtrlHandler(query_abort, TRUE);
#else
	fb_shutdown_callback(0, query_abort, fb_shut_confirmation, 0);
#endif

	// Open database and start tansaction

	//
	// We will not execute this for now on WINDOWS. We are not prompting for
	// a database name, username and password. A connect statement has to be in
	// the file containing the script.

	newdb(isqlGlob.global_Db_name, isqlGlob.User, Password, global_numbufs, isqlGlob.Role, true);

	// If that failed or no Dbname was specified

	ISQL_dbcheck();

	// Read statements and process them from Ifp until the ret
	// code tells us we are done

	StatementGetter statementGetter;
	bool done = false;

	while (!done)
	{
		if (Abort_flag)
		{
			if (D__trans)
			{
				D__trans->rollback(fbStatus);
				if (succeeded())
					D__trans = NULL;
			}

			if (M__trans)
			{
				M__trans->rollback(fbStatus);
				if (succeeded())
					M__trans = NULL;
			}

			if (fbTrans)
			{
				fbTrans->rollback(fbStatus);
				if (succeeded())
					fbTrans = NULL;
			}

			// If there is current user statement, free it
			if (global_Stmt)
			{
				global_Stmt->free(fbStatus);
				if (succeeded())
					global_Stmt = NULL;
			}

			if (DB)
			{
				DB->detach(fbStatus);
				if (succeeded())
					DB = NULL;
			}

			break;
		}

		if (Interrupt_flag)
		{
			// SIGINT caught in interactive mode
			Interrupt_flag = false;

			if (Input_file)
			{
				// close input files going back to stdin
				Filelist->clear(stdin);

				// should have two stdin in Filelist
				fb_assert(Filelist->count() == 2);

				Filelist->removeIntoIfp();
				Input_file = false;
			}
		}

		auto [statement, ret] = statementGetter.getStatement();

		if (ret == CONT)
		{
			const auto statementWithoutSemicolonWithoutComments =
				FrontendLexer::stripComments(statement.withoutSemicolon);

			if (statementWithoutSemicolonWithoutComments.empty())
				ret = SKIP;
			else
				ret = frontend(FrontendLexer::stripComments(statementWithoutSemicolonWithoutComments).c_str());
		}

		// If there is no database yet, remind us of the need to connect

		// But don't execute the statement

		if (!isqlGlob.global_Db_name[0] && (ret == CONT))
		{
			if (!Quiet)
			{
				IUTILS_msg_get(NO_DB, errbuf);
				STDERROUT(errbuf);
			}

			if (!Interactive && setValues.BailOnError)
				ret = FAIL;
			else
				ret = SKIP;
		}

		switch (ret)
		{
		case CONT:
			switch (process_statement(setValues.AutoTerm ? statement.withSemicolon : statement.withoutSemicolon))
			{
				case TRUNCATED:
					statementGetter.rewind();
					break;

				case ps_ERR:
					Exit_value = FINI_ERROR;
					if (!Interactive && setValues.BailOnError)
						Abort_flag = true;
					[[fallthrough]];

				default:
					// Place each non frontend statement in the temp file if we are reading from stdin.
					Filelist->saveCommand(
						(setValues.AutoTerm ? statement.withSemicolon : statement.withoutSemicolon).c_str(),
						(setValues.AutoTerm ? "" : isqlGlob.global_Term));
					break;
			}
			break;

		case END:
		case FOUND_EOF:
		case EXIT:
			if (Abort_flag)
			{
				if (D__trans)
				{
					D__trans->rollback(fbStatus);
					if (succeeded())
						D__trans = NULL;
				}

				if (M__trans)
				{
					M__trans->rollback(fbStatus);
					if (succeeded())
						M__trans = NULL;
				}

				if (fbTrans)
				{
					fbTrans->rollback(fbStatus);
					if (succeeded())
						fbTrans = NULL;
				}
			}
			else
			{
				if (D__trans)
					commit_trans(&D__trans);
				if (M__trans)
					commit_trans(&M__trans);
				if (fbTrans)
					commit_trans(&fbTrans);
			}

			// If there is current user statement, free it
			// I think DSQL_drop is the right one, but who knows
			if (global_Stmt)
			{
				global_Stmt->free(fbStatus);
				if (succeeded())
					global_Stmt = NULL;
			}

			if (DB)
			{
				DB->detach(fbStatus);
				if (succeeded())
					DB = NULL;
			}

			done = true;
			break;

		case BACKOUT:
			if (D__trans)
			{
				D__trans->rollback(fbStatus);
				if (succeeded())
					D__trans = NULL;
			}

			if (M__trans)
			{
				M__trans->rollback(fbStatus);
				if (succeeded())
					M__trans = NULL;
			}

			if (fbTrans)
			{
				fbTrans->rollback(fbStatus);
				if (succeeded())
					fbTrans = NULL;
			}

			// If there is current user statement, free it
			if (global_Stmt)
			{
				global_Stmt->free(fbStatus);
				if (succeeded())
					global_Stmt = NULL;
			}

			if (DB)
			{
				DB->detach(fbStatus);
				if (succeeded())
					DB = NULL;
			}

			done = true;
			break;

		case EXTRACT:
		case EXTRACTALL:
		default:
			// fb_assert (FALSE);  -- removed as finds too many problems
		case ps_ERR:
		case FAIL:
			Exit_value = FINI_ERROR;
			if (!Interactive && setValues.BailOnError)
				Abort_flag = true;
			break;

		case SKIP:
			break;
		}
	}

	global_Stmt = NULL;
	DB = NULL;
	isqlGlob.global_Db_name[0] = '\0';
	D__trans = NULL;
	M__trans = NULL;
	fbTrans = NULL;

	InputDevices::indev& Ofp = Filelist->Ofp();
	// Does it have a valid Temp file pointer?
	if (Ofp.indev_fpointer)
		Ofp.drop();

	// CVC: If we were halt by an error and Bail, we have pending cleanup.
	Filelist->clear();
	if (lastInputLine)
		free(lastInputLine);

	setValues.global_Cols.clear(); // The destructor would do anyway if we don't reach this point.
}


static processing_state drop_db()
{
/**************************************
 *
 *	d r o p _ d b
 *
 **************************************
 *
 * Functional description
 *	Drop the current database
 *
 **************************************/
	if (DB && isqlGlob.global_Db_name[0])
	{
		RELEASE_REQUESTS FOR DB;

		DB->dropDatabase(fbStatus);
		if (ISQL_errmsg(fbStatus))
		{
			return (FAIL);
		}
	}
	else
		return (FAIL);

	// The database got dropped with or without errors
	M__trans = NULL;
	fbTrans = NULL;
	global_Stmt = NULL;
	D__trans = NULL;

	// CVC: If we aren't connected to a db anymore, then the db's dialect is reset.
	// This should fix SF Bug #910430.
	isqlGlob.db_SQL_dialect = 0;
	// BRS this is also needed to fix #910430.
	global_dialect_spoken = 0;

	// Zero database name

	isqlGlob.global_Db_name[0] = '\0';
	DB = NULL;

	return (SKIP);
}


static processing_state edit(const TEXT* file)
{
/**************************************
 *
 *	e d i t
 *
 **************************************
 *
 * Functional description
 *	Edit the current file or named file
 *
 *	Parameters:  cmd -- Array of words interpreted as file name
 *	The result of calling this is to point the global input file
 *	pointer, Ifp, to the named file after editing or the tmp file.
 *
 **************************************/

	// Set up editing command for shell
	// If there is a file name specified, try to open it

	processing_state rc = SKIP;
	if (*file)
	{
		TEXT path[MAXPATHLEN];
		strip_quotes(file, path);
		FILE* fp = os_utils::fopen(path, "r");
		if (fp)
		{
			// Push the current ifp on the indev

			Filelist->insertIfp();
			Filelist->Ifp().init(fp, path, path);
			gds__edit(path, 0);
			Input_file = true;
			getColumn = -1;
		}
		else
		{
			TEXT errbuf[MSG_LENGTH];
			IUTILS_msg_get(FILE_OPEN_ERR, errbuf, SafeArg() << path);
			STDERROUT(errbuf);
			rc = ps_ERR;
		}
	}
	else
	{
		// No file given, edit the temp file

		Filelist->insertIfp();
		// Close the file, edit it, then reopen and read from the top
		InputDevices::indev& Ofp = Filelist->Ofp();

		if (!Ofp.indev_fpointer)
		{
			// File used to edit sessions
			const PathName filename = TempFile::create(SCRATCH);
			const char* Tmpfile = filename.c_str();
			FILE* f = os_utils::fopen(Tmpfile, "w+"); // It was w+b
			if (f)
			{
				Ofp.init(f, Tmpfile, Tmpfile);
				Filelist->commandsToFile(f);
			}
			else
			{
				// If we can't open a temp file then bail
				TEXT errbuf[MSG_LENGTH];
				IUTILS_msg_get(FILE_OPEN_ERR, errbuf, SafeArg() << Tmpfile);
				STDERROUT(errbuf);
				return ps_ERR;
			}
		}

		Ofp.close();
		PathName tmpfile = Ofp.fileName(false);
		gds__edit(tmpfile.c_str(), 0);
		Ofp.init(os_utils::fopen(tmpfile.c_str(), "r+"),
			tmpfile.c_str(), tmpfile.c_str()); // We don't check for failure.
		Filelist->Ifp().init(Ofp);
		Input_file = true;
		getColumn = -1;
	}

	return rc;
}


static processing_state end_trans()
{
/**************************************
 *
 *	e n d _ t r a n s
 *
 **************************************
 *
 * Functional description
 *	Prompt the interactive user if there is an extant transaction and
 *	either commit or rollback
 *
 *	Called by newtrans, createdb, newdb;
 *	Returns success or failure.
 *
 **************************************/

	TEXT infobuf[BUFFER_LENGTH60];

	processing_state ret = CONT;
	// Give option of committing or rolling back before proceding unless
	// the last command was a commit or rollback

	if (M__trans)
	{
		if (Interactive)
		{
			IUTILS_msg_get(COMMIT_PROMPT, sizeof(infobuf), infobuf);
			readNextInputLine(infobuf);
			getColumn = -1; // We are bypassing getNextInputChar().
			if (lastInputLine && isyesno(lastInputLine))
			{
				// check for Yes answer
				IUTILS_msg_get(COMMIT_MSG, sizeof(infobuf), infobuf);
				STDERROUT(infobuf);
				if (DB && M__trans)
				{
					M__trans->commit(fbStatus);
					if (ISQL_errmsg(fbStatus))
					{
						// Commit failed, so roll back anyway
						ret = FAIL;
					}
					else
						M__trans = NULL;
				}
			}
			else
			{
				IUTILS_msg_get(ROLLBACK_MSG, sizeof(infobuf), infobuf);
				STDERROUT(infobuf);
				if (DB && M__trans)
				{
					M__trans->rollback(fbStatus);
					if (ISQL_errmsg(fbStatus))
						ret = FAIL;
					else
						M__trans = NULL;
				}
			}
		}
		else
		{
			// No answer, just roll back by default

			if (DB && M__trans)
			{
				// For WISQL, we keep track of whether a commit is needed by setting a flag in the ISQLPB
				// structure.  This flag is set whenever a sql command is entered in the SQL input area or
				// if the user uses the create database dialog.  Because of this, this should only show up if
				// the user connects and then disconnects or if the user enters a SET TRANSACTION stat without
				// ever doing anything that would cause changes to the dictionary.
				IUTILS_msg_get(ROLLBACK_MSG, sizeof(infobuf), infobuf);
				STDERROUT(infobuf);
				M__trans->rollback(fbStatus);
				if (ISQL_errmsg(fbStatus))
					ret = FAIL;
				else
					M__trans = NULL;
			}
		}
	}

	// Commit background transaction

	if (DB && D__trans)
	{
		D__trans->commit(fbStatus);
		if (ISQL_errmsg(fbStatus))
			ret = FAIL;
		else
			D__trans = NULL;
	}
	return ret;
}


static processing_state escape(const TEXT* cmd)
{
/**************************************
 *
 *	e s c a p e
 *
 **************************************
 *
 * Functional description
 *	Permit a shell escape to system call
 *
 *	Parameters:  cmd -- The command string with SHELL
 *
 **************************************/

	// Advance past the shell

	const TEXT* shellcmd = cmd;

	// Eat whitespace at beginning of command
	while (*shellcmd && fb_utils::isspace(*shellcmd))
		shellcmd++;

#ifdef WIN_NT
	// MSDN says: You must explicitly flush (using fflush or _flushall)
	// or close any stream before calling system.
	// CVC: But that function defeats our possible several input streams opened.
	//_flushall();
	// Save Ofp position in case it's being used as input. See EDIT command.
	fpos_t OfpPos = 0;
	if (Filelist->Ofp().indev_fpointer)
		Filelist->Ofp().getPos(&OfpPos);
	fflush(NULL); // Flush only output buffers.
	const char* emptyCmd = "%ComSpec%";
#else
	const char* emptyCmd = "$SHELL";
#endif

	// If no command given just spawn a shell
	if (!*shellcmd)
		shellcmd = emptyCmd;

	const int rc = system(shellcmd);

#ifdef WIN_NT
	// If we are reading from the temp file, restore the read position because
	// it's opened in r+ mode in this case, that's R/W.
	if (Filelist->sameInputAndOutput())
		Filelist->Ofp().setPos(&OfpPos);
#endif

	return rc ? FAIL : SKIP;
}


static processing_state execSetDebugCommand()
{
	if (!DB)
		return SKIP;

	const char* stmt = setValues.ExecPathDisplay[0] ?
		"set debug option dsql_keep_blr = true" :
		"set debug option dsql_keep_blr = false";

	DB->execute(fbStatus, nullptr, 0, stmt, isqlGlob.SQL_dialect, nullptr, nullptr, nullptr, nullptr);

	if (setValues.ExecPathDisplay[0] && (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS))
	{
		STDERROUT("SET EXEC_PATH_DISPLAY is not supported in this connection.");
		return FAIL;
	}

	return SKIP;
}


static processing_state frontend(const std::string& statement)
{
/**************************************
 *
 *	f r o n t e n d
 *
 **************************************
 *
 * Functional description
 *	Handle any frontend commands that start with
 *	show or set converting the string into an
 *	array of words parms, with MAX_TERMS words only.
 *
 *	Parameters: statement is the string typed by the user
 *
 **************************************/

	FrontendParser::Options parserOptions;
	parserOptions.schemaAsDatabase = isqlGlob.major_ods > 0 && isqlGlob.major_ods < ODS_VERSION12;

	const auto node = FrontendParser::parse(statement, parserOptions);
	bool bad_dialect = false;
	char bad_dialect_buf[512];

	const auto ret = std::visit(StdVisitOverloads{
		[](const FrontendParser::InvalidNode&)
		{
			return CONT;
		},

		[](const FrontendParser::AddNode& node)
		{
			if (!frontendTransaction())
				return FAIL;

			const auto ret = add_row(node.tableName);
			if (fbTrans)
				commit_trans(&fbTrans);

			return ret;
		},

		[](const FrontendParser::BlobDumpViewNode& node)
		{
			return blobedit(node.blobId, (node.file ? node.file->c_str() : nullptr));
		},

		[](const FrontendParser::ConnectNode& node)
		{
			std::optional<std::string> psw;
			const char* usr = nullptr;
			const char* sql_role_nm = nullptr;
			int numbufs = 0;

			// if a parameter is given in the command more than once, the
			// last one will be used. The parameters can appear each any
			// order, but each must provide a value.

			auto ret = SKIP;

			for (std::size_t i = 1; i < node.args.size() - 1;)
			{
				const auto& clause = node.args[i].processedText;

				if (clause == "CACHE")
				{
					char* err;
					long value = strtol(node.args[i + 1].processedText.c_str(), &err, 10);
					if (*err || (value <= 0) || (value >= INT_MAX))
					{
						ret = ps_ERR;
						break;
					}
					numbufs = (int) value;
					i += 2;
				}
				else if (clause == "USER")
				{
					usr = node.args[i + 1].rawText.c_str();
					i += 2;
				}
				else if (clause == "PASSWORD")
				{
					psw = node.args[i + 1].getProcessedString();
					i += 2;
				}
				else if (clause == "ROLE")
				{
					sql_role_nm = node.args[i + 1].rawText.c_str();
					i += 2;
				}
				else if (!clause.empty())
				{
					// Unrecognized option to CONNECT
					ret = ps_ERR;
					break;
				}
				else
					++i;
			}

			if (ret != ps_ERR)
			{
				ret = newdb(
					node.args[0].getProcessedString().c_str(),
					usr,
					(psw ? psw->c_str() : nullptr),
					numbufs,
					sql_role_nm,
					true);
			}

			return ret;
		},

		[](const FrontendParser::CopyNode& node)
		{
			if (!frontendTransaction())
				return FAIL;

			const auto ret = copy_table(node.source, node.destination, node.database.c_str());

			if (fbTrans)
				commit_trans(&fbTrans);

			return ret;
		},

		[](const FrontendParser::CreateDatabaseNode& node)
		{
			return create_db(node);
		},

		[](const FrontendParser::DropDatabaseNode&)
		{
			return drop_db();
		},

		[](const FrontendParser::EditNode& node)
		{
			return edit(node.file.value_or("").c_str());
		},

		[](const FrontendParser::ExitNode& node)
		{
			return EXIT;
		},

		[](const FrontendParser::ExplainNode& node)
		{
			return explain(node.query.c_str());
		},

		[](const FrontendParser::HelpNode& node)
		{
			return help(node.command.value_or("").c_str());
		},

		[](const FrontendParser::InputNode& node)
		{
			return newinput(node.file.c_str());
		},

		[](const FrontendParser::OutputNode& node)
		{
			return newoutput(node.file.value_or("").c_str());
		},

		[](const FrontendParser::QuitNode& node)
		{
			return BACKOUT;
		},

		[](const FrontendParser::ShellNode& node)
		{
			return escape(node.command.value_or("").c_str());
		},

		// SET commands

		[&](const FrontendParser::AnySetNode& anySet)
		{
			return std::visit(StdVisitOverloads{
				[](const FrontendParser::InvalidNode&)
				{
					return CONT;
				},

				[](const FrontendParser::SetNode&)
				{
					return print_sets();
				},

				[](const FrontendParser::SetAutoDdlNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Autocommit);
				},

				[](const FrontendParser::SetAutoTermNode& node)
				{
					const auto ret = do_set_command(node.arg.c_str(), &setValues.AutoTerm);
					if (setValues.AutoTerm)
					{
						isqlGlob.Termlen = 1;
						strcpy(isqlGlob.global_Term, ";");
					}
					return ret;
				},

				[](const FrontendParser::SetBailNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.BailOnError);
				},

				[](const FrontendParser::SetBlobDisplayNode& node)
				{
					// No arg means turn off blob display
					if (node.arg.empty() || node.arg == "OFF")
						setValues.Doblob = NO_BLOBS;
					else if (node.arg == "ALL")
						setValues.Doblob = ALL_BLOBS;
					else
						setValues.Doblob = atoi(node.arg.c_str());
					return SKIP;
				},

				[](const FrontendParser::SetBulkInsertNode& node)
				{
					return bulk_insert_hack(node.statement.c_str());
				},

				[](const FrontendParser::SetCountNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Docount);
				},

				[](const FrontendParser::SetEchoNode& node)
				{
					const auto ret = do_set_command(node.arg.c_str(), &setValues.Echo);
					if (!setValues.Echo)
						ISQL_prompt("");
					return ret;
				},

				[](const FrontendParser::SetExecPathDisplayNode& node)
				{
					if (node.arg.empty())
						return ps_ERR;
					else if (node.arg == "OFF")
						setValues.ExecPathDisplay[0] = 0;
					else
					{
						static constexpr UCHAR execPath[] = {isc_info_sql_exec_path_blr_text};

						if (node.arg != "BLR")
							return ps_ERR;

						memcpy(setValues.ExecPathDisplay, execPath, FB_NELEM(execPath));
						setValues.ExecPathDisplay[FB_NELEM(execPath)] = 0;
					}

					return execSetDebugCommand();
				},

				[](const FrontendParser::SetExplainNode& node)
				{
					auto ret = do_set_command(node.arg.c_str(), &setValues.ExplainPlan);
					if (setValues.ExplainPlan)
						ret = do_set_command("ON", &setValues.Plan);
					return ret;
				},

				[](const FrontendParser::SetHeadingNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Heading);
				},

				[](const FrontendParser::SetKeepTranParamsNode& node)
				{
					const bool oldValue = setValues.KeepTranParams;
					const auto ret = do_set_command(node.arg.c_str(), &setValues.KeepTranParams);
					if ((ret != ps_ERR) && (oldValue != setValues.KeepTranParams))
						TranParams->assign(setValues.KeepTranParams ? DEFAULT_DML_TRANS_SQL : "");
					return ret;
				},

				[](const FrontendParser::SetListNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.List);
				},

				[](const FrontendParser::SetLocalTimeoutNode& node)
				{
					int val = strtol(node.arg.c_str(), nullptr, 10);

					if (val < 0)
						return ps_ERR;
					else
					{
						setValues.StmtTimeout = val;
						return SKIP;
					}
				},

				[](const FrontendParser::SetMaxRowsNode& node)
				{
					return newMaxRows((node.arg.empty() ? "0" : node.arg.c_str()));
				},

				[](const FrontendParser::SetNamesNode& node)
				{
					setValues.ISQL_charset = node.name;
					return SKIP;
				},

				[](const FrontendParser::SetPerTableStatsNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.PerTableStats);
				},

				[](const FrontendParser::SetPlanNode& node)
				{
					auto ret = do_set_command(node.arg.c_str(), &setValues.Plan);
					if (setValues.Planonly && !setValues.Plan)
						ret = do_set_command("OFF", &setValues.Planonly);
					return ret;
				},

				[](const FrontendParser::SetPlanOnlyNode& node)
				{
					auto ret = do_set_command(node.arg.c_str(), &setValues.Planonly);
					if (setValues.Planonly && !setValues.Plan)
					{
						// turn on plan
						ret = do_set_command("ON", &setValues.Plan);
					}
					return ret;
				},

				[](const FrontendParser::SetSqldaDisplayNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Sqlda_display);
				},

				[&](const FrontendParser::SetSqlDialectNode& node)
				{
					return get_dialect(node.arg.c_str(), bad_dialect_buf, bad_dialect);
				},

				[](const FrontendParser::SetStatsNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Stats);
				},

				[](const FrontendParser::SetTermNode& node)
				{
					const TEXT* termStr = node.arg.empty() ? DEFTERM : node.arg.c_str();

					for (size_t iter = 0; iter < sizeof(FORBIDDEN_TERM_CHARS); ++iter)
					{
						if (strchr(termStr, FORBIDDEN_TERM_CHARS[iter]))
						{
							TEXT msg_string[MSG_LENGTH];
							IUTILS_msg_get(INVALID_TERM_CHARS, msg_string, SafeArg() << FORBIDDEN_TERM_CHARS_DISPLAY);
							isqlGlob.printf("%s\n", msg_string);
							return ps_ERR;
						}
					}

					setValues.AutoTerm = false;

					isqlGlob.Termlen = strlen(termStr);
					if (isqlGlob.Termlen < MAXTERM_SIZE)
						strcpy(isqlGlob.global_Term, termStr);
					else
					{
						isqlGlob.Termlen = MAXTERM_SIZE - 1;
						fb_utils::copy_terminate(isqlGlob.global_Term, termStr, isqlGlob.Termlen + 1);
					}

					return SKIP;
				},

				[](const FrontendParser::SetTimeNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Time_display);
				},

				[](const FrontendParser::SetTransactionNode& node)
				{
					return newtrans(node.statement.c_str());
				},

				[](const FrontendParser::SetWarningsNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.Warnings);
				},

				[](const FrontendParser::SetWidthNode& node)
				{
					return newsize(node.column.c_str(), node.width.c_str());
				},

				[](const FrontendParser::SetWireStatsNode& node)
				{
					return do_set_command(node.arg.c_str(), &setValues.WireStats);
				},

				[](auto& arg)
				{
					static_assert(FrontendParser::AlwaysFalseV<decltype(arg)>,
						"Add visitor method for that set node type");
				}
			}, anySet);
		},

		// SHOW commands

		[](const FrontendParser::AnyShowNode& node)
		{
			if (DB && !frontendTransaction())
				return FAIL;

			const auto ret = SHOW_metadata(node);

			if (fbTrans)
				commit_trans(&fbTrans);

			return ret;
		},

		[](auto& arg)
		{
			static_assert(FrontendParser::AlwaysFalseV<decltype(arg)>, "Add visitor method for that node type");
		}
	}, node);

	// In case any default transaction was started - commit it here
	if (fbTrans)
		commit_trans(&fbTrans);

	if (ret == ps_ERR)
	{
		TEXT errbuf[MSG_LENGTH];

		if (bad_dialect)
			IUTILS_msg_get(CMD_ERR, errbuf, SafeArg() << bad_dialect_buf);
		else
			IUTILS_msg_get(CMD_ERR, errbuf, SafeArg() << statement.c_str());

		STDERROUT(errbuf);
	}

	return ret;
}


static processing_state do_set_command(const TEXT* parm, bool* global_flag)
{
/**************************************
 *
 *	d o _ s e t _ c o m m a n d
 *
 **************************************
 *
 * Functional description
 *	set the flag pointed to by global_flag
 *		to true or false.
 *	if parm is missing, toggle it
 *	if parm is "ON", set it to true
 *	if parm is "OFF", set it to false
 *
 **************************************/
	processing_state ret = SKIP;

	if (!*parm)
		*global_flag = !*global_flag;
	else if (!strcmp(parm, "ON"))
		*global_flag = true;
	else if (!strcmp(parm, "OFF"))
		*global_flag = false;
	else
		ret = ps_ERR;
	return (ret);
}


// *********************
// g e t _ d i a l e c t
// *********************
// Validates SET SQL DIALECT command according to the target db.
static processing_state get_dialect(const char* const dialect_str,
	char* const bad_dialect_buf, bool& bad_dialect)
{
	processing_state ret = SKIP;
	bool print_warning = false;
	const USHORT old_SQL_dialect = isqlGlob.SQL_dialect; // save the old SQL dialect
	if (dialect_str && (isqlGlob.SQL_dialect = atoi(dialect_str)))
	{
		if (isqlGlob.SQL_dialect < SQL_DIALECT_V5 ||
			isqlGlob.SQL_dialect > SQL_DIALECT_V6)
		{
			bad_dialect = true;
			sprintf(bad_dialect_buf, "%s%s",
					"invalid SQL dialect ", dialect_str);
			isqlGlob.SQL_dialect = old_SQL_dialect;	// restore SQL dialect
			ret = ps_ERR;
		}
		else
		{
			if (isqlGlob.major_ods)
			{
				if (isqlGlob.major_ods < ODS_VERSION10)
				{
					if (isqlGlob.SQL_dialect > SQL_DIALECT_V5)
					{
						if (global_dialect_spoken)
						{
							sprintf(bad_dialect_buf,
									"%s%d%s%s%s%d%s",
									"ERROR: Database SQL dialect ",
									global_dialect_spoken,
									" database does not accept Client SQL dialect ",
									dialect_str,
									" setting. Client SQL dialect still remains ",
									old_SQL_dialect, NEWLINE);
						}
						else
						{
							sprintf(bad_dialect_buf,
									"%s%s%s%s%s%s",
									"ERROR: Pre IB V6 database only speaks ",
									"Database SQL dialect 1 and ",
									"does not accept Client SQL dialect ",
									dialect_str,
									" setting. Client SQL dialect still remains 1.",
									NEWLINE);
						}
						isqlGlob.SQL_dialect = old_SQL_dialect;	// restore SQL dialect
						isqlGlob.prints(bad_dialect_buf);
					}
				}
				else
				{
					// ODS 10 databases
					switch (global_dialect_spoken)
					{
					case SQL_DIALECT_V5:
						if (isqlGlob.SQL_dialect > SQL_DIALECT_V5)
						{
							if (SQL_DIALECT_V6_TRANSITION)
								Merge_stderr = true;
							print_warning = true;
						}
						break;
					case SQL_DIALECT_V6:
						if (isqlGlob.SQL_dialect == SQL_DIALECT_V5 ||
							isqlGlob.SQL_dialect == SQL_DIALECT_V6_TRANSITION)
						{
							if (SQL_DIALECT_V6_TRANSITION)
								Merge_stderr = true;
							print_warning = true;
						}
						break;
					default:
						break;
					}
					if (print_warning && setValues.Warnings)
					{
						//print_warning = false;
						sprintf(bad_dialect_buf, "%s%d%s%d%s%s",
								"WARNING: Client SQL dialect has been set to ",
								isqlGlob.SQL_dialect,
								" when connecting to Database SQL dialect ",
								global_dialect_spoken,
								" database. ", NEWLINE);
						isqlGlob.prints(bad_dialect_buf);
					}
				}
			}
		}
	}
	else
	{
		// handle non numeric invalid "set sql dialect" case
		isqlGlob.SQL_dialect = old_SQL_dialect;	// restore SQL dialect
		bad_dialect = true;
		sprintf(bad_dialect_buf, "%s%s", "invalid SQL dialect ",
				dialect_str);
		ret = ps_ERR;
	}
	return ret;
}


std::pair<FrontendLexer::SingleStatement, processing_state> StatementGetter::getStatement()
{
	Filelist->Ifp().indev_line = Filelist->Ifp().indev_aux;

	const auto* prompt = lexer.isBufferEmpty() ? sql_prompt : conPrompt;
	std::string_view term(isqlGlob.global_Term, isqlGlob.Termlen);
	std::string buffer;

	while (true)
	{
		if ((Interactive && !Input_file) || setValues.Echo)
			ISQL_prompt(prompt);

		SSHORT c = getNextInputChar();

		if (c == EOF)
		{
			// Go back to getc if we get interrupted by a signal.

			if (SYSCALL_INTERRUPTED(errno))
			{
				errno = 0;
				continue;
			}

			buffer += '\n';
			lexer.appendBuffer(buffer);
			buffer.clear();

			bool isBufferEmpty = lexer.isBufferEmpty();

			// If there was something valuable before EOF - error
			if (!isBufferEmpty)
			{
				try
				{
					isBufferEmpty = FrontendLexer::stripComments(lexer.getBuffer()).empty();
				}
				catch (const FrontendLexer::IncompleteTokenError&)
				{
				}

				if (!isBufferEmpty)
				{
					TEXT errbuf[MSG_LENGTH];
					IUTILS_msg_get(UNEXPECTED_EOF, errbuf);
					STDERROUT(errbuf);
				}
			}

			// If we hit EOF at the top of the flist, exit time

			if (Filelist->count() == 1)
				return {{}, FOUND_EOF};

			// If this is not tmpfile, close it

			if (!Filelist->sameInputAndOutput())
				Filelist->Ifp().close();

			// Reset to previous after other input

			Filelist->removeIntoIfp();

			if ((Interactive && !Input_file) || setValues.Echo)
				prompt = sql_prompt;

			// CVC: Let's detect if we went back to the first level.
			if (Filelist->readingStdin())
			{
				Interactive = !stdin_redirected();
				Input_file = false;
			}

			// Try to convince the new routines to go back to previous file(s)
			// This should fix the INPUT bug introduced with editline.
			getColumn = -1;

			if (!isBufferEmpty)
			{
				lexer.reset();
				Exit_value = FINI_ERROR;
				return {{}, FAIL};
			}
		}
		else
		{
			buffer += (char) c;

			if (c == '\n' ||
				(buffer.length() >= isqlGlob.Termlen &&
					std::equal(buffer.end() - isqlGlob.Termlen, buffer.end(), term.begin())))
			{
				lexer.appendBuffer(buffer);
				buffer.clear();

				const auto singleStatementVar = lexer.getSingleStatement(term);

				if (const auto singleStatement = std::get_if<FrontendLexer::SingleStatement>(&singleStatementVar))
					return {*singleStatement, CONT};
				else if (const auto incompleteTokenError =
							std::get_if<FrontendLexer::IncompleteTokenError>(&singleStatementVar))
				{
					prompt =
						incompleteTokenError->insideComment ? "---> " :
						lexer.isBufferEmpty() ? sql_prompt :
						conPrompt;
				}
			}
		}
	}

	fb_assert(false);
	return {{}, FOUND_EOF};
}


void ISQL_get_version(bool call_by_create_db)
{
/**************************************
 *
 *	I S Q L _ g e t _ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	finds out if the database we just attached to is
 *	V4 or newer as well as other info.
 *
 **************************************/
	const UCHAR db_version_info[] =
	{
		isc_info_ods_version,
		isc_info_ods_minor_version,
		isc_info_db_sql_dialect,
		frb_info_att_charset,
		UCHAR(Version_info ? isc_info_firebird_version: isc_info_end),
		isc_info_end
	};
	/*
	   ** Each info item requested will return
	   **
	   **	 1 byte for the info item tag
	   **	 2 bytes for the length of the information that follows
	   **	 1 to 4 bytes of integer information
	   **
	   ** isc_info_end will not have a 2-byte length - which gives us
	   ** some padding in the buffer.
	 */

	// UCHAR buffer[sizeof(db_version_info) * (1 + 2 + 4)];

	// Now we are also getting the Firebird server version which is a
	// string the above calculation does not apply.	 NM 03-Oct-2001

	UCHAR buffer[PRINT_BUFFER_LENGTH];
	char bad_dialect_buf[BUFFER_LENGTH512];
	bool print_warning = false;

	global_dialect_spoken = 0;

	if (!DB)
		return;
	DB->getInfo(fbStatus, sizeof(db_version_info), db_version_info,
						  sizeof(buffer), buffer);
	if(ISQL_errmsg(fbStatus))
	{
		return;
	}

	for (Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		UCHAR item = p.getClumpTag();
		if (item == isc_info_end)
			break;

		switch (item)
		{
		case isc_info_ods_version:
			isqlGlob.major_ods = p.getInt();
			break;
		case isc_info_ods_minor_version:
			isqlGlob.minor_ods = p.getInt();
			break;
		case isc_info_db_sql_dialect:
			global_dialect_spoken = p.getInt();
			if (isqlGlob.major_ods < ODS_VERSION10)
			{
				if (isqlGlob.SQL_dialect > SQL_DIALECT_V5 && setValues.Warnings)
				{
					isqlGlob.printf(NEWLINE);
					sprintf(bad_dialect_buf, "%s%s%s%d%s%s",
							"WARNING: Pre IB V6 database only speaks",
							" SQL dialect 1 and ",
							"does not accept Client SQL dialect ",
							isqlGlob.SQL_dialect,
							" . Client SQL dialect is reset to 1.", NEWLINE);
					isqlGlob.prints(bad_dialect_buf);
				}
			}
			else
			{
				// ODS 10 databases

				switch (global_dialect_spoken)
				{
				case SQL_DIALECT_V5:
					if (isqlGlob.SQL_dialect > SQL_DIALECT_V5)
						print_warning = true;
					break;

				case SQL_DIALECT_V6:
					if (isqlGlob.SQL_dialect != 0 && isqlGlob.SQL_dialect < SQL_DIALECT_V6)
						print_warning = true;
					break;
				default:
					break;
				}
				if (print_warning && setValues.Warnings)
				{
					print_warning = false;
					isqlGlob.printf(NEWLINE);
					sprintf(bad_dialect_buf, "%s%d%s%d%s%s",
							"WARNING: This database speaks SQL dialect ",
							global_dialect_spoken,
							" but Client SQL dialect was set to ",
							isqlGlob.SQL_dialect, " .", NEWLINE);
					isqlGlob.prints(bad_dialect_buf);
				}
			}
			break;
		case isc_info_error:
			// Error indicates an option was not understood by the
			// remote server.
			if (p.getBytes()[0] == isc_info_firebird_version)
			{
				// must be an old or non Firebird server
				break;
			}
			if (isqlGlob.SQL_dialect && isqlGlob.SQL_dialect != SQL_DIALECT_V5 && setValues.Warnings)
			{
				isqlGlob.printf(NEWLINE);
				if (call_by_create_db)
					sprintf(bad_dialect_buf, "%s%s%d%s%s",
							"WARNING: Pre IB V6 server only speaks SQL dialect 1",
							" and does not accept Client SQL dialect ",
							isqlGlob.SQL_dialect,
							" . Client SQL dialect is reset to 1.", NEWLINE);
				else
				{
					//connecting_to_pre_v6_server = true; Not used anywhere.
					sprintf(bad_dialect_buf, "%s%s%d%s%s",
							"ERROR: Pre IB V6 server only speaks SQL dialect 1",
							" and does not accept Client SQL dialect ",
							isqlGlob.SQL_dialect,
							" . Client SQL dialect is reset to 1.", NEWLINE);
				}
				isqlGlob.prints(bad_dialect_buf);
			}
			else
			{
				if (isqlGlob.SQL_dialect == 0)
				{
					//connecting_to_pre_v6_server = true; Not used anywhere.
					sprintf(bad_dialect_buf, "%s%s%d%s%s",
							"ERROR: Pre IB V6 server only speaks SQL dialect 1",
							" and does not accept Client SQL dialect ",
							isqlGlob.SQL_dialect,
							" . Client SQL dialect is reset to 1.", NEWLINE);
					isqlGlob.prints(bad_dialect_buf);
				}
			}
			break;
		case isc_info_firebird_version:
			if (Version_info)
			{
				// This information will be skipped if the server isn't given enough buffer
				// to put it all. It's a FULL or NOTHING answer. It grows with redirection.
				// The command SHOW version that calls isc_version() will return more info.
				isqlGlob.printf("Server version:%s", NEWLINE);
				const UCHAR* q = p.getBytes(); // We don't want to spoil p with a wrong calculation.
				const UCHAR* limit = q + p.getClumpLength();
				for (int times = *q++; times && q < limit; --times)
				{
					int l = *q++;
					if (l > limit - q)
						l = limit - q;

					isqlGlob.printf("%.*s%s", l, q, NEWLINE);
					q += l;
				}
			}
			break;

		case frb_info_att_charset:
			isqlGlob.att_charset = p.getInt();
			break;

		default:
			isqlGlob.printf("Internal error: Unexpected isc_info_value %d%s",
							item, NEWLINE);
			break;
		}
	}

	if (isqlGlob.major_ods < ODS_VERSION8)
	{
		TEXT errbuf[MSG_LENGTH];
		IUTILS_msg_get(SERVER_TOO_OLD, errbuf);
		STDERROUT(errbuf);
		return;
	}

	// If the remote server did not respond to our request for
	// "dialects spoken", then we can assume it can only speak
	// the V5 dialect.  We automatically change the connection
	// dialect to that spoken by the server.  Otherwise the
	// current dialect is set to whatever the user requested.

	if (global_dialect_spoken == 0)
		isqlGlob.SQL_dialect = SQL_DIALECT_V5;
	else if (isqlGlob.major_ods < ODS_VERSION10)
		isqlGlob.SQL_dialect = global_dialect_spoken;
	else if (isqlGlob.SQL_dialect == 0)	// client SQL dialect has not been set
		isqlGlob.SQL_dialect = global_dialect_spoken;

	if (global_dialect_spoken > 0)
		isqlGlob.db_SQL_dialect = global_dialect_spoken;
	else
		isqlGlob.db_SQL_dialect = SQL_DIALECT_V5;

	if (setValues.ExecPathDisplay[0])
		execSetDebugCommand();
}


void ISQL_ri_action_print(const TEXT* ri_action_str,
						  const TEXT* ri_action_prefix_str,
						  bool all_caps)
{
/**************************************
 *
 *	I S Q L _ r i _ a c t i o n _ p r i n t
 *
 **************************************
 *
 * Functional description
 *	prints the description of ref. integrity actions.
 *	  The actions must be one of the cascading actions or RESTRICT.
 *	  RESTRICT is used to indicate that the user did not specify any
 *	  actions, so do not print it out.
 *
 **************************************/
	for (const ri_actions* ref_int = ri_actions_all; ref_int->ri_action_name;
		++ref_int)
	{
		if (!strcmp(ref_int->ri_action_name, ri_action_str))
		{
			if (*ref_int->ri_action_print_caps)
			{
				// we have something to print
				if (all_caps)
					isqlGlob.printf("%s %s", ri_action_prefix_str, ref_int->ri_action_print_caps);
				else if (*ref_int->ri_action_print_mixed)
					isqlGlob.printf("%s %s", ri_action_prefix_str, ref_int->ri_action_print_mixed);
			}
			return;
		}
	}

	fb_assert(FALSE);
}


static bool get_numeric(const UCHAR* str2,
						USHORT length,
						SSHORT* scale,
						SINT64* ptr)
{
/**************************************
 *
 *	  g e t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	  Convert a numeric literal (str2) to its binary value.
 *
 *	  The binary value (int64) is stored at the
 *	  address given by ptr.
 *
 **************************************/
	SINT64 value = 0;

	SSHORT local_scale = 0, sign = 0;
	bool digit_seen = false, fraction = false;

	const UCHAR* const end = str2 + length;
	for (const UCHAR* p = str2; p < end; p++)
	{
		if (DIGIT(*p))
		{
			digit_seen = true;

			// Before computing the next value, make sure there will be
			// no overflow. Trying to detect overflow after the fact is
			// tricky: the value doesn't always become negative after an
			// overflow!

			if (value > INT64_LIMIT)
				return false;

			if (value == INT64_LIMIT)
			{
				// possibility of an overflow

				if ((*p > '8' && sign == -1) || (*p > '7' && sign != -1))
					return false;
			}

			// Force the subtraction to be performed before the addition,
			// thus preventing a possible signed arithmetic overflow.
			value = value * 10 + (*p - '0');
			if (fraction)
				--local_scale;
		}
		else if (*p == '.')
		{
			if (fraction)
				return false;

			fraction = true;
		}
		else if (*p == '-' && !digit_seen && !sign && !fraction)
			sign = -1;
		else if (*p == '+' && !digit_seen && !sign && !fraction)
			sign = 1;
		else if (*p != BLANK)
			return false;
	}

	if (!digit_seen)
		return false;

	*scale = local_scale;
	*(SINT64*) ptr = ((sign == -1) ? -value : value);
	return true;
}


// Helper to print boolean values in the SET options.
static void print_set(const char* str, bool v)
{
	isqlGlob.printf("%-25s%s%s", str, v ? "ON" : "OFF", NEWLINE);
}


static processing_state print_sets()
{
/**************************************
 *
 *	p r i n t _ s e t s
 *
 **************************************
 *
 * Functional description
 *	Print the current set values
 *
 **************************************/

	print_set("Print statistics:", setValues.Stats);
	print_set("Print per-table stats:", setValues.PerTableStats);
	print_set("Print wire stats:", setValues.WireStats);
	print_set("Echo commands:", setValues.Echo);
	print_set("List format:", setValues.List);
	print_set("Show Row Count:", setValues.Docount);
	//print_set("Row Count:", setValues.Docount);   // Changed print to the above to avoid confusion with next one
	isqlGlob.printf("%-25s%lu%s", "Select maxrows limit:", setValues.maxRows, NEWLINE);
	print_set("Autocommit DDL:", setValues.Autocommit);
	print_set("Access Plan:", setValues.Plan);
	print_set("Access Plan only:", setValues.Planonly);
	print_set("Explain Access Plan:", setValues.ExplainPlan);

	isqlGlob.printf("%-25s", "Display BLOB type:");
	switch (setValues.Doblob)
	{
	case ALL_BLOBS:
		isqlGlob.printf("ALL");
		break;
	case NO_BLOBS:
		isqlGlob.printf("NONE");
		break;
	default:
		isqlGlob.printf("%d", setValues.Doblob);
	}
	isqlGlob.printf(NEWLINE);

	if (setValues.ISQL_charset)
	{
		isqlGlob.printf(
			"%-25s%s%s",
			"Set names:",
			IUTILS_name_to_string(setValues.ISQL_charset.value()).c_str(),
			NEWLINE);
	}

	print_set("Column headings:", setValues.Heading);

	if (setValues.global_Cols.count())
	{
		isqlGlob.printf("Column print widths:%s", NEWLINE);
		const ColList::item* p = setValues.global_Cols.getHead();
		while (p)
		{
			isqlGlob.printf("%s%s width: %d%s", TAB_AS_SPACES, p->col_name, p->col_len, NEWLINE);
			p = p->next;
		}
	}

	print_set("Auto Term:", setValues.AutoTerm);

	isqlGlob.printf("%-25s%s%s", "Terminator:", isqlGlob.global_Term, NEWLINE);

	print_set("Time:", setValues.Time_display);
	print_set("Warnings:", setValues.Warnings);
	print_set("Bail on error:", setValues.BailOnError);
	isqlGlob.printf("%-25s%lu%s", "Local statement timeout:", setValues.StmtTimeout, NEWLINE);
	print_set("Keep transaction params:", setValues.KeepTranParams);
	if (setValues.KeepTranParams)
		isqlGlob.printf("    %s%s", TranParams->c_str(), NEWLINE);
	return SKIP;
}


static processing_state explain(const TEXT* command)
{
	Firebird::AutoSetRestore autoExplainCommand(&setValues.ExplainCommand, true);
	Firebird::AutoSetRestore autoPlanonly(&setValues.Planonly, true);
	Firebird::AutoSetRestore autoPlan(&setValues.Plan, true);
	Firebird::AutoSetRestore autoExplainPlan(&setValues.ExplainPlan, true);
	Firebird::AutoSetRestore autoSqldaDisplay(&setValues.Sqlda_display, false);

	process_statement(command);

	return SKIP;
}


static processing_state help(const TEXT* what)
{
/**************************************
 *
 *	h e l p
 *
 **************************************
 *
 * Functional description
 *	List the known commands.
 *
 **************************************/

	// Ordered list of help messages to display.  Use -1 to terminate list,
	// and 0 for an empty blank line
	static const SSHORT help_ids[] =
	{
		HLP_FRONTEND,			// Frontend commands:
		HLP_BLOBDMP,			// BLOBDUMP <blobid> <file>	-- dump BLOB to a file
		HLP_BLOBED,				// BLOBVIEW <blobid>		-- view BLOB in text editor
		HLP_EDIT,				// EDIT	 [<filename>]		-- edit SQL script file and execute
		HLP_EDIT2,				// EDIT						-- edit current command buffer and execute
		HLP_EXPLAIN,			// EXPLAIN					-- explain a query access plan
		HLP_HELP,				// HELP						-- display this menu
		HLP_INPUT,				// INput	<filename>		-- take input from the named SQL file
		HLP_OUTPUT,				// OUTput   [<filename>]	-- write output to named file
		HLP_OUTPUT2,			// OUTput					-- return output to stdout
		HLP_SET_ROOT,			// SET	  <option>			-- (use HELP SET for list)
		HLP_SHELL,				// SHELL	<command>		-- execute Operating System command in sub-shell
		HLP_SHOW,				// SHOW	 <object> [<name>]	-- display system information
		HLP_OBJTYPE,			//     <object> = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
		HLP_OBJTYPE2,			//                GENERATOR, GRANT, INDEX, PACKAGE, PROCEDURE, ROLE, SQL DIALECT,
		HLP_OBJTYPE3,			//                SYSTEM, TABLE, TRIGGER, VERSION, USERS, VIEW, WIRE_STATISTICS
		HLP_EXIT,				// EXIT					   -- exit and commit changes
		HLP_QUIT,				// QUIT					   -- exit and roll back changes
		0,
		HLP_ALL,				// All commands may be abbreviated to letters in CAPitals
		-1						// end of list
	};

	static const SSHORT help_set_ids[] =
	{
		HLP_SETCOM,				//Set commands:
		HLP_SET,				//	SET						-- display current SET options
		HLP_SETAUTO,			//	SET AUTOddl				-- toggle autocommit of DDL statements
		HLP_SETAUTOTERM,		//	SET AUTOTERM			-- toggle auto statement terminator with semicolon
		HLP_SETBAIL,			//	SET BAIL				-- toggle bailing out on errors in non-interactive mode
		HLP_SETBLOB,			//	SET BLOB [ALL|<n>]		-- display BLOBS of subtype <n> or ALL
		HLP_SETBLOB2,			//	SET BLOB				-- turn off BLOB display
		HLP_SETCOUNT,			//	SET COUNT				-- toggle count of selected rows on/off
		HLP_SETMAXROWS,			//	SET MAXROWS [<n>]		-- toggle limit of selected rows to <n>, zero is no limit
		HLP_SETECHO,			//	SET ECHO				-- toggle command echo on/off
		HLP_SETEXPLAIN,			//	SET EXPLAIN				-- toggle display of query plan in the explained form
		HLP_SETHEADING,			//  SET HEADING 	        -- toggle column titles display on/off
		HLP_SETKEEPTRAN,		//	SET KEEP_TRAN_params	-- toggle to keep or not to keep text of following successful SET TRANSACTION statement
		HLP_SETLIST,			//	SET LIST				-- toggle column or table display format
		HLP_SETNAMES,			//	SET NAMES <csname>		-- set name of runtime character set
		HLP_SETPERTAB,			//	SET PER_TABle_stats		-- toggle display of detailed per-table statistics
		HLP_SETPLAN,			//	SET PLAN				-- toggle display of query access plan
		HLP_SETPLANONLY,		//	SET PLANONLY			-- toggle display of query plan without executing
		HLP_SETSQLDIALECT,		//	SET SQL DIALECT <n>		-- set sql dialect to <n>
		HLP_SETSTAT,			//	SET STATs				-- toggle display of performance statistics
		HLP_SETTIME,			//	SET TIME				-- toggle display of timestamp with DATE values
		HLP_SETTERM,			//	SET TERM <string>		-- change statement terminator string
		HLP_SETWIDTH,			//	SET WIDTH <col> [<n>]	-- set/unset print width to <n> for column <col>
		HLP_SETWIRESTATS,		//	SET WIRE_stats			-- toggle display of wire (network) statistics
		0,
		HLP_ALL,				// All commands may be abbreviated to letters in CAPitals
		-1						// end of list
	};

	TEXT msg[MSG_LENGTH];
	const SSHORT* msgid;
	if (!strcmp(what, "SET")) {
		msgid = help_set_ids;
	}
	else {
		msgid = help_ids;
	}
	for (; *msgid != -1; msgid++)
	{
		if (*msgid != 0)
		{
			IUTILS_msg_get(*msgid, msg);
			IUTILS_printf(Help, msg);
		}
		IUTILS_printf(Help, NEWLINE);
	}
	return (SKIP);
}


static bool isyesno(const TEXT* buffer)
{
/**********************************************
 *
 *	i s y e s n o
 *
 **********************************************
 *
 * Functional description
 *	check if the first letter of the user's response
 *	corresponds to the first letter of Yes
 *	(in whatever language they are using)
 *
 *	returns true for Yes, otherwise false.
 *
 **********************************************/

	if (!have_trans)
	{
		// get the translation if we don't have it already
		IUTILS_msg_get(YES_ANS, sizeof(yesword), yesword);
		have_trans = true;
	}

	// Just check first byte of yes response -- could be multibyte problem

	return UPPER7(buffer[0]) == UPPER7(yesword[0]);
}


static bool printUser(const char* dbName)
{
	unsigned char info[] = {fb_info_username, fb_info_sqlrole};
	unsigned char buffer[(1 + 2 + MAX_SQL_IDENTIFIER_SIZE) * 2 + 2];
	string login, role;

	DB->getInfo(fbStatus, sizeof(info), info, sizeof(buffer), buffer);
	if (failed())
		return false;

	UCHAR* p = buffer;

	while (p)
	{
		unsigned int len;
		switch (*p++)
		{
		case fb_info_username:
			len = gds__vax_integer(p, 2);
			login.assign(p + 2, len);
			break;

		case fb_info_sqlrole:
			len = gds__vax_integer(p, 2);
			role.assign(p + 2, len);
			if (role == "NONE")
				role.erase();
			break;

		default:
			p = NULL;
			continue;
		}

		p += (2 + len);
	}

	if (login.hasData() || role.hasData())
	{
		bool wasOut = dbName && dbName[0];
		if (wasOut)
			isqlGlob.printf("Database: %s", dbName);

		if (login.hasData())
		{
			isqlGlob.printf("%sUser: %s", wasOut ? ", " : "", login.c_str());
			wasOut = true;
		}

		if (role.hasData())
		{
			isqlGlob.printf("%sRole: %s", wasOut ? ", " : "", role.c_str());
			wasOut = true;
		}

		if (wasOut)
			isqlGlob.printf("%s", NEWLINE);

		return true;
	}

	// fallback to SQL way to do job

	if (!frontendTransaction())
		return false;

	class FbTransCommit
	{
	public:
		~FbTransCommit()
		{
			if (DB && fbTrans)
			{
				fbTrans->rollback(fbStatus);
				if (succeeded())
					fbTrans = NULL;
			}
		}
	};
	FbTransCommit fbTransCommit;

	string sql;
	sql.printf(
		"SELECT CURRENT_USER, CURRENT_ROLE FROM %sRDB$DATABASE",
		(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""));

	Firebird::RefPtr<Firebird::IStatement> st(Firebird::REF_NO_INCR,
		DB->prepare(fbStatus, fbTrans, 0, sql.c_str(), 3, Firebird::IStatement::PREPARE_PREFETCH_METADATA));
	if (failed())
		return false;
	Firebird::RefPtr<Firebird::IMessageMetadata> m(Firebird::REF_NO_INCR,
		st->getOutputMetadata(fbStatus));
	if (failed())
		return false;
	unsigned bs = m->getMessageLength(fbStatus);
	if (failed())
		return false;
	Firebird::UCharBuffer outBuf;
	UCHAR* buf = outBuf.getBuffer(bs);
	st->execute(fbStatus, fbTrans, NULL, NULL, m, buf);
	if (failed())
		return false;

	struct FieldInfo
	{
		const char* text;
		const char* skip;
	};
	FieldInfo fieldInfo[2] = {
		{"User", NULL},
		{"Role", "NONE"}
	};

	bool wasOut = dbName && dbName[0];
	if (wasOut)
		isqlGlob.printf("Database: %s", dbName);

	for (unsigned i = 0; i < FB_NELEM(fieldInfo); ++i)
	{
		IsqlVar v;
		if (ISQL_fill_var(&v, m, i, buf) == ps_ERR)
			return false;
		if (*v.nullInd)
			continue;

		string txt;
		switch(v.type & ~1)
		{
		case SQL_TEXT:
			txt.assign(v.value.asChar, v.length);
			break;
		case SQL_VARYING:
			txt.assign(v.value.asVary->vary_string, v.value.asVary->vary_length);
			break;
		}

		txt.trim();

		if (fieldInfo[i].skip && txt == fieldInfo[i].skip)
			continue;

		isqlGlob.printf("%s%s: %s", wasOut ? ", " : "", fieldInfo[i].text, txt.c_str());
		wasOut = true;
	}

	if (wasOut)
		isqlGlob.printf("%s", NEWLINE);

	return true;
}


static processing_state newdb(const TEXT* dbname,
					const TEXT* usr,
					const TEXT* psw,
					int numbufs,
					const TEXT* sql_role_nm,
					bool start_user_trans)
{
/**************************************
 *
 *	n e w d b
 *
 **************************************
 *
 * Functional description
 *	Change the current database from what it was.
 *	This procedure is called when we first enter this program.
 *
 *	Parameters:	dbname	  -- Name of database to open
 *			usr		 -- user name, if given
 *			psw		 -- password, if given
 *			numbufs	 -- # of connection cache buffers, if given, 0 if not
 *			sql_role_nm -- sql role name
 *
 **************************************/
	// No name of a database, just return an error

	if (!dbname || !*dbname)
		return ps_ERR;

	// Since the dbname is set already, in the case where a database is specified
	// on the command line, we need to save it so ISQL_disconnect does not NULL it
	// out.  We will restore it after the disconnect.  The save_database buffer
	// will also be used to translate dbname to the proper character set.

	const SLONG len = strnlen(dbname, MAXPATHLEN - 1);
	SCHAR* save_database = (SCHAR*) ISQL_ALLOC(len + 1);
	if (!save_database)
		return ps_ERR;

	strncpy(save_database, dbname, len);
	save_database[len] = 0;
	ISQL_disconnect_database(false);
	strcpy(isqlGlob.global_Db_name, save_database);
	dbname = isqlGlob.global_Db_name;
	ISQL_FREE(save_database);

	TEXT local_psw[BUFFER_LENGTH256];
	TEXT local_usr[BUFFER_LENGTH256];
	TEXT local_sql_role[BUFFER_LENGTH256];

	// global user and passwords are set only if they are not originally set

	local_psw[0] = 0;
	local_usr[0] = 0;
	local_sql_role[0] = 0;

	if (usr)
		strcpy(local_usr, usr);
	if (psw)
		strcpy(local_psw, psw);

	// if local user is not specified, see if global options are
	// specified - don't let a global role setting carry forward if a
	// specific local user was specified

	if (sql_role_nm)
		strcpy(local_sql_role, sql_role_nm);

	if (!(strlen(local_sql_role)) && global_role)
		strcpy(local_sql_role, isqlGlob.Role);

	if (!(strlen(local_usr)) && global_usr)
		strcpy(local_usr, isqlGlob.User);

	if (!(strlen(local_psw)) && global_psw)
		strcpy(local_psw, Password);

	int local_numbufs = numbufs;
	if ((local_numbufs == 0) && has_global_numbufs)
		local_numbufs = global_numbufs;

	// Build up a dpb
	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::dpbList, MAX_DPB_SIZE);

	if (setValues.ISQL_charset)
	{
		const auto charSet = IUTILS_name_to_string(setValues.ISQL_charset.value());
		dpb.insertString(isc_dpb_lc_ctype, charSet.c_str(), charSet.length());
	}

    FB_SIZE_T l;
	if ((l = fb_strlen(local_usr))) {
		dpb.insertString(isc_dpb_user_name, local_usr, l);
	}

	if ((l = fb_strlen(local_psw))) {
		dpb.insertString(isc_dpb_password, local_psw, l);
	}

	if ((l = fb_strlen(local_sql_role)))
	{
		dpb.insertInt(isc_dpb_sql_dialect, isqlGlob.SQL_dialect);
		dpb.insertString(isc_dpb_sql_role_name, local_sql_role, l);
	}

	if (global_search_path && (l = fb_strlen(isqlGlob.SearchPath)))
		dpb.insertString(isc_dpb_search_path, isqlGlob.SearchPath, l);

	dpb.insertString(isc_dpb_blr_request_search_path, SYSTEM_SCHEMA);

	if (local_numbufs > 0) {
		dpb.insertInt(isc_dpb_num_buffers, local_numbufs);
	}

	if (Nodbtriggers)
		dpb.insertInt(isc_dpb_no_db_triggers, 1);

#ifdef TRUSTED_AUTH
	if (Trusted_auth) {
		dpb.insertTag(isc_dpb_trusted_auth);
	}
#endif

	{ // scope
		const TEXT* local_name = isqlGlob.global_Db_name;

		DB = fbProvider->attachDatabase(fbStatus, local_name, dpb.getBufferLength(), dpb.getBuffer());
		if (ISQL_errmsg(fbStatus))
		{
			isqlGlob.global_Db_name[0] = '\0';
			return FAIL;
		}

		// Make it read owner name to display grantor correctly
		SHOW_read_owner();

		// No use in cancel when running non-end-user operators
		DB->cancelOperation(fbStatus, fb_cancel_disable);
	} // scope

	perTableStats->reset();

	ISQL_get_version(false);

	if (*local_sql_role)
	{
		switch (isqlGlob.SQL_dialect)
		{
		case SQL_DIALECT_V5:
			// Uppercase the Sql isqlGlob.Role name
			IUTILS_make_upper(local_sql_role);
			break;
		case SQL_DIALECT_V6_TRANSITION:
		case SQL_DIALECT_V6:
			if (*local_sql_role == DBL_QUOTE || *local_sql_role == SINGLE_QUOTE)
			{
				// Remove the delimited quotes and escape quote from ROLE name.
				const TEXT end_quote = *local_sql_role;
				IUTILS_remove_and_unescape_quotes(local_sql_role, end_quote);
			}
			else {
				IUTILS_make_upper(local_sql_role);
			}
			break;
		default:
			break;
		}
	}

	// CVC: We do not require those pesky transactions for -x or -a options.
	// Metadata extraction works exclusively with default transaction gds__trans.

	if (start_user_trans)
	{
		// Start the user transaction and default transaction

		if (!M__trans)
		{
			M_Transaction();
			if (D__trans)
				commit_trans(&D__trans);
			if (setValues.Autocommit)
				D_Transaction();
		}
	}

	// CVC: Do not put the user and pw used to extract metadata in a script!
	// Only acknowledge user connection parameters in interactive logins.

	if (Interactive && !printUser(dbname))
	{
		if (local_usr[0] != '\0')
		{
			if (local_sql_role[0] != '\0')
			{
				isqlGlob.printf("Database:  %s, User: %s, Role: %s%s",
						dbname, local_usr, local_sql_role, NEWLINE);
			}
			else {
				isqlGlob.printf("Database:  %s, User: %s%s", dbname, local_usr, NEWLINE);
			}
		}
		else
		{
			if (local_sql_role[0] != '\0') {
				isqlGlob.printf("Database:  %s, Role:  %s%s", dbname, local_sql_role, NEWLINE);
			}
			else {
				isqlGlob.printf("Database:  %s%s", dbname, NEWLINE);
			}
		}
	}

	if (setValues.ExecPathDisplay[0])
		execSetDebugCommand();

	global_Stmt = NULL;

	check_autoterm();

	return SKIP;
}


static processing_state newinput(const TEXT* infile)
{
/**************************************
 *
 *	n e w i n p u t
 *
 **************************************
 *
 * Functional description
 *	Read commands from the named input file
 *
 *	Parameters:  infile -- Second word of the command line
 *		filelist is a stack of file pointers to
 *			return from nested inputs
 *
 *	The result of calling this is to point the
 *	global input file pointer, Ifp, to the named file.
 *
 **************************************/
	TEXT errbuf[MSG_LENGTH];

	// If there is no file name specified, return error
	if (!infile || !*infile) {
		return ps_ERR;
	}

	PathName file;

	if (PathUtils::isRelative(infile))
	{
		PathName newPath, temp;
		PathUtils::splitLastComponent(newPath, temp, Filelist->Ifp().fileName(false));

		PathUtils::concatPath(file, newPath, infile);
	}
	else
		file = infile;

	// filelist is a linked list of file pointers.  We must add a node to
	// the linked list before discarding the current Ifp.
	// Filelist is a global pointing to base of list.

	FILE* fp = os_utils::fopen(file.c_str(), "r");
	if (fp)
	{
		Filelist->insertIfp();
		Filelist->Ifp().init(fp, file.c_str(), infile);
	}
	else
	{
		IUTILS_msg_get(FILE_OPEN_ERR, errbuf, SafeArg() << infile);
		STDERROUT(errbuf);
		return FAIL;
	}

	Input_file = true;
	return SKIP;
}


static processing_state newoutput(const TEXT* outfile)
{
/**************************************
 *
 *	n e w o u t p u t
 *
 **************************************
 *
 * Functional description
 *	Change the current output file
 *
 *	Parameters:  outfile : Name of file to receive query output
 *
 **************************************/
	processing_state ret = SKIP;
	// If there is a file name, attempt to open it for append

	if (*outfile)
	{
		FILE* fp = os_utils::fopen(outfile, "a");
		if (fp)
		{
			if (isqlGlob.Out && isqlGlob.Out != stdout)
				fclose(isqlGlob.Out);
			isqlGlob.Out = fp;
			if (Merge_stderr)
				isqlGlob.Errfp = isqlGlob.Out;
			if (Merge_diagnostic)
			    Diag = isqlGlob.Out;
		}
		else
		{
			TEXT errbuf[MSG_LENGTH];
			IUTILS_msg_get(FILE_OPEN_ERR, errbuf, SafeArg() << outfile);
			STDERROUT(errbuf);
			ret = FAIL;
		}
	}
	else
	{
		// Revert to stdout
		if (isqlGlob.Out != stdout)
		{
			fclose(isqlGlob.Out);
			isqlGlob.Out = stdout;
			if (Merge_stderr)
				isqlGlob.Errfp = isqlGlob.Out;
			if (Merge_diagnostic)
			    Diag = isqlGlob.Out;
		}
	}
	return (ret);
}


static processing_state newsize(const TEXT* colname, const TEXT* sizestr)
{
/**************************************
 *
 *	n e w s i z e
 *
 **************************************
 *
 * Functional description
 *	Add a column name and print width to collist
 *
 **************************************/
	if (!*colname || strlen(colname) > MAX_SQL_IDENTIFIER_LEN)
		return ps_ERR;

	// If no size is given, remove the entry
	if (!*sizestr)
	{
		// We don't signal error if the item to be removed doesn't exist.
		setValues.global_Cols.remove(colname);
		return SKIP;
	}

	const int size = atoi(sizestr);
	if (size <= 0)
		return ps_ERR;

	// We don't care if it was insertion or replacement.
	setValues.global_Cols.put(colname, size);
	return SKIP;
}

static processing_state newMaxRows(const TEXT* newMaxRowsStr)
{
/**************************************
 *
 *	newMaxRows
 *
 **************************************
 *
 * Functional description
 * Sets the new value for the setValues.maxRows limit (max rows to be retrieved).
 *
 **************************************/

	char* p;

	errno = 0;
	const long newMaxRows = strtol(newMaxRowsStr, &p, 10);
	// I was going to use this one, but "-1" parses as max ulong without error
	// and it would be politer to give an error.
	//const ULONG newMaxRows = strtoul(newMaxRowsStr, &p, 10);

	// CVC: I added this block because Windows wasn't working according to Mark's
	// expectation: it only produces ERANGE. Thus, garbage like
	// set maxrows abs;  wasn't caught.
	if (p == newMaxRowsStr)
	{
		IUTILS_put_errmsg(MAXROWS_INVALID, SafeArg() << newMaxRowsStr);
		return ps_ERR;
	}

	switch (errno)
	{
	case 0: // everything correct
		break;
	case ERANGE:
		// Only ERANGE is part of the ANSI standard here.
		IUTILS_put_errmsg(MAXROWS_OUTOF_RANGE, SafeArg() << newMaxRowsStr << SLONG_MAX);
		return ps_ERR;
	default:
		// EINVAL and the like
		IUTILS_put_errmsg(MAXROWS_INVALID, SafeArg() << newMaxRowsStr);
		return ps_ERR;
	}

	if (newMaxRows < 0)
	{
		IUTILS_put_errmsg(MAXROWS_NEGATIVE, SafeArg() << newMaxRowsStr);
		return ps_ERR;
	}

	setValues.maxRows = newMaxRows;
	return SKIP;
}


static processing_state newtrans(const TEXT* statement)
{
/**************************************
 *
 *	n e w t r a n s
 *
 **************************************
 *
 * Functional description
 *	Intercept and handle a set transaction statement by zeroing M__trans
 *
 *	Leave the default transaction, fbTrans, alone
 *	Parameters:  The statement in its entirety
 *
 **************************************/

	if (!ISQL_dbcheck())
		return FAIL;

	if (end_trans() == FAIL)
		return FAIL;

	M__trans = 0;

	// M__trans = 0 after the commit or rollback. Ready for a new transaction

	M__trans = DB->execute(fbStatus, NULL, 0, statement, isqlGlob.SQL_dialect,
		NULL, NULL, NULL, NULL);
	if (ISQL_errmsg(fbStatus))
	{
		return FAIL;
	}

	if (setValues.KeepTranParams)
		TranParams->assign(statement);

	return SKIP;
}


static processing_state parse_arg(int argc, SCHAR** argv, QualifiedMetaString& tabname)
//	, FILE** sess) Last param was for wisql
{
/**************************************
 *
 *	p a r s e _ a r g
 *
 **************************************
 *
 * Functional description
 *	Parse command line flags
 *	All flags except database are -X.  Look for
 *	the - and make it so.
 *
 **************************************/
	processing_state ret = SKIP;

	TEXT errbuf[MSG_LENGTH];

	// Initialize database name

	isqlGlob.global_Db_name[0] = '\0';
	isqlGlob.global_Target_db[0] = '\0';
	Password[0] = '\0';
	isqlGlob.User[0] = '\0';
	isqlGlob.Role[0] = '\0';
	global_numbufs = 0;
	Quiet = false;
	Exit_value = FINI_OK;

	// default behavior in V6.0 is SQL_DIALECT_V6

	requested_SQL_dialect = SQL_DIALECT_V6;

	Merge_stderr = false;
	Merge_diagnostic =  false;

	setValues.ISQL_charset.reset();

	// redirected stdin means act like -i was set

	Filelist->Ifp().init(stdin, "stdin", "stdin");

	// Terminators are initialized

	isqlGlob.Termlen = strlen(DEFTERM);
	if (isqlGlob.Termlen < MAXTERM_SIZE)
		strcpy(isqlGlob.global_Term, DEFTERM);
	else
	{
		isqlGlob.Termlen = MAXTERM_SIZE - 1;
		fb_utils::copy_terminate(isqlGlob.global_Term, DEFTERM, isqlGlob.Termlen + 1);
	}

	// Initialize list of input file pointers

	//Filelist->clear();

	// Interpret each command line argument

	const SCHAR switchchar = '-';

#ifdef	DEV_BUILD
	bool istable = false;
#endif

	Switches switches(isql_in_sw_table, FB_NELEM(isql_in_sw_table), true, true);

	for (int i = 1; i < argc; ++i)
	{
		const char* s = argv[i];
		// Look at flags to find unique match.  If the flag has an arg,
		// advance the pointer (and i).  Only change the return value
		// for extract switch or error.
		if (*s == switchchar)
		{
			int swid = IN_SW_ISQL_0;
			int swarg_int = 0;
			char* swarg_str = NULL;

			string s2(s);
			Switches::in_sw_tab_t* option = switches.findSwitchMod(s2);
			if (option)
			{
				swid = option->in_sw;
				if (option->in_sw_state)
				{
					IUTILS_msg_get(USAGE_DUPSW, errbuf, SafeArg() << s);
					STDERROUT(errbuf);
					ret = ps_ERR;
					break;
				}
				//option->in_sw_state = true; It's not enough with switches that have multiple spellings
				switches.activate(swid);

				switch (option->in_sw_optype)
				{
				case iqoArgNone: // nothing to do
					break;
				case iqoArgString:
				case iqoArgInteger:
					// make sure swarg_str is really a pointer to argv, not something else !!
					if (++i < argc)
						swarg_str = argv[i];
					if (!swarg_str || !*swarg_str)
					{
						IUTILS_msg_get(USAGE_NOARG, errbuf, SafeArg() << s);
						STDERROUT(errbuf);
						ret = ps_ERR;
					}
					else if (option->in_sw_optype == iqoArgInteger)
					{
						char* err;
						long value = strtol(swarg_str, &err, 10);
						if (*err)
						{
							// conversion error
							IUTILS_msg_get(USAGE_NOTINT, errbuf, SafeArg() << swarg_str << s);
							STDERROUT(errbuf);
							ret = ps_ERR;
						}
						else if ((value < INT_MIN) || (value > INT_MAX))
						{
							IUTILS_msg_get(USAGE_RANGE, errbuf, SafeArg() << swarg_str << s);
							STDERROUT(errbuf);
							ret = ps_ERR;
						}
						else {
							swarg_int = (int) value;
						}
					}
					break;
				default:
					fb_assert(false);
				}
			}

			// Quit the loop of interpreting if we got an error
			if (ret == ps_ERR)
				break;

			switch (swid)
			{
#ifdef DEV_BUILD
				case IN_SW_ISQL_EXTRACTTBL:
					istable = true;
					ret = EXTRACT;
					break;
#endif
				case IN_SW_ISQL_EXTRACT:
					ret = EXTRACT;
					break;

				case IN_SW_ISQL_EXTRACTALL:
					ret = EXTRACTALL;
					break;

				case IN_SW_ISQL_BAIL:
					setValues.BailOnError = true;
					break;

				case IN_SW_ISQL_ECHO:
					setValues.Echo = true;
					break;

				case IN_SW_ISQL_MERGE:
					Merge_stderr = true;
					break;

				case IN_SW_ISQL_MERGE2:
					Merge_diagnostic = true;
					break;

				case IN_SW_ISQL_NOAUTOCOMMIT:
					setValues.Autocommit = false;
					break;

				case IN_SW_ISQL_NODBTRIGGERS:
					Nodbtriggers = true;
					break;

				case IN_SW_ISQL_NOWARN:
					setValues.Warnings = false;
					break;

				case IN_SW_ISQL_OUTPUT:
					if (newoutput(swarg_str) == FAIL) {
						ret = ps_ERR;
					}
					break;

				case IN_SW_ISQL_INPUT:
					if (newinput(swarg_str) == SKIP) {
						Interactive = false;
					}
					else {
						ret = ps_ERR;
					}
					// CVC: Set by newinput() above only if successful.
					// Input_file = true;
					break;

				case IN_SW_ISQL_TERM:
					setValues.AutoTerm = false;
					isqlGlob.Termlen = strlen(swarg_str);
					if (isqlGlob.Termlen >= MAXTERM_SIZE) {
						isqlGlob.Termlen = MAXTERM_SIZE - 1;
					}
					fb_utils::copy_terminate(isqlGlob.global_Term, swarg_str, isqlGlob.Termlen + 1);
					break;

				case IN_SW_ISQL_DATABASE:
					fb_utils::copy_terminate(isqlGlob.global_Target_db, swarg_str, sizeof(isqlGlob.global_Target_db));
					break;

				case IN_SW_ISQL_PAGE:
					if (swarg_int < 0)
					{
						IUTILS_msg_get(USAGE_RANGE, errbuf, SafeArg() << swarg_str << s);
						STDERROUT(errbuf);
						ret = ps_ERR;
					}
					else if (swarg_int == 0) // let's interpret -pag 0 as SET HEADING OFF
						setValues.Heading = false;
					Pagelength = swarg_int;
					break;

				case IN_SW_ISQL_PASSWORD:
					fb_utils::copy_terminate(Password, fb_utils::get_passwd(swarg_str), sizeof(Password));
					// make sure swarg_str is really a pointer to argv, not something else !!
					global_psw = true;
					break;

				case IN_SW_ISQL_FETCHPASS:
				{
					const char* pass = NULL;
					const fb_utils::FetchPassResult rez = fb_utils::fetchPassword(swarg_str, pass);
					if (rez == fb_utils::FETCH_PASS_OK)
					{
						fb_utils::copy_terminate(Password, pass, sizeof(Password));
						global_psw = true;
					}
					else
					{
						switch (rez)
						{
						case fb_utils::FETCH_PASS_FILE_OPEN_ERROR:
							IUTILS_msg_get(PASS_FILE_OPEN, errbuf, SafeArg() << swarg_str << errno);
							// could not open password file @1, errno @2
							break;
						case fb_utils::FETCH_PASS_FILE_READ_ERROR:
							IUTILS_msg_get(PASS_FILE_READ, errbuf, SafeArg() << swarg_str << errno);
							// could not read password file @1, errno @2
							break;
						case fb_utils::FETCH_PASS_FILE_EMPTY:
							IUTILS_msg_get(EMPTY_PASS, errbuf, SafeArg() << swarg_str);
							// empty password file @1
							break;
						default:
							break;
						}
						STDERROUT(errbuf);
						ret = ps_ERR;
					}
					break;
				}

				case IN_SW_ISQL_USER:
					fb_utils::copy_terminate(isqlGlob.User, swarg_str, sizeof(isqlGlob.User));
					global_usr = true;
					break;

				case IN_SW_ISQL_ROLE:
					fb_utils::copy_terminate(isqlGlob.Role, swarg_str, sizeof(isqlGlob.Role));
					global_role = true;
					break;

				case IN_SW_ISQL_ROLE2:
					strcpy(isqlGlob.Role, "\"");
					fb_utils::copy_terminate(isqlGlob.Role + 1, swarg_str, sizeof(isqlGlob.Role) - 2);
					strcat(isqlGlob.Role, "\"");
					global_role = true;
					break;

				case IN_SW_ISQL_SEARCH_PATH:
					fb_utils::copy_terminate(isqlGlob.SearchPath, swarg_str, sizeof(isqlGlob.SearchPath));
					global_search_path = true;
					break;

				case IN_SW_ISQL_CACHE:
					if (swarg_int <= 0)
					{
						IUTILS_msg_get(USAGE_RANGE, errbuf, SafeArg() << swarg_str << s);
						STDERROUT(errbuf);
						ret = ps_ERR;
					}
					global_numbufs = swarg_int;
					has_global_numbufs = true;
					break;

				case IN_SW_ISQL_CHARSET:
					setValues.ISQL_charset = QualifiedMetaString::parseSchemaObject(swarg_str);
					break;

				case IN_SW_ISQL_QUIET:
					Quiet = true;
					break;

#ifdef TRUSTED_AUTH
				case IN_SW_ISQL_TRUSTED:
					Trusted_auth = true;
					break;
#endif

				case IN_SW_ISQL_VERSION:
					Version_info = true;
					IUTILS_msg_get(VERSION, errbuf, SafeArg() << FB_VERSION);
					isqlGlob.printf("%s%s", errbuf, NEWLINE);
					break;

				case IN_SW_ISQL_SQLDIALECT:
					requested_SQL_dialect = swarg_int;
					if (requested_SQL_dialect < SQL_DIALECT_V5 ||
						requested_SQL_dialect > SQL_DIALECT_CURRENT)
					{
						ret = ps_ERR;
					}
					else
					{
						// requested_SQL_dialect is used to specify the database dialect
						// if SQL dialect was not specified.  Since it is possible to
						// have a client dialect of 2, force the database dialect to 3, but
						// leave the client dialect as 2
						isqlGlob.SQL_dialect = requested_SQL_dialect;
						if (requested_SQL_dialect == SQL_DIALECT_V6_TRANSITION)
						{
							Merge_stderr = true;
							requested_SQL_dialect = SQL_DIALECT_V6;
						}
					}
					break;

				case IN_SW_ISQL_AUTOTERM:
					setValues.AutoTerm = true;
					break;

				case IN_SW_ISQL_HELP:
					ret = ps_ERR;
					break;

				default: // unknown switch
					IUTILS_msg_get(SWITCH, errbuf, SafeArg() << s);
					STDERROUT(errbuf);
					ret = ps_ERR;

			}
		}
		else
		{
			// This is not a switch, it is a db_name
			if (isqlGlob.global_Db_name[0])
			{
				// We already have a database name
				IUTILS_msg_get(USAGE_DUPDB, errbuf, SafeArg() << isqlGlob.global_Db_name << s);
				STDERROUT(errbuf);
				ret = ps_ERR;
			}
			else
			{
				fb_utils::copy_terminate(isqlGlob.global_Db_name, s, sizeof(isqlGlob.global_Db_name));
#ifdef DEV_BUILD
				// If there is a table name, it follows
				if (istable && (++i < argc) && (s = argv[i]) && *s)
					tabname = QualifiedMetaString::parseSchemaObject(s);
#endif
			}
		}

		// Quit the loop of interpreting if we got an error
		if (ret == ps_ERR)
			break;
	}

	// If not input, then set up first filelist

	if (Filelist->readingStdin())
	{
		Filelist->insert(stdin, "stdin", "stdin");
		fb_assert(Filelist->count() == 1);
	}

	return ret;
}


static bool checkSpecial(TEXT* const p, const int length, const double value)
{
/**************************************
 *
 *	c h e c k S p e c i a l
 *
 **************************************
 *
 * Functional description
 *	Special case - Nan and Infinity.
 *	Some libraries (SFIO) work wrong with them.
 *
 **************************************/
	const TEXT* t = NULL;
	if (std::isnan(value))
		t = "NaN";
	else if (std::isinf(value))
		t = Firebird::isNegativeInf(value) ? "-Infinity" : "Infinity";
	else
		return false;

	if (setValues.List) {
		isqlGlob.printf("%s%s", t, NEWLINE);
	}
	sprintf(p, "%*.*s ", length, length, t);

	return true;
}


static unsigned print_item(TEXT** s, const IsqlVar* var, const unsigned length)
{
/**************************************
 *
 *	p r i n t _ i t e m
 *
 **************************************
 *
 * Functional description
 *	Print an SQL data item as described.
 *
 **************************************/
	const char* convErr = "Conversion error";
	TEXT d[64];
	TEXT* p = *s;
	*p = '\0';

	unsigned dtype = var->type;		// may be modified by print_item_blob()
	const int dscale = var->scale;

	if (setValues.List) {
		isqlGlob.printf("%-31s ", var->alias);
	}

	if (var->nullable && (*var->nullInd < 0))
	{
		// If field was missing print <null>

		if (setValues.List) {
			isqlGlob.printf("<null>%s", NEWLINE);
		}

		if (dtype == SQL_TEXT || dtype == SQL_VARYING || dtype == SQL_BOOLEAN)
			sprintf(p, "%-*.*s ", length, length, "<null>");
		else
			sprintf(p, "%*.*s ", length, length, "<null>");
	}
	else if (!strncmp(var->field, "DB_KEY", 6))
	{
		// Special handling for db_keys printed in hex

		// Keep a temp buf, d for building the binary string

		for (const TEXT* t = var->value.asChar; t < var->value.asChar + var->length; t++)
		{
			if (setValues.List) {
				isqlGlob.printf("%02X", (unsigned int) (UCHAR) *t);
			}
			else
			{
				sprintf(d, "%02X", (unsigned int) (UCHAR) *t);
				strcat(p, d);
			}
		}
		if (setValues.List)
			isqlGlob.printf(NEWLINE);
		else
			strcat(p, " ");
	}
	else
	{
		const ISC_QUAD* blobid;
		TEXT blobbuf[30];
		TEXT* str2;
		tm times;

		switch (dtype)
		{
		case SQL_ARRAY:

			// Print blob-ids only here

			blobid = var->value.blobid;
			sprintf(blobbuf, "%" xLONGFORMAT":%" xLONGFORMAT, blobid->gds_quad_high,
					blobid->gds_quad_low);
			sprintf(p, "%*s ", MAX(17, length), blobbuf);
			break;

		case SQL_BLOB:

			// Print blob-ids only here

			blobid = var->value.blobid;
			sprintf(blobbuf, "%" xLONGFORMAT":%" xLONGFORMAT, blobid->gds_quad_high,
					blobid->gds_quad_low);
			sprintf(p, "%*s ", MAX(17, length), blobbuf);
			if (setValues.List)
			{
				isqlGlob.printf("%s%s", blobbuf, NEWLINE);
				dtype = ISQL_print_item_blob(isqlGlob.Out, var, M__trans, setValues.Doblob);
				isqlGlob.printf(NEWLINE);
			}
			break;

		case SQL_SHORT:
		case SQL_LONG:
		case SQL_INT64:
			{
				SINT64 value;

				switch (dtype)
				{
				case SQL_SHORT:
					value = *var->value.asSmallint;
					break;
				case SQL_LONG:
					value = *var->value.asInteger;
					break;
				case SQL_INT64:
					value = *var->value.asBigint;
					break;
				}

				string str_buf;
				print_item_numeric(value, length, dscale, str_buf.getBuffer(length));
				sprintf(p, "%s ", str_buf.c_str());
				if (setValues.List)
				{
					str_buf.ltrim(); // Added 1999-03-23 to left-justify in LIST ON mode
					isqlGlob.printf("%s%s", str_buf.c_str(), NEWLINE);
				}
			}
			break;

		case SQL_FLOAT:
			{
				//
				// BRS 08 Aug 2003
				// MSVC6 has a bug in the g format when used with # and display
				// one digit more than the specified precision when the value is 0
				// The bug appears in TCS DSQL_DOMAIN_12 and 13
				//
				const double value = *var->value.asFloat;

				if (checkSpecial(p, length, value))
				{
				    break;
				}

#if defined(MINGW)
				if (value == 0)
				{
					sprintf(p, "% #*.*g ", length, (int) MIN(8, (length - 6)) - 1, value);
					if (setValues.List) {
						isqlGlob.printf("%.*g%s", FLOAT_LEN - 6 -1, value, NEWLINE);
					}
				}
				else
				{
					sprintf(p, "% #*.*g ", length, (int) MIN(8, (length - 6)), value);
					if (setValues.List) {
						isqlGlob.printf("%.*g%s", FLOAT_LEN - 6, value, NEWLINE);
					}
				}
#else
				sprintf(p, "% #*.*g ", length, (int) MIN(8, (length - 6)), value);
				if (setValues.List) {
					isqlGlob.printf("%.*g%s", FLOAT_LEN - 6, value, NEWLINE);
				}
#endif
			}
			break;

		case SQL_DOUBLE:
			{
				const double value = *var->value.asDouble;

				if (checkSpecial(p, length, value))
				{
				    break;
				}

				// Don't let numeric/decimal doubles overflow print length
				// Special handling for 0 -- don't test log for length
				unsigned rounded = 0;
				if (dscale && (!value ||
					(rounded = static_cast<unsigned int>(ceil(fabs(log10(fabs(value)))))) < length - 10))
				{
					unsigned precision = 0;

					// CVC: Test values are
					// select -2.488355210669293e+01 from rdb$database;
					// select +2.488355210669293e+01 from rdb$database;
					// select +2.488355210669293e-01 from rdb$database;
					// select -2.488355210669293e-01 from rdb$database;
					// and sprintf should return length + 1.
					// See http://tracker.firebirdsql.org/browse/CORE-1363
					// The only way to enter this code is with a literal value (see above).
					// Taking SQL_DOUBLE from table fields or expressions will
					// yield dscale being zero.
					// This means that dscale is not what Borland expected; it's simply
					// the length of the incoming literal.
					if (value > 1)
						precision = length - rounded - 1; // nnn.nnn
					else if (value >= 0)
						precision = length - 2; // 0.nnn
					else if (value >= -1)
						precision = length - 3; // -0.nnn
					else // -nnn.nnn
						precision = length - rounded - 2;

					// Take into account old database containing negative scales for double
					if (dscale < 0 && precision > unsigned(-dscale))
					{
						precision = -dscale;
					}

					sprintf(p, "%*.*f ", length, precision, value);

					if (setValues.List) {
						isqlGlob.printf("%.*f%s", precision, /*dscale,*/ value, NEWLINE);
					}
				}
				else
				{
#if defined(MINGW)
					if (value == 0)
					{
						sprintf(p, "% #*.*g ", length, (int) MIN(16, (length - 7)) - 1, value);
						if (setValues.List) {
							isqlGlob.printf("%#.*g%s", DOUBLE_LEN - 7 - 1, value, NEWLINE);
						}
					}
					else
					{
						sprintf(p, "% #*.*g ", length, (int) MIN(16, (length - 7)), value);
						if (setValues.List) {
							isqlGlob.printf("%#.*g%s", DOUBLE_LEN - 7, value, NEWLINE);
						}
					}
#else
					sprintf(p, "% #*.*g ", length, (int) MIN(16, (length - 7)), value);
					if (setValues.List) {
						isqlGlob.printf("%#.*g%s", DOUBLE_LEN - 7, value, NEWLINE);
					}
#endif
				}
			}
			break;

		case SQL_DEC16:
			{
				char decStr[Firebird::IDecFloat16::STRING_SIZE];
				if (isqlGlob.df16)
				{
					isqlGlob.df16->toString(fbStatus, var->value.asDec16, sizeof(decStr), decStr);
					if (ISQL_errmsg(fbStatus))
						strcpy(decStr, convErr);
				}
				else
					strcpy(decStr, convErr);

				if (setValues.List)
					isqlGlob.printf("%*.*s%s", int(sizeof(decStr) - 1), int(sizeof(decStr) - 1), decStr, NEWLINE);
				else
					sprintf(p, "%*.*s ", int(sizeof(decStr) - 1), int(sizeof(decStr) - 1), decStr);
			}
			break;

		case SQL_DEC34:
			{
				char decStr[Firebird::IDecFloat34::STRING_SIZE];
				if (isqlGlob.df34)
				{
					isqlGlob.df34->toString(fbStatus, var->value.asDec34, sizeof(decStr), decStr);
					if (ISQL_errmsg(fbStatus))
						strcpy(decStr, convErr);
				}
				else
					strcpy(decStr, convErr);

				if (setValues.List)
				{
					isqlGlob.printf("%*.*s%s", int(sizeof(decStr) - 1), int(sizeof(decStr) - 1),
						decStr, NEWLINE);
				}
				else
					sprintf(p, "%*.*s ", int(sizeof(decStr) - 1), int(sizeof(decStr) - 1), decStr);
			}
			break;

		case SQL_INT128:
			{
				char intStr[Firebird::IInt128::STRING_SIZE];
				if (isqlGlob.i128)
				{
					isqlGlob.i128->toString(fbStatus, var->value.asInt128, dscale, sizeof(intStr), intStr);
					if (ISQL_errmsg(fbStatus))
						strcpy(intStr, convErr);
				}
				else
					strcpy(intStr, convErr);

				if (setValues.List)
				{
					isqlGlob.printf("%*.*s%s", int(sizeof(intStr) - 1), int(sizeof(intStr) - 1),
						intStr, NEWLINE);
				}
				else
					sprintf(p, "%*.*s ", int(sizeof(intStr) - 1), int(sizeof(intStr) - 1), intStr);
			}
			break;

		case SQL_TEXT:
			str2 = var->value.asChar;
			// See if it is character set OCTETS
			if (var->charSet == 1)
			{
				const ULONG hex_len = 2 * var->length;
				TEXT* buff2 = (TEXT*) ISQL_ALLOC(hex_len + 1);
				// Convert the string to hex digits
				for (unsigned i = 0; i < var->length; i++) {
					sprintf(&buff2[i * 2], "%02X", (UCHAR)str2[i]);
				}
				buff2[hex_len] = 0;
				if (setValues.List) {
					isqlGlob.printf("%-*s%s", var->length, buff2, NEWLINE);
				}
				else
					sprintf(p, "%-*s ", length, buff2);
				ISQL_FREE(buff2);
			}
			else if (setValues.List)
				isqlGlob.printf("%-*.*s%s", var->length, var->length, str2, NEWLINE);
			else
			{
				IcuUtil::pad(p, var->charSet,
					static_cast<unsigned>(strnlen(var->value.asChar, var->length)),
					var->value.asChar, length, false);
				strcat(p, " ");
			}
			break;

		case SQL_VARYING:
			{
				vary* avary = var->value.asVary;

				// If CHARACTER SET OCTETS, print two hex digits per octet
				if (var->charSet == 1)
				{
					const ULONG hex_len = 2 * avary->vary_length;
					char* buff2 = static_cast<char*>(ISQL_ALLOC(hex_len + 1));
					char* bp = buff2;

					for (unsigned i = 0; i < avary->vary_length; i++, bp += 2)
					{
						sprintf(bp, "%02X",
						static_cast<UCHAR>(avary->vary_string[i]));
					}
					buff2[hex_len] = '\0'; // there is an extra byte for terminator

					if (setValues.List)
					{
						isqlGlob.printf("%s%s", buff2, NEWLINE);
					}
					else
					{
						// Truncate if necessary
						sprintf(p, "%-*.*s ", length, static_cast<unsigned int>(MIN(length, hex_len)), buff2);
					}
					ISQL_FREE(buff2);
				}
				else if (setValues.List)
					isqlGlob.printf("%-*.*s%s", avary->vary_length, avary->vary_length, avary->vary_string, NEWLINE);
				else
				{
					IcuUtil::pad(p, var->charSet, avary->vary_length, avary->vary_string, length, false);
					strcat(p, " ");
				}
				break;
			}

		case SQL_TIMESTAMP:
			{
				isc_decode_timestamp(var->value.asDateTime, &times);
				ULONG fractions = ((ULONG*) var->value.asChar)[1] % ISC_TIME_SECONDS_PRECISION;

				if (isqlGlob.SQL_dialect > SQL_DIALECT_V5)
				{
					sprintf(d, "%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d.%4.4" ULONGFORMAT,
							times.tm_year + 1900, (times.tm_mon + 1),
							times.tm_mday, times.tm_hour, times.tm_min,
							times.tm_sec,
							fractions);
				}
				else
				{
					if (setValues.Time_display)
						sprintf(d, "%2.2d-%s-%4.4d %2.2d:%2.2d:%2.2d.%4.4" ULONGFORMAT,
								times.tm_mday, alpha_months[times.tm_mon],
								times.tm_year + 1900, times.tm_hour, times.tm_min,
								times.tm_sec,
								fractions);
					else
						sprintf(d, "%2.2d-%s-%4.4d", times.tm_mday,
								alpha_months[times.tm_mon], times.tm_year + 1900);
				}

				sprintf(p, "%-*.*s ", length, length, d);

				if (setValues.List)
					isqlGlob.printf("%s%s", d, NEWLINE);

				break;
			}

		case SQL_TIMESTAMP_TZ:
		case SQL_TIMESTAMP_TZ_EX:
			{
				unsigned year, month, day, hours, minutes, seconds, fractions;
				char timeZone[TimeZoneUtil::MAX_SIZE];

				if (dtype == SQL_TIMESTAMP_TZ)
				{
					Firebird::UtilInterfacePtr()->decodeTimeStampTz(fbStatus, var->value.asDateTimeTz,
						&year, &month, &day, &hours, &minutes, &seconds, &fractions, sizeof(timeZone), timeZone);
				}
				else
				{
					Firebird::UtilInterfacePtr()->decodeTimeStampTzEx(fbStatus, var->value.asDateTimeTzEx,
						&year, &month, &day, &hours, &minutes, &seconds, &fractions, sizeof(timeZone), timeZone);
				}

				if (ISQL_errmsg(fbStatus))
					return ps_ERR;

				sprintf(d, "%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d.%4.4d %s",
						year, month, day, hours, minutes, seconds, fractions, timeZone);

				sprintf(p, "%-*.*s ", length, length, d);

				if (setValues.List)
					isqlGlob.printf("%s%s", d, NEWLINE);

				break;
			}

		case SQL_TYPE_TIME:
			{
				isc_decode_sql_time(var->value.asTime, &times);
				ULONG fractions = (*var->value.asTime) % ISC_TIME_SECONDS_PRECISION;

				sprintf(d, "%2.2d:%2.2d:%2.2d.%4.4" ULONGFORMAT,
						times.tm_hour, times.tm_min, times.tm_sec,
						fractions);

				sprintf(p, "%-*.*s ", length, length, d);

				if (setValues.List)
					isqlGlob.printf("%s%s", d, NEWLINE);

				break;
			}

		case SQL_TIME_TZ:
		case SQL_TIME_TZ_EX:
			{
				unsigned hours, minutes, seconds, fractions;
				char timeZone[TimeZoneUtil::MAX_SIZE];

				if (dtype == SQL_TIME_TZ)
				{
					Firebird::UtilInterfacePtr()->decodeTimeTz(fbStatus, var->value.asTimeTz, &hours, &minutes, &seconds,
						&fractions, sizeof(timeZone), timeZone);
				}
				else
				{
					Firebird::UtilInterfacePtr()->decodeTimeTzEx(fbStatus, var->value.asTimeTzEx, &hours, &minutes, &seconds,
						&fractions, sizeof(timeZone), timeZone);
				}

				if (ISQL_errmsg(fbStatus))
					return ps_ERR;

				sprintf(d, "%2.2d:%2.2d:%2.2d.%4.4d %s", hours, minutes, seconds, fractions, timeZone);

				sprintf(p, "%-*.*s ", length, length, d);

				if (setValues.List)
					isqlGlob.printf("%s%s", d, NEWLINE);

				break;
			}

		case SQL_TYPE_DATE:
			isc_decode_sql_date(var->value.asDate, &times);
			sprintf(d, "%4.4d-%2.2d-%2.2d", times.tm_year + 1900,
					(times.tm_mon + 1), times.tm_mday);

			sprintf(p, "%-*.*s ", length, length, d);
			if (setValues.List) {
				isqlGlob.printf("%s%s", d, NEWLINE);
			}
			break;

		case SQL_BOOLEAN:
			strcpy(d, (*var->value.asBoolean ? "<true>" : "<false>"));
			sprintf(p, "%-*.*s ", length, length, d);
			if (setValues.List)
				isqlGlob.printf("%s%s", d, NEWLINE);
			break;

		default:
			sprintf(d, "Unknown type: %d", dtype);
			sprintf(p, "%-*s ", length, d);
			if (setValues.List) {
				isqlGlob.printf("%s%s", d, NEWLINE);
			}
			break;
		}
	}

	while (*p)
		++p;

	*s = p;

	return dtype;
}


processing_state ISQL_print_item_blob(FILE* fp, const IsqlVar* var, Firebird::ITransaction* trans, int subtype)
{
/******************************************
 *
 *	I S Q L _ p r i n t _ i t e m _ b l o b
 *
 ******************************************
 *
 * Functional description
 *	Print a User Selected BLOB field (as oppposed to
 *	any BLOB selected in a show or extract command)
 *
 **************************************/
	TEXT msg[MSG_LENGTH];

	ISC_QUAD* blobid = var->value.blobid;

	// Don't bother with null blobs

	if (UserBlob::blobIsNull(*blobid))
		return CONT;

	if ((var->subType != subtype) && (subtype != ALL_BLOBS))
	{
		IUTILS_msg_get(BLOB_SUBTYPE, msg, SafeArg() << subtype << var->subType);
		// Blob display set to subtype %d. This blob: subtype = %d\n
		IUTILS_printf(fp, msg);
		return CONT;
	}

	USHORT bpb_length = 0;
	const UCHAR* bpb = NULL;
	UCHAR bpb_buffer[64];
	ISC_BLOB_DESC from_desc;

	const int blob_subtype = var->subType;
	if (blob_subtype == isc_blob_text)
	{
		// ASF: Since ODS11.1, BLOBs are automatically transliterated to the client charset.
		if (isqlGlob.major_ods < ODS_VERSION11 ||
			(isqlGlob.major_ods == ODS_VERSION11 && isqlGlob.minor_ods == 0))
		{
			// Lookup the remaining descriptor information for the BLOB field,
			// most specifically we're interested in the Character Set so
			// we can set up a BPB that requests character set transliteration

			// CVC: Adriano changed trans to D__trans with the following comment:
			// Fix a bug that occur when a BLOB column is added after the start
			// of the DML transaction.
			// ASF: But use M__trans if D__trans is not started;
			from_desc.blob_desc_subtype = var->subType;
			from_desc.blob_desc_charset = var->charSet;

			ISC_BLOB_DESC to_desc;
			ISC_STATUS_ARRAY oldStat;
			isc_blob_default_desc(&to_desc, (const UCHAR*) var->relation, (const UCHAR*) var->field);
			if (!isc_blob_gen_bpb(oldStat, &to_desc, &from_desc, sizeof(bpb_buffer),
								  bpb_buffer, &bpb_length))
			{
				bpb = bpb_buffer;
			}
		}
	}
	else if (blob_subtype > isc_blob_text && blob_subtype < isc_blob_max_predefined_subtype)
	{
		bpb = predefined_blob_subtype_bpb;
		bpb_length = sizeof(predefined_blob_subtype_bpb);
		set_bpb_for_translation(blob_subtype);
	}

	Firebird::IBlob* blob = DB->openBlob(fbStatus, trans, blobid, bpb_length, bpb);
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}

	TEXT buffer[BUFFER_LENGTH512];

	do
	{
		unsigned int length;
		int cc = blob->getSegment(fbStatus, sizeof(buffer) - 1, buffer, &length);
		if (cc == Firebird::IStatus::RESULT_NO_DATA || cc == Firebird::IStatus::RESULT_ERROR)
			break;

		buffer[length] = 0;

		// Special displays for blr or acl subtypes

		if (blob_subtype > isc_blob_text && blob_subtype < isc_blob_max_predefined_subtype)
		{
			for (char* b = buffer + length - 1; b >= buffer;)
			{
				if (*b == '\n' || *b == '\t' || *b == BLANK)
					*b-- = 0;
				else
					break;
			}

			IUTILS_printf2(fp, "%s	%s%s", TAB_AS_SPACES, buffer, NEWLINE);
		}
		else
			IUTILS_printf(fp, buffer);

	} while (true);

	if (failed())
	{
		ISQL_errmsg(fbStatus);
		blob->close(fbStatus);
		return ps_ERR;
	}

	blob->close(fbStatus);
	return CONT;
}


static void print_item_numeric(SINT64 value, int length, int scale, TEXT* buf)
{
/**************************************
 *
 *	p r i n t _ i t e m _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Print a INT64 value into a buffer by accomodating
 *	decimal point '.' for scale notation
 *
 **************************************/
	// Handle special case of no negative scale, no '.' required!
	if (scale >= 0)
	{
		if (scale > 0)
			value *= (SINT64) pow(10.0, (double) scale);
		sprintf(buf, "%*" SQUADFORMAT, length, value);
		return;
	}

	const bool neg = (value < 0);

	// Use one less space than allowed, to leave room for '.'
	length--;
	sprintf(buf, "%*" SQUADFORMAT, length, value);

	// start from LSByte towards MSByte
	int from = length - 1;
	int to = length;

	// make space for decimal '.' point in buffer
	buf[to + 1] = '\0';
	for (; from >= 0 && DIGIT(buf[from]) && scale; from--, to--, ++scale)
		buf[to] = buf[from];

	// Check whether we need a '0' (zero) in front of the '.' point
	const bool all_digits_used = !DIGIT(buf[from]);

	// Insert new '0's to satisfy larger scale than input digits
	// For e.g: 12345 with scale -7 would be .0012345
	if (from > 0 && scale)
		do {
			buf[to--] = '0';
		} while (++scale != 0);

	// Insert '.' decimal point, and if required, '-' and '0'
	buf[to--] = '.';
	if (all_digits_used)
	{
		buf[to--] = '0';
		if (neg)
			buf[to--] = '-';
	}
}


static processing_state print_line(Firebird::IMessageMetadata* message, UCHAR* buf, const unsigned pad[], TEXT line[])
{
/**************************************
 *
 *	p r i n t _ l i n e
 *
 **************************************
 *
 * Functional description
 *	Print a line of SQL variables.
 *
 *	Args:  message, a message metadata
 *		pad = an array of the print lengths of all the columns
 *		line = pointer to the line buffer.
 *
 **************************************/
	const unsigned maxblob = 20;
	IsqlVar varlist[maxblob]; // No more than 20 blobs per line
	unsigned varnum = 0;

	{ // scope
		TEXT* p = line;
		unsigned n = message->getCount(fbStatus);
		if (ISQL_errmsg(fbStatus))
		{
			return ps_ERR;
		}
		for (unsigned i = 0; i < n; ++i)
		{
			IsqlVar var;
			if (ISQL_fill_var(&var, message, i, buf) == ps_ERR)
				return ps_ERR;

			if (!Interrupt_flag && !Abort_flag)
			{
				// Save all the blob vars and print them at the end
				// CVC: If varnum reaches 20, we must print an error instead of crashing.
				const int rc = print_item(&p, &var, pad[i]);
				if (rc == SQL_BLOB && varnum < maxblob)
					varlist[varnum++] = var;
			}
		}
		*p = 0;
	} // scope

	if (setValues.List)
	{
		isqlGlob.printf(NEWLINE);
		return (CONT);
	}

	isqlGlob.printf("%s%s", line, NEWLINE);

	// If blobdisplay is not wanted, set varnum back to 0

	if (setValues.Doblob == NO_BLOBS)
		varnum = 0;
	else if (varnum >= maxblob)
	{
		TEXT msg[MSG_LENGTH];
		IUTILS_msg_get(ONLY_FIRST_BLOBS, msg, SafeArg() << maxblob);
		isqlGlob.printf("%s%s", msg, NEWLINE);
	}

	// If there were Blobs to print, print them passing the blobid

	for (unsigned i = 0; i < varnum; i++)
	{
		const IsqlVar* var = &varlist[i];
		if (!var->nullable || *var->nullInd == 0)
		{
			// Print blob title

			isqlGlob.printf(
					"==============================================================================%s",
					NEWLINE);
			isqlGlob.printf("%s:  %s", var->alias, NEWLINE);
			if (ISQL_print_item_blob(isqlGlob.Out, var, M__trans, setValues.Doblob) != CONT)
				return (ps_ERR);
			isqlGlob.printf(
					"%s==============================================================================%s",
					NEWLINE, NEWLINE);
		}
	}
	return CONT;
}


// *********************************
// p r i n t _ p e r f o r m a n c e
// *********************************
// As the name implies, show performance as extracted from the API routines.
static processing_state print_performance(const SINT64* perf_before)
{
	// Translation of report strings. Do not remove "static" modifier.
	static bool have_report = false;
	static Firebird::GlobalPtr<string> diag;

	SINT64 perf_after[ISQL_COUNTERS];
	Firebird::UtilInterfacePtr()->getPerfCounters(fbStatus, DB, ISQL_COUNTERS_SET, perf_after);
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}

	if (!have_report)
	{
		TEXT report_1[MSG_LENGTH];
		IUTILS_msg_get(REPORT_NEW1, report_1);
		// Current memory = !\nDelta memory = !\nMax memory = !\nElapsed time = ~ sec\n
		diag->assign(report_1);

#ifndef WIN_NT
		IUTILS_msg_get(REPORT_NEW2, report_1);
		// Cpu = !u sec\n
		diag->append(report_1);
#endif

		IUTILS_msg_get(REPORT_NEW3, report_1);
		// Buffers = !b\nReads = !r\nWrites = !w\nFetches = !f\n
		diag->append(report_1);

		string::size_type p;
		while ((p = diag->find('!')) != string::npos)
			diag->replace(p, 1, "%" SQUADFORMAT);
		while ((p = diag->find('~')) != string::npos)
			diag->replace(p, 1, "%" SQUADFORMAT".%.3" SQUADFORMAT);

		have_report = true;
	}

	struct IsqlStatist
	{
		SINT64 curMem, deltaMem, maxMem;
		SINT64 realTime, cpu;
		SINT64 buffers, reads, writes, fetches;

		// ISQL_COUNTERS_SET = "CurrentMemory, MaxMemory, RealTime, UserTime, Buffers, Reads, Writes, Fetches"
		//						0			   1		  2			3		  4		   5	  6		  7
		IsqlStatist(const SINT64* b, const SINT64* a)
		{
			curMem = a[0];
			deltaMem = a[0] - b[0];
			maxMem = a[1];
			realTime = a[2] - b[2];
			cpu = a[3] - b[3];
			buffers = a[4];
			reads = a[5] - b[5];
			writes = a[6] - b[6];
			fetches = a[7] - b[7];
		}
	};

	IsqlStatist iStat(perf_before, perf_after);

	// counters: "%" SQUADFORMAT
	// time: "%" SQUADFORMAT".%.3" SQUADFORMAT
	IUTILS_printf2(Diag, diag->c_str(), iStat.curMem, iStat.deltaMem, iStat.maxMem,
		iStat.realTime / 1000, iStat.realTime % 1000,
#ifndef WIN_NT
		iStat.cpu / 1000, iStat.cpu % 1000,
#endif
		iStat.buffers, iStat.reads, iStat.writes, iStat.fetches);
	IUTILS_printf2(Diag, "%s", NEWLINE);

	return CONT;
}


// *********************************
// p r i n t _ m e s s a g e
// *********************************
// Show the contents of the input msg, used typically for parameters.
static void print_message(Firebird::IMessageMetadata* msg, const char* dir)
{
	unsigned n = msg->getCount(fbStatus);
	isqlGlob.printf(
			"\n%sPUT message field count: %d\n", dir, n);
	for (unsigned i = 0; i < n; ++i)
	{
		unsigned type = msg->getType(fbStatus, i);
		unsigned subtype = msg->getSubType(fbStatus, i);
		unsigned cs;
		isqlGlob.printf("%02d: sqltype: %d %s %sscale: %d subtype: %d len: %d",
				i + 1, type, sqltype_to_string(type), msg->isNullable(fbStatus, i) ? "Nullable " : "",
				msg->getScale(fbStatus, i), subtype, msg->getLength(fbStatus, i));

		switch(type)
		{
		case SQL_BLOB:
			if (subtype != 1)
				break;

		case SQL_TEXT:
		case SQL_VARYING:
			cs = msg->getCharSet(fbStatus, i);
			isqlGlob.printf(" charset: %d %s", cs, IUTILS_name_to_string(charset_to_string(cs)).c_str());
			break;
		}

		const auto schema = isqlGlob.major_ods >= ODS_VERSION14 ?
			msg->getSchema(fbStatus, i) : "";

		isqlGlob.printf("\n");
		isqlGlob.printf("  :  name: %s  alias: %s\n",
				msg->getField(fbStatus, i), msg->getAlias(fbStatus, i));
		isqlGlob.printf("  : table: %s  schema: %s  owner: %s\n",
				msg->getRelation(fbStatus, i), schema, msg->getOwner(fbStatus, i));
	}
}


// ***************************
// p r o c e s s _ h e a d e r
// ***************************
// Write into buffers the information that will be printed as page header for
// statements that return data.
static void process_header(Firebird::IMessageMetadata* msg, const unsigned pad[], TEXT header[], TEXT header2[])
{
	// Create the column header :  Left justify strings

	TEXT* p = header;
	TEXT* p2 = header2;
	unsigned n_cols = msg->getCount(fbStatus);
	if (ISQL_errmsg(fbStatus))
	{
		return;
	}

	for (unsigned i = 0; i < n_cols; ++i)
	{
		IsqlVar var;
		if (ISQL_fill_var(&var, msg, i, NULL) == ps_ERR)
			return;

		const unsigned type = var.type;

		IcuUtil::pad(p, isqlGlob.att_charset, static_cast<unsigned>(strlen(var.alias)), var.alias, pad[i],
			(type != SQL_TEXT && type != SQL_VARYING));
		strcat(p, " ");

		p += strlen(p);

		// Separators need not go on forever no more than a line
		unsigned limit = IcuUtil::charLength(
			isqlGlob.att_charset, static_cast<unsigned>(strlen(var.alias)), var.alias);
		limit = MAX(limit, pad[i]) + 1;

		for (unsigned j = 1; j < limit; j++)
			*p2++ = '=';
		*p2++ = BLANK;
	}
	*p2 = '\0';
}


// ***********************
// p r o c e s s _ p l a n
// ***********************
// Retrieve and show the server's execution plan.
// We don't consider critical a failure to get the plan, so we don't return
// any result to the caller.
static void process_plan()
{
	if (!global_Stmt)
		return;

	const char* plan = global_Stmt->getPlan(fbStatus, setValues.ExplainPlan ? FB_TRUE : FB_FALSE);
	if (ISQL_errmsg(fbStatus))
		return;

	ISQL_warning(fbStatus);

	if (plan != nullptr)
		IUTILS_printf2(Diag, "%s%s", plan, NEWLINE);
}


static void process_exec_path()
{
	if (!global_Stmt)
		return;

	Firebird::Array<UCHAR> pathBuffer;
	pathBuffer.getBuffer(MAX_USHORT, false);

	for (const UCHAR* code = setValues.ExecPathDisplay; *code; ++code)
	{
		global_Stmt->getInfo(fbStatus, 1, code, pathBuffer.getCount(), pathBuffer.begin());

		if (ISQL_errmsg(fbStatus))
			return;

		string pathString;

		for (const UCHAR* ptr = pathBuffer.begin(); ptr < pathBuffer.end();)
		{
			const UCHAR tag = *ptr++;

			if (tag == *code)
			{
				const USHORT len = (USHORT) gds__vax_integer(ptr, sizeof(USHORT));
				ptr += sizeof(USHORT);
				pathString.assign((const char*) ptr, len);
				ptr += len;
			}
			else if (tag == isc_info_end)
				break;
			else if (tag == isc_info_truncated)
			{
				pathString = "* error: overflow *\n";
				break;
			}
			else
				pathString = "* unknown error *\n";
		}

		if (pathString.hasData())
		{
			IUTILS_printf2(Diag, "%sExecution path (%s):%s%s%s", NEWLINE,
				(*code == isc_info_sql_exec_path_blr_text ? "BLR" :
				 "* unknown *"
				),
				NEWLINE, NEWLINE,
				pathString.c_str());
		}
	}
}


// ***************************************
// p r o c e s s _ r e c o r d _ c o u n t
// ***************************************
// Get number of records affected for updates, deletions and insertions.
// Return -1 if the statement is not one of those or if there's an error
// retrieving the information from the server.
static SINT64 process_record_count(const unsigned statement_type)
{
	if (!global_Stmt)
		return -1;
	UCHAR count_type = 0;

	// Skip selects, better to count records incoming later
	switch (statement_type)
	{
	case isc_info_sql_stmt_update:
		count_type = isc_info_req_update_count;
		break;
	case isc_info_sql_stmt_delete:
		count_type = isc_info_req_delete_count;
		break;
	case isc_info_sql_stmt_insert:
		count_type = isc_info_req_insert_count;
		break;
	}

	if (count_type)
	{
		const UCHAR count_info[] = { isc_info_sql_records };
		UCHAR count_buffer[33];
		global_Stmt->getInfo(fbStatus, sizeof(count_info), count_info,
			sizeof(count_buffer), count_buffer);
		if (ISQL_errmsg(fbStatus))
		{
			return -1;
		}

		if (count_buffer[0] == isc_info_sql_records)
		{
			SINT64 total = 0;
			const UCHAR* p = count_buffer + 3;
			while (*p != isc_info_end)
			{
				const UCHAR count_is = *p++;
				const SSHORT len = gds__vax_integer(p, 2);
				p += 2;
				const ULONG count = gds__vax_integer(p, len);
				p += len;
				// CVC: Do as StatementMetadata::getAffectedRecords() does:
				//if (count_is == count_type)
				//	return count;
				if (count_is != isc_info_req_select_count)
					total += count;
			}
			return total;
		}
	}
	return -1;
}


// *********************************************
// p r o c e s s _ m e s s a g e _ d i s p l a y
// *********************************************
// Calculate individual column widths and return total line width.
static unsigned process_message_display(Firebird::IMessageMetadata* message, unsigned pad[])
{
	unsigned linelength = 0;
	unsigned ncols = message->getCount(fbStatus);
	if (ISQL_errmsg(fbStatus))
	{
		return 0;
	}
	for (unsigned i = 0; i < ncols; ++i)
	{
		IsqlVar var;
		if (ISQL_fill_var(&var, message, i, NULL) == ps_ERR)
			return 0;

		// Record the length of name and var, then convert to print
		// length, later to be stored in pad array

		unsigned disp_length, alignment;
		disp_length = alignment = var.length;
		unsigned namelength = IcuUtil::charLength(isqlGlob.att_charset,
			static_cast<unsigned>(strlen(var.alias)), var.alias);

		// Minimum display length should not be less than that needed
		// for displaying null

		if (namelength < NULL_DISP_LEN)
			namelength = NULL_DISP_LEN;

		const unsigned type = var.type;
		const SSHORT charSet = TTYPE_TO_CHARSET(var.charSet);

		switch (type)
		{
		case SQL_BLOB:
		case SQL_ARRAY:
			// enough room for the blob id to print

			disp_length = 17;
			break;
		case SQL_TIMESTAMP:
			if (setValues.Time_display || isqlGlob.SQL_dialect > SQL_DIALECT_V5)
				disp_length = DATETIME_LEN;
			else
				disp_length = DATE_ONLY_LEN;
			break;
		case SQL_TIMESTAMP_TZ:
		case SQL_TIMESTAMP_TZ_EX:
			disp_length = DATETIME_TZ_LEN;
			break;
		case SQL_TYPE_TIME:
			disp_length = TIME_ONLY_LEN;
			break;
		case SQL_TIME_TZ:
		case SQL_TIME_TZ_EX:
			disp_length = TIME_TZ_ONLY_LEN;
			break;
		case SQL_TYPE_DATE:
			disp_length = DATE_ONLY_LEN;
			break;
		case SQL_FLOAT:
			disp_length = FLOAT_LEN;
			break;
		case SQL_DOUBLE:
			disp_length = DOUBLE_LEN;
			break;
		case SQL_DEC16:
			disp_length = Firebird::IDecFloat16::STRING_SIZE - 1;
			break;
		case SQL_INT128:
			disp_length = Firebird::IInt128::STRING_SIZE - 1;
			break;
		case SQL_DEC34:
			disp_length = Firebird::IDecFloat34::STRING_SIZE - 1;
			break;
		case SQL_TEXT:
			alignment = 1;
			// OCTETS data is displayed in hex
			if (charSet == CS_BINARY)
				disp_length = 2 * var.length;
			else if (charSet == CS_UNICODE_FSS)
				disp_length /= 3;
			else if (charSet == CS_UTF8)
				disp_length /= 4;
			break;
		case SQL_VARYING:
			alignment = sizeof(USHORT);
			// OCTETS data is displayed in hex
			if (charSet == CS_BINARY)
				disp_length = 2 * var.length;
			else if (charSet == CS_UNICODE_FSS)
				disp_length /= 3;
			else if (charSet == CS_UTF8)
				disp_length /= 4;
			break;
		case SQL_SHORT:
			disp_length = SHORT_LEN;
			break;
		case SQL_LONG:
			disp_length = LONG_LEN;
			break;
		case SQL_INT64:
			disp_length = INT64_LEN;
			break;
		case SQL_BOOLEAN:
			disp_length = BOOLEAN_LEN;
			break;
		default:
			disp_length = UNKNOWN_LEN;
			break;
		}

		// special case db_key alignment which arrives as an SQL_TEXT

		if (!strncmp(var.field, "DB_KEY", 6))
		{
			alignment = 8;
			disp_length = 2 * var.length;
		}

		// This is the print width of each column

		if (disp_length < namelength)
			disp_length = namelength;

		pad[i] = disp_length;

		// Is there a collist entry, then use that width, but only for text
		if (type == SQL_TEXT || type == SQL_VARYING)
		{
			if (!setValues.global_Cols.find(var.alias, &pad[i]) && setValues.global_Col_default)
				pad[i] = setValues.global_Col_default;
			disp_length = pad[i];

			if (charSet == CS_UNICODE_FSS)
				disp_length *= 3;
			else if (charSet == CS_UTF8)
				disp_length *= 4;
		}
		else if (isqlGlob.att_charset == CS_UNICODE_FSS)
			disp_length = MAX(disp_length, namelength * 3);
		else if (isqlGlob.att_charset == CS_UTF8)
			disp_length = MAX(disp_length, namelength * 4);

		// The total line length
		linelength += disp_length + 1;
	}

	return linelength;
}


static processing_state process_statement(const std::string& str)
{
/**************************************
 *
 *	p r o c e s s _ s t a t e m e n t
 *
 **************************************
 *
 * Functional description
 *	Prepare and execute a dynamic SQL statement.
 *	This function uses the isc_dsql user functions rather
 *	than embedded dynamic statements.  The user request
 *	is placed on transaction M__trans, while all
 *	background work is on the default fbTrans.
 *	This function now returns CONT (success) or ps_ERR.
 **************************************/

	// Here we actively use the fact that fb_cancel_enable/disable commands may be send many times.
	// They are ignored if cancel already has requested state. This let's us disable cancel
	// in the middle of processing, but do not care about special scope for CancelHolder variable.
	class CancelHolder
	{
	public:
		CancelHolder()
		{
			if (DB)
				DB->cancelOperation(fbStatus, fb_cancel_enable);
		}
		~CancelHolder()
		{
			if (DB)
				DB->cancelOperation(fbStatus, fb_cancel_disable);
		}
	};

	processing_state ret = CONT;

	// enable CANCEL during statement processing
	CancelHolder cHolder;

	// If somebody did a commit or rollback, we are out of a transaction

	if (!M_Transaction())
		return ps_ERR;

	// No need to start a default transaction unless there is no current one

	if (setValues.Autocommit)
	{
		if (!D_Transaction())
			return ps_ERR;
	}

	// If statistics are requested, then reserve them here

	SINT64 perf_before[ISQL_COUNTERS];
	if (setValues.Stats)
	{
		Firebird::UtilInterfacePtr()->getPerfCounters(fbStatus,
			DB, ISQL_COUNTERS_SET, perf_before);
		if (ISQL_errmsg(fbStatus))
		{
			return ps_ERR;
		}
	}

	if (setValues.PerTableStats)
		perTableStats->getStats(DB, true);

	IsqlWireStats wireStats(DB);
	if (setValues.WireStats)
		wireStats.get(true);

	// Prepare the dynamic query stored in string.
	// But put this on the DDL transaction to get maximum visibility of
	// metadata.

	Firebird::ITransaction* prepare_trans = setValues.Autocommit ? D__trans : M__trans;

	if (global_Stmt)
	{
		global_Stmt->free(fbStatus);
		if (ISQL_errmsg(fbStatus))
			return (SKIP);
	}

	unsigned flags = Firebird::IStatement::PREPARE_PREFETCH_METADATA;
	if (setValues.Plan)
	{
		if (setValues.ExplainPlan)
			flags |= Firebird::IStatement::PREPARE_PREFETCH_DETAILED_PLAN;
		else
			flags |= Firebird::IStatement::PREPARE_PREFETCH_LEGACY_PLAN;
	}

	if (setValues.AutoTerm)
		flags |= IStatement::PREPARE_REQUIRE_SEMICOLON;

	global_Stmt = DB->prepare(fbStatus, prepare_trans,
		0, str.c_str(), isqlGlob.SQL_dialect, flags);

	if (failed())
	{
		if (setValues.AutoTerm &&
			fb_utils::containsErrorCode(fbStatus->getErrors(), isc_command_end_err2))
		{
			return TRUNCATED;
		}

		if (isqlGlob.SQL_dialect == SQL_DIALECT_V6_TRANSITION && Input_file)
		{
			isqlGlob.printf("%s%s%s%s%s%s",
							NEWLINE,
							"**** Error preparing statement:",
							NEWLINE,
							NEWLINE,
							str.c_str(),
							NEWLINE);
		}
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	}

	// check for warnings
	ISQL_warning(fbStatus);

	global_Stmt->setTimeout(fbStatus, setValues.StmtTimeout);
	if (failed())
	{
		if (fbStatus->getErrors()[1] == isc_interface_version_too_old)
		{
			if (setValues.StmtTimeout)
			{
				setValues.StmtTimeout = 0;

				TEXT msg[MSG_LENGTH];
				IUTILS_msg_get(NO_TIMEOUTS, msg);
				// Timeouts are not supported by server
				isqlGlob.printf("%s%s", msg, NEWLINE);
			}
		}
		else
		{
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		}
	}

	// Find out what kind of statement this is
	const unsigned statement_type = global_Stmt->getType(fbStatus);
	if (failed())
	{
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	}
	if (!statement_type)
	{
		TEXT msg[MSG_LENGTH];
		IUTILS_msg_get(BAD_STMT_TYPE, msg);
		// Statement type is not recognized
		isqlGlob.printf("%s%s", msg, NEWLINE);
		return ps_ERR;
	}

	ISQL_warning(fbStatus);

	if (setValues.Sqlda_display)
	{
		const bool can_have_input_parameters =
			statement_type == isc_info_sql_stmt_select ||
			statement_type == isc_info_sql_stmt_insert ||
			statement_type == isc_info_sql_stmt_update ||
			statement_type == isc_info_sql_stmt_delete ||
			statement_type == isc_info_sql_stmt_exec_procedure ||
			statement_type == isc_info_sql_stmt_select_for_upd ||
			statement_type == isc_info_sql_stmt_get_segment;

		if (can_have_input_parameters)
		{
			Firebird::RefPtr<Firebird::IMessageMetadata>
				input(Firebird::REF_NO_INCR, global_Stmt->getInputMetadata(fbStatus));
			if (ISQL_errmsg(fbStatus))
			{
				return ps_ERR;
			}

			// check for warnings
			ISQL_warning(fbStatus);

			print_message(input, "IN");
		}
	}

	const bool is_selectable =
		statement_type == isc_info_sql_stmt_select ||
		statement_type == isc_info_sql_stmt_select_for_upd ||
		statement_type == isc_info_sql_stmt_exec_procedure ||
		statement_type == isc_info_sql_stmt_get_segment;

	// if PLAN is set and this is not DDL, print out the plan now

	if (setValues.Plan && statement_type != isc_info_sql_stmt_ddl &&
		statement_type != isc_info_sql_stmt_set_generator)
	{
		process_plan();

		if (setValues.ExplainCommand)
		{
			if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
				ret = ps_ERR;

			if (setValues.PerTableStats)
				perTableStats->getStats(DB, false);
		}

		if (setValues.Planonly && (!is_selectable || setValues.ExplainCommand))
			return ret;	// do not execute
	}

	if (setValues.ExecPathDisplay[0])
		process_exec_path();

	// If the statement isn't a select, execute it and be done

	if (!is_selectable && !setValues.Planonly)
	{

		// If this is an autocommit, put the DDL stmt on a special trans

		if (setValues.Autocommit &&
			(statement_type == isc_info_sql_stmt_ddl ||
			 statement_type == isc_info_sql_stmt_set_generator))
		{
			global_Stmt->execute(fbStatus, D__trans, nullptr, nullptr, nullptr, nullptr);
			setValues.StmtTimeout = 0;
			if (ISQL_errmsg(fbStatus))
			{
				ret = ps_ERR;
			}
			else
			{
				// check for warnings
				ISQL_warning(fbStatus);
			}

			// CVC: DDL statements that aren't syntax errors are caught by DFW
			// only at commit time, so we need to check here.
			// AP: fbStatus will be cleaned in commit_trans()
			if (!commit_trans(&D__trans))
				ret = ps_ERR;

			// check for warnings from COMMIT
			ISQL_warning(fbStatus);

			if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
				ret = ps_ERR;

			if (setValues.PerTableStats)
				perTableStats->getStats(DB, false);

			if (setValues.WireStats)
				wireStats.print(false);

			return ret;
		}

		// Check to see if this is a SET TRANSACTION statement

		if (statement_type == isc_info_sql_stmt_start_trans)
		{
			// CVC: Starting a txn can fail, too. Let's check it, although I
			// suspect isql will catch it in frontend_set() through StatementGetter,
			// so this place has little chance to be reached.
			if (newtrans(str.c_str()) == FAIL)
				return ps_ERR;

			if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
				ret = ps_ERR;

			if (setValues.PerTableStats)
				perTableStats->getStats(DB, false);

			if (setValues.WireStats)
				wireStats.print(false);

			return ret;
		}

		//  This is a non-select DML statement or trans

		M__trans = global_Stmt->execute(fbStatus, M__trans, NULL, NULL, NULL, NULL);
		setValues.StmtTimeout = 0;
		if (ISQL_errmsg(fbStatus))
		{
			// CVC: Make this conditional if it causes problems. For example
			// if (setValues.BailOnError)
			ret = ps_ERR;
		}

		// check for warnings
		ISQL_warning(fbStatus);

		// We are executing a commit or rollback, commit default trans

		if ((statement_type == isc_info_sql_stmt_commit) ||
			(statement_type == isc_info_sql_stmt_rollback))
		{
			// CVC: Commit may fail with AUTO-DDL off and DDL changes rejected by DFW.
			if (D__trans && !commit_trans(&D__trans))
				ret = ps_ERR;
		}

		// Print statistics report

		if (setValues.Docount)
		{
			const SINT64 count = process_record_count(statement_type);
			if (count >= 0)
			{
				TEXT rec_count_msg[MSG_LENGTH];
				IUTILS_msg_get(REC_COUNT, rec_count_msg, SafeArg() << count);
				// Records affected: %ld
				isqlGlob.printf("%s%s", rec_count_msg, NEWLINE);
			}
		}

		if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
			ret = ps_ERR;

		if (setValues.PerTableStats)
			perTableStats->getStats(DB, false);

		if (setValues.WireStats)
			wireStats.print(false);

		return ret;
	}

	Firebird::RefPtr<Firebird::IMessageMetadata>
		message(Firebird::REF_NO_INCR, global_Stmt->getOutputMetadata(fbStatus));
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}

	// check for warnings
	ISQL_warning(fbStatus);

	const unsigned n_cols = message->getCount(fbStatus);
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}

	// To facilitate debugging, the option
	// SET SQLDA_DISPLAY ON
	// will activate code to display the SQLDA after each statement.

	if (setValues.Sqlda_display)
		print_message(message, "OUT");

	if (setValues.Planonly)
		return ret;

	unsigned bufLen = message->getMessageLength(fbStatus);
	if (ISQL_errmsg(fbStatus))
	{
		return ps_ERR;
	}
	UCHAR* buffer = global_Buffer->getBuffer(bufLen);

	// Pad is an array of lengths to be passed to the print_item
	unsigned* pad = NULL;
	if (n_cols) {
		pad = (unsigned*) ISQL_ALLOC ((SLONG) (n_cols * sizeof(int)));
	}

	// Calculate display width and add a few for line termination, et al
    const SLONG linelength = process_message_display(message, pad) + 10;

	// Allocate the print line, the header line and the separator

	TEXT* line = (TEXT*) ISQL_ALLOC(linelength);
	TEXT* header = 0;
	TEXT* header2 = 0;

	if (setValues.Heading)
	{
		header = (TEXT*) ISQL_ALLOC(linelength);
		header2 = (TEXT*) ISQL_ALLOC(linelength);
		*header = '\0';
		*header2 = '\0';

		process_header(message, pad, header, header2);
	}

	// If this is an exec procedure, execute into the buffer with one fetch only

	if (statement_type == isc_info_sql_stmt_exec_procedure)
	{
		global_Stmt->execute(fbStatus, M__trans, NULL, NULL, message, buffer);
		setValues.StmtTimeout = 0;
		if (ISQL_errmsg(fbStatus))
		{
			ret = ps_ERR;
		}
		else
		{
			if (n_cols)
			{
				// do not output unnecessary white text
				isqlGlob.printf(NEWLINE);
				if (!setValues.List && setValues.Heading)
				{
					isqlGlob.printf("%s%s%s%s",
									header,
									NEWLINE,
									header2,
									NEWLINE);
				}
				print_line(message, buffer, pad, line);
				isqlGlob.printf(NEWLINE);
			}
		}
	}
	else
	{
		// Otherwise, open the cursor to start things up

		Firebird::IResultSet* curs = global_Stmt->openCursor(fbStatus, M__trans,
			NULL, NULL, message, 0);
		setValues.StmtTimeout = 0;
		if (ISQL_errmsg(fbStatus))
		{
			return ps_ERR;
		}

		// check for warnings
		ISQL_warning(fbStatus);

		// Now fetch and print records until EOF

#ifdef HAVE_TERMIOS_H
		int out_fd = fileno(isqlGlob.Out);
		if (isatty(out_fd))
		{
			struct termios tflags;
			if (tcgetattr(out_fd, &tflags) == 0)
			{
				tflags.c_lflag |= NOFLSH;
				tcsetattr(out_fd, TCSANOW, &tflags);
			}
		}
#endif

		const bool printHead = !setValues.List && setValues.Heading;
		unsigned int lines;
		for (lines = 0; !Interrupt_flag && !Abort_flag; ++lines)
		{

			// Check if exceeded setValues.maxRows value
			if (setValues.maxRows != 0 && lines >= setValues.maxRows)
				break;

			// Fetch the current cursor

			if (curs->fetchNext(fbStatus, buffer) == Firebird::IStatus::RESULT_NO_DATA)
				break;

			// Print the header every Pagelength number of lines for
			// command-line ISQL only.

			if (printHead &&
				((Pagelength && (lines % Pagelength == 0)) ||
				 (!Pagelength && !lines)))
			{
				isqlGlob.printf("%s%s%s%s%s",
								NEWLINE,
								header,
								NEWLINE,
								header2,
								NEWLINE);
			}

			if (!lines && !printHead)
				isqlGlob.printf(NEWLINE);

			if (ISQL_errmsg(fbStatus))
			{
				ret = ps_ERR;
				break;
			}

			// check for warnings
			ISQL_warning(fbStatus);

			ret = print_line(message, buffer, pad, line);
		}

		if (lines)
			isqlGlob.printf(NEWLINE);

		// Record count printed here upon request

		if (setValues.Docount)
		{
			TEXT rec_count_msg[MSG_LENGTH];
			IUTILS_msg_get(REC_COUNT, rec_count_msg, SafeArg() << lines);
			// Records affected: @1
			isqlGlob.printf("%s%s", rec_count_msg, NEWLINE);
		}

		curs->close(fbStatus);
		if (ISQL_errmsg(fbStatus))
		{
			return ps_ERR;
		}
	}

	// Avoid cancel during cleanup
	DB->cancelOperation(fbStatus, fb_cancel_disable);

	// Statistics printed here upon request

	if (setValues.Stats && (print_performance(perf_before) == ps_ERR))
		ret = ps_ERR;

	if (setValues.PerTableStats)
		perTableStats->getStats(DB, false);

	if (setValues.WireStats)
		wireStats.print(false);

	if (pad)
		ISQL_FREE(pad);
	if (line)
		ISQL_FREE(line);
	if (header)
		ISQL_FREE(header);
	if (header2)
		ISQL_FREE(header2);

	return (ret);
}


#ifdef WIN_NT
static BOOL CALLBACK query_abort(DWORD dwCtrlType)
#else
static int query_abort(const int reason, const int, void*)
#endif
{
/**************************************
 *
 *	q u e r y _ a b o r t
 *
 **************************************
 *
 * Functional description
 *	Signal handler for interrupting output of a query.
 *  Note: this function is currently used in completelly different ways in Windows x POSIX.
 *
 **************************************/

	bool flag = true;

#ifdef WIN_NT
	if (dwCtrlType != CTRL_C_EVENT)
		return FALSE;
#else
	if (reason != fb_shutrsn_signal)
	{
		return FB_SUCCESS;
	}
#endif

	if (DB)
	{
		Firebird::LocalStatus ls;
		Firebird::CheckStatusWrapper status(&ls);
		DB->cancelOperation(&status, fb_cancel_raise);
		flag = !(status.getState() & Firebird::IStatus::STATE_ERRORS);
	}

	if (flag)
	{
		if (Interactive)
			Interrupt_flag = true;
		else
			Abort_flag = true;
	}

#ifdef WIN_NT
	return TRUE;
#else
	// we do not want to proceed with shutdown except when exit() was called
	return FB_FAILURE;
#endif
}


// Detect if stdin is redirected, IE we aren't reading from the console.
static bool stdin_redirected()
{
#ifdef WIN_NT
	HANDLE in = GetStdHandle(STD_INPUT_HANDLE);
	const DWORD file_type = GetFileType(in);
	if (file_type == FILE_TYPE_CHAR)
		return false;
#else
	if (isatty(fileno(stdin)))
		return false;
#endif
	return true;
}


// CVC: There's something either wrong or on purpose in this routine:
// it doesn't unescape the embedded quotes that may exist.
// But it's useful for paths as it's now.
static void strip_quotes(const TEXT* in, TEXT* out)
{
/**************************************
 *
 *	s t r i p _ q u o t e s
 *
 **************************************
 *
 * Functional description
 *	Get rid of quotes around strings
 *
 **************************************/
	if (!in || !*in)
	{
		*out = 0;
		return;
	}

	TEXT quote = 0;
	// Skip any initial quote
	if ((*in == DBL_QUOTE) || (*in == SINGLE_QUOTE))
		quote = *in++;
	const TEXT* p = in;

	// Now copy characters until we see the same quote or EOS
	while (*p && (*p != quote)) {
		*out++ = *p++;
	}
	*out = 0;
}


static const char* sqltype_to_string(unsigned sqltype)
{
/**************************************
 *
 *	s q l t y p e _ t o _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Return a more readable version of SQLDA.sqltype
 *
 **************************************/
	switch (sqltype)
	{
	case SQL_TEXT:
		return "TEXT";
	case SQL_VARYING:
		return "VARYING";
	case SQL_SHORT:
		return "SHORT";
	case SQL_LONG:
		return "LONG";
	case SQL_INT64:
		return "INT64";
	case SQL_FLOAT:
		return "FLOAT";
	case SQL_DOUBLE:
		return "DOUBLE";
	case SQL_DEC16:
		return "DECFLOAT(16)";
	case SQL_DEC34:
		return "DECFLOAT(34)";
	case SQL_INT128:
		return "INT128";
	case SQL_D_FLOAT:
		return "D_FLOAT";
	case SQL_TIMESTAMP:
		return "TIMESTAMP";
	case SQL_TIMESTAMP_TZ:
		return "TIMESTAMP WITH TIME ZONE";
	case SQL_TIMESTAMP_TZ_EX:
		return "EXTENDED TIMESTAMP WITH TIME ZONE";
	case SQL_TYPE_DATE:
		return "SQL DATE";
	case SQL_TYPE_TIME:
		return "TIME";
	case SQL_TIME_TZ:
		return "TIME WITH TIME ZONE";
	case SQL_TIME_TZ_EX:
		return "EXTENDED TIME WITH TIME ZONE";
	case SQL_BLOB:
		return "BLOB";
	case SQL_ARRAY:
		return "ARRAY";
	case SQL_QUAD:
		return "QUAD";
	case SQL_BOOLEAN:
		return "BOOLEAN";
	case SQL_NULL:
		return "NULL";
	default:
		return UNKNOWN;
	}
}


static const QualifiedMetaString& charset_to_string(unsigned charset)
{
/**************************************
 *
 *	s q l t y p e _ t o _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Return a more readable version of SQLDA.sqltype
 *
 **************************************/
	static GlobalPtr<RightPooledMap<unsigned, QualifiedMetaString>> csMap;
	static const QualifiedMetaString UNKNOWN_CS("*unknown*");

	charset = TTYPE_TO_CHARSET(charset);

	if (const auto name = csMap->get(charset))
		return *name;

	csMap->clear();
	bool err = false;

	if (!frontendTransaction())
		return UNKNOWN_CS;

	FOR CS IN RDB$CHARACTER_SETS
		if (!err)
		{
			try
			{
				csMap->put(CS.RDB$CHARACTER_SET_ID, QualifiedMetaString(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME));
			}
			catch (const Firebird::Exception& ex)
			{
				err = true;
				ex.stuffException(fbStatus);
				ISQL_errmsg(fbStatus);
			}
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
	END_ERROR;

	if (const auto name = csMap->get(charset))
		return *name;

	return UNKNOWN_CS;
}


/// class PerTableStats

const unsigned char PerTableStats::m_items[] =
{
	isc_info_read_seq_count, isc_info_read_idx_count,
	isc_info_insert_count, isc_info_update_count, isc_info_delete_count,
	isc_info_backout_count, isc_info_purge_count, isc_info_expunge_count,
	isc_info_end
};

const char* PerTableStats::m_itemNames[] =
{
	" Natural", " Index",
	" Insert",  " Update", " Delete",
	" Backout", " Purge",  " Expunge"
};


void PerTableStats::getStats(Firebird::IAttachment* att, bool initial)
{
	if (initial)
		m_stat.clear();
	else if (!m_initialized)
		return;

	Firebird::Array<unsigned char> buffer(*getDefaultMemoryPool(), 32 * 1024);
	unsigned char* buff = buffer.begin();

	att->getInfo(fbStatus, sizeof(m_items), m_items, buffer.getCapacity(), buff);

	if (ISQL_errmsg(fbStatus))
		return;

	const unsigned char* p = buff;
	const unsigned char* end = buff + buffer.getCapacity();
	while (p < end)
	{
		StatItem item;

		item.statId = *p++;
		if (item.statId == isc_info_end)
			break;

		const FB_SIZE_T len = isc_portable_integer(p, 2);
		p += 2;
		const unsigned char* const end2 = p + len;
		while (p < end2)
		{
			item.relId = isc_portable_integer(p, 2);
			p += 2;
			item.value = isc_portable_integer(p, 4);
			p += 4;

			if (initial)
			{
				if (item.value)
					m_stat.add(item);
			}
			else
			{
				FB_SIZE_T pos;
				if (m_stat.find(item, pos))
				{
					m_stat[pos].value = item.value - m_stat[pos].value;
					if (m_stat[pos].value == 0)
						m_stat.remove(pos);
				}
				else if (item.value)
					m_stat.add(item);
			}
		}
	}

	if (!initial)
	{
		printStats(att);
		m_stat.clear();
	}
	m_initialized = initial;
}

void PerTableStats::reset()
{
	m_relNames.clear();
}

void PerTableStats::printStats(Firebird::IAttachment* att)
{
	if (m_stat.isEmpty())
		return;

	unsigned maxTabLen = loadRelNames(att);

	IUTILS_printf2(Diag, "Per table statistics:%s", NEWLINE);

	string h;

	const unsigned lenTable = maxTabLen < 32 ? 32 : FB_ALIGN(maxTabLen, 4);
	const unsigned lenValue = 9;

	h.append(lenTable, '-');
	h.append(1, '+');

	for (unsigned i = 0; i < ITEM_COUNT; i++)
	{
		h.append(lenValue, '-');
		h.append(1, '+');
	}

	IUTILS_printf2(Diag, "%s%s", h.c_str(), NEWLINE);

	string s;
	s.printf("%-*s|", lenTable, " Table name");

	for (unsigned i = 0; i < ITEM_COUNT; i++)
	{
		string l;
		l.printf("%-*s|", lenValue, m_itemNames[i]);

		s.append(l);
	}
	IUTILS_printf2(Diag, "%s%s", s.c_str(), NEWLINE);

	s = h;
	USHORT relId = MAX_USHORT;
	FB_SIZE_T lenName;
	for (const auto& item : m_stat)
	{
		if (relId != item.relId)
		{
			IUTILS_printf2(Diag, "%s%s", s.c_str(), NEWLINE);

			relId = item.relId;

			if (const auto relName = m_relNames.get(relId))
			{
				IcuUtil::pad(s.getBuffer(lenTable * 4 + 1), isqlGlob.att_charset,
							 relName->length(), relName->c_str(),
							 lenTable, false);
				s.recalculate_length();
				lenName = s.length();
				s += '|';
			}
			else
				s.printf("%-*d|", lenTable, item.relId);

			for (unsigned i = 0; i < ITEM_COUNT; i++)
			{
				s.append(lenValue, ' ');
				s.append(1, '|');
			}
		}

		for (unsigned i = 0; i < FB_NELEM(m_items) - 1; i++)
		{
			if (m_items[i] == item.statId)
			{
				string v;
				v.printf("%*" UQUADFORMAT, lenValue, item.value);

				FB_SIZE_T pos = lenName + 1 + (lenValue + 1) * i;
				pos += lenValue - v.length();
				s.replace(pos, v.length(), v.begin(), v.length());
			}
		}
	}

	if (relId)
	{
		IUTILS_printf2(Diag, "%s%s", s.c_str(), NEWLINE);
		IUTILS_printf2(Diag, "%s%s", h.c_str(), NEWLINE);
	}
}

unsigned PerTableStats::loadRelNames(Firebird::IAttachment* att)
{
	string sIds;

	unsigned maxLen = 0;
	USHORT relId = MAX_USHORT;
	for (StatItem* item = m_stat.begin(); item < m_stat.end(); item++)
	{
		if (relId == item->relId)
			continue;

		relId = item->relId;

		if (const auto nameStr = m_relNames.get(relId))
		{
			const unsigned len = IcuUtil::charLength(isqlGlob.att_charset, nameStr->length(), nameStr->c_str());
			if (maxLen < len)
				maxLen = len;

			continue;
		}

		string s;
		s.printf("%u", relId);

		if (!sIds.isEmpty())
			sIds.append(", ");
		sIds.append(s);
	}

	if (sIds.isEmpty())
		return maxLen;

	if (!frontendTransaction())
		return maxLen; // ?

	string sql;
	sql.printf(
		"SELECT RDB$RELATION_ID, RDB$RELATION_NAME%s FROM %sRDB$RELATIONS WHERE RDB$RELATION_ID IN (%s)",
		(isqlGlob.major_ods >= ODS_VERSION14 ? ", RDB$SCHEMA_NAME" : ""),
		(isqlGlob.major_ods >= ODS_VERSION14 ? "SYSTEM." : ""),
		sIds.c_str());

	Firebird::IResultSet* rs = att->openCursor(fbStatus, fbTrans,
		sql.length(), sql.c_str(), SQL_DIALECT_CURRENT,
		NULL, NULL, NULL, NULL,
		Firebird::IStatement::PREPARE_PREFETCH_METADATA);

	Firebird::IMessageMetadata* outMeta = rs->getMetadata(fbStatus);

	unsigned msgLen = outMeta->getMessageLength(fbStatus);
	Firebird::HalfStaticArray<char, 512> buff(msgLen);

	char* msg = buff.getBuffer(msgLen);

	if (outMeta->getType(fbStatus, 0) != SQL_SHORT)
		return maxLen;
	if (outMeta->getType(fbStatus, 1) != SQL_TEXT)
		return maxLen;

	SSHORT* pRelID = (SSHORT*) (msg + outMeta->getOffset(fbStatus, 0));
	SSHORT* pRelID_Null = (SSHORT*)(msg + outMeta->getNullOffset(fbStatus, 0));

	while (rs->fetchNext(fbStatus, msg) != Firebird::IStatus::RESULT_NO_DATA)
	{
		if (*pRelID_Null == FB_TRUE)
			continue;

		const MetaString relName(msg + outMeta->getOffset(fbStatus, 1), outMeta->getLength(fbStatus, 1));
		const MetaString relSchema(
			(isqlGlob.major_ods >= ODS_VERSION14 ? msg + outMeta->getOffset(fbStatus, 2) : nullptr),
			(isqlGlob.major_ods >= ODS_VERSION14 ? outMeta->getLength(fbStatus, 2) : 0)
		);

		const auto nameStr = IUTILS_name_to_string(QualifiedMetaString(relName, relSchema));

		const unsigned len = IcuUtil::charLength(isqlGlob.att_charset, nameStr.length(), nameStr.c_str());
		if (maxLen < len)
			maxLen = len;

		m_relNames.put(*pRelID, nameStr);
	}

	outMeta->release();
	rs->release();

	return maxLen;
}

/// class IsqlWireStats

bool IsqlWireStats::get(bool initial)
{
	if (!m_att)
		return false;

	const UCHAR info[] = {
		fb_info_wire_snd_packets,	fb_info_wire_rcv_packets,
		fb_info_wire_out_packets,	fb_info_wire_in_packets,
		fb_info_wire_snd_bytes,		fb_info_wire_rcv_bytes,
		fb_info_wire_out_bytes,		fb_info_wire_in_bytes,
		fb_info_wire_roundtrips,
		isc_info_end
	};

	UCHAR buffer[128];

	m_att->getInfo(fbStatus, sizeof(info), info, sizeof(buffer), buffer);

	if (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS)
		return false;

	Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer));
	for (; !p.isEof(); p.moveNext())
	{
		FB_UINT64* pField = nullptr;
		switch (p.getClumpTag())
		{
		case fb_info_wire_snd_packets:
			pField = &m_snd_packets;
			break;
		case fb_info_wire_rcv_packets:
			pField = &m_rcv_packets;
			break;
		case fb_info_wire_out_packets:
			pField = &m_out_packets;
			break;
		case fb_info_wire_in_packets:
			pField = &m_in_packets;
			break;
		case fb_info_wire_snd_bytes:
			pField = &m_snd_bytes;
			break;
		case fb_info_wire_rcv_bytes:
			pField = &m_rcv_bytes;
			break;
		case fb_info_wire_out_bytes:
			pField = &m_out_bytes;
			break;
		case fb_info_wire_in_bytes:
			pField = &m_in_bytes;
			break;
		case fb_info_wire_roundtrips:
			pField = &m_roundtrips;
			break;
		case isc_info_end:
			break;
		case isc_info_error:
			// don't return false here, as we not put error into status
			return true;
			/* uncomment to show error (isc_infunk) instead
			{
				ISC_STATUS errs[3] = { isc_arg_gds, 0, isc_arg_end };
				auto b = p.getBytes();
				errs[1] = isc_portable_integer(b + 1, p.getClumpLength() - 1);
				fbStatus->setErrors(errs);
				return false;
			}*/

		default:
			fb_assert(false);
			break;
		}

		if (pField)
		{
			const FB_UINT64 val = p.getBigInt();
			*pField = initial ? val : val - *pField;
		}
	}

	return true;
}

bool IsqlWireStats::print(bool initial)
{
	if (!get(initial))
	{
		ISQL_errmsg(fbStatus);
		return false;
	}

	IUTILS_printf2(Diag, "Wire logical statistics:%s", NEWLINE);
	IUTILS_printf2(Diag, "  send packets = %8" SQUADFORMAT "%s", m_out_packets, NEWLINE);
	IUTILS_printf2(Diag, "  recv packets = %8" SQUADFORMAT "%s", m_in_packets, NEWLINE);
	IUTILS_printf2(Diag, "  send bytes   = %8" SQUADFORMAT "%s", m_out_bytes, NEWLINE);
	IUTILS_printf2(Diag, "  recv bytes   = %8" SQUADFORMAT "%s", m_in_bytes, NEWLINE);

	IUTILS_printf2(Diag, "Wire physical statistics:%s", NEWLINE);
	IUTILS_printf2(Diag, "  send packets = %8" SQUADFORMAT "%s", m_snd_packets, NEWLINE);
	IUTILS_printf2(Diag, "  recv packets = %8" SQUADFORMAT "%s", m_rcv_packets, NEWLINE);
	IUTILS_printf2(Diag, "  send bytes   = %8" SQUADFORMAT "%s", m_snd_bytes, NEWLINE);
	IUTILS_printf2(Diag, "  recv bytes   = %8" SQUADFORMAT "%s", m_rcv_bytes, NEWLINE);
	IUTILS_printf2(Diag, "  roundtrips   = %8" SQUADFORMAT "%s", m_roundtrips, NEWLINE);

	return true;
}
